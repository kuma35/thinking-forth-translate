# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Leo Brodie
# This file is distributed under the same license as the Thinking Forth
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Thinking Forth 0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-18 19:06+0900\n"
"PO-Revision-Date: 2019-07-19 07:34+0900\n"
"Last-Translator: kuma35\n"
"Language: ja_JP\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../chapter6.rst:4
msgid "6. Factoring"
msgstr "第６章 ファクタリング(要素分解)"

#: ../../chapter6.rst:6
msgid ""
"In this chapter we’ll continue our study of the implementations phase, "
"this time focusing on factoring."
msgstr "私たちは実装フェイズについての研究を続けます。本章ではファクタリング(要素分解)に焦点を当てます。"

#: ../../chapter6.rst:9
msgid ""
"Decomposition and factoring are chips off the same block. Both involve "
"dividing and organizing. Decomposition occurs during preliminary design; "
"factoring occurs during detailed design and implementation."
msgstr "分解とファクタリング(要素分解)は、同じブロックから切り出されたものです。 どちらも分割と整理が関係しています。 分解は予備設計中に発生します。 ファクタリング(要素分解)は詳細な設計と実装の間に行われます。"

#: ../../chapter6.rst:13
msgid ""
"Since every colon definition reflects decisions of factoring, an "
"understanding of good factoring technique is perhaps the most important "
"skill for a Forth programmer."
msgstr "コロンの定義はすべてファクタリング(要素分解)の決定を反映しているので、優れたファクタリング(要素分解)手法を理解することは、おそらくForthプログラマにとって最も重要なスキルです。"

#: ../../chapter6.rst:17
msgid ""
"What is factoring? Factoring means organizing code into useful fragments."
" To make a fragment useful, you often must separate reusable parts from "
"non-reusable parts. The reusable parts become new definitions. The non-"
"reusable parts become arguments or parameters to the definitions."
msgstr "ファクタリング(要素分解)とは何でしょうか？ ファクタリング(要素分解)は、コードを有用な断片に整理することを意味します。 断片を有用とするには、再利用可能な部分と再利用不可能な部分を区別しなければならないことがよくあります。 再利用可能な部分は新しい定義になります。 再利用できない部分は、定義に対する引数またはパラメータになります。"

#: ../../chapter6.rst:23
msgid ""
"Making this separation is usually referred to as “factoring out.” The "
"first part of this chapter will discuss various “factoring-out” "
"techniques."
msgstr "この分離を行うことは、通常「括り出し(factoring out)」と呼ばれます。この章の最初の部分では、さまざまな「括り出し」手法について説明します。"

#: ../../chapter6.rst:27
msgid ""
"Deciding how much should go into, or stay out of, a definition is another"
" aspect of factoring. The second section will outline the criteria for "
"useful factoring."
msgstr "どの程度まで定義に入れるか、または定義から外れるかを決定することは、要素化のもう1つの側面です。 第2節では、有用なファクタリング(要素分解)の基準について概説します。"

#: ../../chapter6.rst:32
msgid "Factoring Techniques"
msgstr "ファクタリング(要素分解)技法"

#: ../../chapter6.rst:34
msgid ""
"If a module seems almost, but not quite, useful from a second place in "
"the system, try to identify and isolate the useful subfunction. The "
"remainder of the module might be incorporated in its original caller "
"(from \"**Structured Design**\" [stevens74-6]_ )."
msgstr "システム内で有用な箇所が２回以上現れる場合は、有用なサブ機能を識別して切り分けるようにしてください。モジュールの残りの部分は、元の呼び出し元に組み込まれる可能性があります( **Structured Design** [stevens74-6]_ )。"

#: ../../chapter6.rst:39
msgid ""
"The “useful subfunction” of course becomes the newly factored "
"definition.What about the part that “isn’t quite useful”? That depends on"
" what it is."
msgstr ""
"もちろん、「有用なサブ機能」が新しく定義された定義になります。「まったく有用ではない」という部分についてはどうでしょうか。 "
"それはそれが何であるかによって異なります。"

#: ../../chapter6.rst:44
msgid "Factoring Out Data"
msgstr "データの括り出し"

#: ../../chapter6.rst:46
msgid ""
"The simplest thing to factor out is data, thanks to Forth’s data stack. "
"For instance, to compute two-thirds of 1,000, we write"
msgstr "Forthのデータスタックのおかげで、最も簡単に括り出せるのはデータです。 たとえば、1,000の3分の2を計算するには、次のように記述します。"

#: ../../chapter6.rst:54
msgid ""
"To define a word that computes two-thirds of *any* number, we factor out "
"the argument from the definition:"
msgstr "任意の数の3分の2を計算するワードを定義するには、定義から引数を取り除きます。"

#: ../../chapter6.rst:61
msgid ""
"When the datum comes in the *middle* of the useful phrase, we have to use"
" stack manipulation. For instance, to center a piece of text ten "
"characters long on an 80-column screen, we would write:"
msgstr ""
"データが有用な句の中央にくると、スタック操作を使用する必要があります。 "
"たとえば、80桁の画面で長さ10文字のテキストを中央揃えにするには、次のように記述します。"

#: ../../chapter6.rst:69
msgid ""
"But text isn’t always 10 characters long. To make the phrase useful for "
"any string, you’d factor out the length by writing:"
msgstr "しかし、テキストは必ずしも10文字の長さではありません。 フレーズをあらゆる文字列に役立つようにするには、次のように記述して長さを計算します。"

#: ../../chapter6.rst:76
msgid ""
"The data stack can also be used to pass addresses. Therefore what’s "
"factored out may be a *pointer* to data rather than the data themselves. "
"The data can be numbers or even strings, and still be factored out "
"through use of the stack."
msgstr ""
"データスタックはアドレスを渡すためにも使用できます。 そのため、データ自体ではなく、データへのポインタが除外される可能性があります。 "
"データは数値でも文字列でもかまいませんが、それでもスタックを使用して除外することができます。"

#: ../../chapter6.rst:81
msgid ""
"Sometimes the difference appears to be a function, but you can factor it "
"out simply as a number on the stack. For instance:"
msgstr "「差」は機能が違うように見える事もありますが、単純にスタック上の数値として括り出す事ができます。"

#: ../../chapter6.rst:87 ../../chapter6.rst:106 ../../chapter6.rst:133
#: ../../chapter6.rst:150 ../../chapter6.rst:164
msgid "Segment 1:"
msgstr "Segment 1:"

#: ../../chapter6.rst:88 ../../chapter6.rst:89 ../../chapter6.rst:93
msgid "WILLY"
msgstr "WILLY"

#: ../../chapter6.rst:91 ../../chapter6.rst:96
msgid "PUDDIN’ PIE AND"
msgstr "PUDDIN’ PIE AND"

#: ../../chapter6.rst:92 ../../chapter6.rst:109 ../../chapter6.rst:139
#: ../../chapter6.rst:153 ../../chapter6.rst:167
msgid "Segment 2:"
msgstr "Segment 2:"

#: ../../chapter6.rst:94
msgid "NILLY"
msgstr "NILLY"

#: ../../chapter6.rst:95
msgid "8 \\*"
msgstr "8 \\*"

#: ../../chapter6.rst:98
msgid ""
"How can you factor out the “8 \\*” operation? By including “\\*” in the "
"factoring and passing it a one or eight:"
msgstr "どうやって ``8 *`` という操作を括り出せますか？ 以下のように、要素化に ``*`` を含め、それに1つまたは8つを渡すことによって可能です。"

#: ../../chapter6.rst:106
msgid "1 NEW"
msgstr "1 NEW"

#: ../../chapter6.rst:109
msgid "8 NEW"
msgstr "8 NEW"

#: ../../chapter6.rst:111
msgid ""
"(Of course if WILLY NILLY changes the stack, you’ll need to add "
"appropriate stack-manipulation operators.)"
msgstr "（もちろん、 ``WILLY NILLY`` がスタックを変更する場合は、適切なスタック操作演算子を追加する必要があります。）"

#: ../../chapter6.rst:114
msgid "If the operation involves addition, you can nullify it by passing a zero."
msgstr "操作に加算が含まれる場合は、ゼロを渡して無効にすることができます。"

#: ../../chapter6.rst:119
msgid ""
"For simplicity, try to express the difference between similar fragments "
"as a numeric difference (values or addresses), rather than as a "
"procedural difference."
msgstr "簡単にするために、類似の断片の差異を、手続き上の違いとしてではなく、数値の違い（値またはアドレス）として表すよう試みて下さい。"

#: ../../chapter6.rst:124
msgid "Factoring Out Functions"
msgstr "機能の括り出し"

#: ../../chapter6.rst:126
msgid "On the other hand, the difference sometimes *is* a function. Witness:"
msgstr "一方、機能はしばしば差異があります。こんなのを目撃しました。"

#: ../../chapter6.rst:141
msgid "Wrong approach:"
msgstr "悪いアプローチ"

#: ../../chapter6.rst:150
msgid "TRUE BLETCHES"
msgstr "TRUE BLETCHES"

#: ../../chapter6.rst:153
msgid "FALSE BLETCHES"
msgstr "FALSE BLETCHES"

#: ../../chapter6.rst:155
msgid "A better approach:"
msgstr "より良いアプローチ"

#: ../../chapter6.rst:164
msgid "BLETCH-AB BLETCH-C BLETCH-DEF"
msgstr "BLETCH-AB BLETCH-C BLETCH-DEF"

#: ../../chapter6.rst:167
msgid "BLETCH-AB PERVERSITY BLETCH-DEF"
msgstr "BLETCH-AB PERVERSITY BLETCH-DEF"

#: ../../chapter6.rst:171
msgid "Don't pass control flags downward."
msgstr "制御フラグを下流へ渡さないで下さい。"

#: ../../chapter6.rst:173
msgid ""
"Why not? First, you are asking your running application to make a "
"pointless decision—one you knew the answer to while programming—thereby "
"reducing efficiency. Second, the terminology doesn’t match the conceptual"
" model. What are ``TRUE BLETCHES`` as opposed to ``FALSE BLETCHES``?"
msgstr ""
"何故でしょうか？ まず、実行中のアプリケーションに、プログラム作成時に答えが判っている無意味な判定を下すように求めているため効率が低下します。 "
"次に、用語は概念モデルと一致しません。``FALSE BLETCHES`` とは対照的に、 ``TRUE BLETCHES`` とは何ですか？"

#: ../../chapter6.rst:179
msgid "Factoring Out Code from Within Control Structures"
msgstr "制御構造内からコードを括り出す"

#: ../../chapter6.rst:181
msgid ""
"Be alert to repetitions on either side of an ``IF``  ``ELSE``  ``THEN`` "
"statement. For instance:"
msgstr "``IF`` ``ELSE`` ``THEN`` ステートメントの両側の繰り返しに注意してください。 たとえば以下のようなのです。"

#: ../../chapter6.rst:190
msgid ""
"This fragment normally emits an ASCII character, but if the character is "
"a control code, it emits a dot. Either way, an ``EMIT`` is performed. "
"Factor ``EMIT`` out of the conditional structure, like this:"
msgstr ""
"この断片は通常ASCII文字を生成しますが、その文字が制御コードの場合はドットを生成します。 いずれにせよ、 ``EMIT`` が実行されます。 "
"次のようにして条件付き構造から ``EMIT`` を取り除きます。"

#: ../../chapter6.rst:199
msgid ""
"The messiest situation occurs when the difference between two definitions"
" is a function within a structure that makes it impossible to factor out "
"the half-fragments. In this case, use stack arguments, variables, or even"
" vectoring. We’ll see how vectoring can be used in a section of "
":doc:`Chapter Seven<chapter7>` called “Using DOER/MAKE.”"
msgstr "最も厄介な状況は、2つの定義の違いが構造内の機能である場合、断片の片割れを括り出すことは不可能です。この場合は、スタック引数、変数、更にはベクトル化を使って下さい。 :doc:`第7章<chapter7>` の「DOER/MAKEの使用」の章で、ベクトル化がどのように使われるのかを見ていきましょう。"

#: ../../chapter6.rst:205
msgid "Here’s a reminder about factoring code from out of a ``DO``  ``LOOP``:"
msgstr "以下は ``DO LOOP`` からコードを括り出すことについての注意です。"

#: ../../chapter6.rst:209
msgid ""
"In factoring out the contents of a ``DO``   ``LOOP`` into a new "
"definition, rework the code so that ``I`` (the index) is not referenced "
"within the new definition, but rather passed as a stack argument to it."
msgstr ""
"``DO LOOP`` の内容を新しい定義に分解する際には、 ``I`` "
"(インデックス)が新しい定義内で参照されず、スタック引数として渡されるようにコードを作り直してください。"

#: ../../chapter6.rst:215
msgid "Factoring Out Control Structures Themselves"
msgstr "制御構造自体の括り出し"

#: ../../chapter6.rst:217
msgid ""
"Here are two definitions whose differences lies within a ``IF``  ``THEN``"
" construct:"
msgstr "ここに ``IF THEN`` 構造の中が異なる２つの定義があります。"

#: ../../chapter6.rst:225
msgid ""
"The condition and control structure remain the same; only the event "
"changes. Since you can’t factor the ``IF`` into one word and the ``THEN``"
" into another, the simplest thing is to factor the condition:"
msgstr ""
"条件と制御構造は変わりません。イベントだけが違います。 ``IF`` や ``THEN`` "
"を、それ以上分解することはできないので、最も簡単なのは条件を考慮することです。"

#: ../../chapter6.rst:236
msgid ""
"Depending on the number of repetitions of the same condition and control "
"structure, you may even want to factor out both. Watch this:"
msgstr "同じ条件と制御構造の繰り返し数に応じて、その両方を括り出すこともできます。 以下を見てください。"

#: ../../chapter6.rst:246
msgid ""
"The word ``CONDITIONALLY`` may—depending on the condition—alter the "
"control flow so that the remaining words in each definition will be "
"skipped. This approach has certain disadvantages as well. We’ll discuss "
"this technique—pros and cons—in :doc:`Chapter Eight<chapter8>`."
msgstr ""
"条件に応じて、ワード ``CONDITIONALLY`` "
"は、各定義の残りのワードをスキップする制御フローを変更することがあります。この方法にもいくつかの欠点があります。 この技法の賛否両論については "
":doc:`第８章<chapter8>` で議論します。"

#: ../../chapter6.rst:251
msgid ""
"More benign examples of factoring-out control structures include case "
"statements, which eliminate nested ``IF``  ``ELSE``  ``THEN`` s, and "
"multiple exit loops  (the ``BEGIN``  ``WHILE``  ``WHILE``  ``WHILE`` "
"``...``  ``REPEAT`` construct). We\\’ll also discuss these topics in "
":doc:`Chapter Eight<chapter8>`."
msgstr "括り出す制御構造のより良性の例にはcaseステートメントがあります。それはネストされた ``IF…ELSE…THEN`` や、複数の出口を持つループ(``BEGIN…WHILE…WHILE…WHILE…REPEAT`` 構造)を取り除きます。これらのトピックについては :doc:`第８章<chapter8>` でも議論します。"

#: ../../chapter6.rst:258
msgid "Factoring Out Names"
msgstr "名前の括り出し"

#: ../../chapter6.rst:260
msgid ""
"It’s even good to factor out names, when the names seem almost, but not "
"quite, the same. Examine the following terrible example of code, which is"
" meant to initialize three variables associated with each of eight "
"channels:"
msgstr "名前がほとんど同じだが、まったく同じではないと思われる場合は、名前を括り出すこともできます。 以下のひどいコード例を見てください。これは、8つのチャネルそれぞれに関連付けられた3つの変数を初期化することを意味しています。"

#: ../../chapter6.rst:292
msgid ""
"First there’s a similarity among the names of the variables; then there’s"
" a similarity in the code used in all the ``INIT-CH`` words."
msgstr "まず、変数の名前には類似点があります。 それから、``INIT-CH`` 系ワードで使われているコードには類似性があります。"

#: ../../chapter6.rst:295
msgid ""
"Here’s an improved rendition. The similar variable names have been "
"factored into three data structures, and the lengthy recital of ``INIT-"
"CH`` words has been factored into a ``DO``  ``LOOP``:"
msgstr ""
"これが改良された表現です。 同様の変数名は3つのデータ構造にまとめられ、長い ``INIT-CH`` 系ワードの演奏会は ``DO…LOOP`` "
"にまとめられました。"

#: ../../chapter6.rst:309
msgid "That’s all the code we need."
msgstr "私たちに必要なコードはこれっきりです。"

#: ../../chapter6.rst:311
msgid ""
"Even in the most innocent cases, a little data structure can eliminate "
"extra names. By convention Forth handles text in “counted strings” (i.e.,"
" with the count in the first byte). Any word that returns the “address of"
" a string” actually returns this beginning address, where the count is. "
"Not only does use of this two-element data structure eliminate the need "
"for separate names for string and count, it also makes it easier to move "
"a string in memory, because you can copy the string *and* the count with "
"a single ``CMOVE``."
msgstr ""
"最も他愛のない場合でさえ、小さなデータ構造は余分な名前を排除することができます。 "
"慣例により、Forthはテキストを「文字数付き文字列」（すなわち、最初のバイトに文字数）で扱います。 "
"「文字列のアドレス」を返す単語は、実際にはこの文字数格納先頭アドレスを返します。 "
"この2要素のデータ構造を使用すると、「文字列」と「カウント」に別々の名前を使用する必要がなくなるだけでなく、文字列*とカウントを1つの "
"``CMOVE`` でコピーできるため、文字列をメモリ内で移動しやすくなります。 "

#: ../../chapter6.rst:321
msgid ""
"When you start finding the same awkwardness here and there, you can "
"combine things and make the awkwardness go away."
msgstr "あちこちで同じぎこちなさを見つけ始めたら、物事を組み合わせてぎこちなさを解消することができます。"

#: ../../chapter6.rst:325
msgid "Factoring Out Functions into Defining Words"
msgstr "定義ワード内の機能の括り出し"

#: ../../chapter6.rst:329
msgid ""
"If a series of definitions contains identical functions, with variation "
"only in data, use a defining word."
msgstr "定義のシリーズに同一の機能が含まれていて、データに違いがある場合は、定義ワードを使用してください。"

#: ../../chapter6.rst:332
msgid ""
"Examine the structure of this code (without worrying about its "
"purpose—you’ll see the same example later on):"
msgstr "このコードの構造を調べてください(ここでは、その目的は気にしないでください。後でもう一度同じ例を出します)。"

#: ../../chapter6.rst:349
msgid ""
"The above approach is technically correct, but less memory-efficient than"
" the following approach using defining words:"
msgstr "上記の方法は技法的には正しいですが、定義ワードを使用する次の方法よりもメモリ効率が低くなります。"

#: ../../chapter6.rst:360
msgid "(Defining words are explained in *Starting Forth*, Chapter Eleven)."
msgstr "(定義ワードは *Starting Forth*, Chapter Eleven;邦訳 FORTH入門 第11章 に説明があります。)"

#: ../../chapter6.rst:362
msgid ""
"By using a defining word, we save memory because each compiled colon "
"definition needs the address of ``EXIT`` to conclude the definition. (In "
"defining eight words, the use of a defining word saves 14 bytes on a "
"16-bit Forth.) Also, in a colon definition each reference to a numeric "
"literal requires the compilation of ``LIT`` (or ``literal``), another 2 "
"bytes per definition. (If 1 and 2 are predefined constants, this costs "
"another 10 bytes—24 total.)"
msgstr ""
"定義語を使用することによって、コンパイルされた各コロン定義は定義を終了するために ``EXIT`` "
"のアドレスを必要とするのでメモリを節約します(8ワードを定義する場合、定義ワードを使用すると16ビットのForthで14バイト節約できます)。また、コロン定義では、数値リテラルを参照するたびに"
" ``LIT`` (または ``literal`` "
")をコンパイルする必要があります）、定義ごとにさらに2バイト(1と2が事前定義された定数の場合、これにはさらに10バイト、合計24バイトのコストがかかります)。"

#: ../../chapter6.rst:370
msgid ""
"In terms of readability, the defining word makes it absolutely clear that"
" all the colors it defines belong to the same family of words."
msgstr "読みやすさの点では、定義するワードは、それが定義するすべての色が同じワードのグループに属することを絶対に明確にしています。"

#: ../../chapter6.rst:373
msgid ""
"The greatest strength of defining words, however, arises when a series of"
" definitions share the same *compile-time* behavior. This topic is the "
"subject of a later section, “Compile-Time Factoring.”"
msgstr ""
"しかし、定義ワードの最大の強みは、一連の定義が同じコンパイル時の動作を共有するときに生じます。 "
"このトピックは、後節の「コンパイル時の除外」の主題です。"

#: ../../chapter6.rst:378
msgid "Factoring Criteria"
msgstr "ファクタリング(要素分解)基準"

#: ../../chapter6.rst:380
msgid ""
"Armed with an understanding of factoring techniques, let’s now discuss "
"several of the criteria for factoring Forth definitions. They include:"
msgstr "ファクタリング(要素分解)手法について理論武装したので、今度はForth定義をファクタリング(要素分解)するためのいくつかの基準について説明しましょう。 以下の内容が含まれます。"

#: ../../chapter6.rst:384
msgid "Limiting the size of definitions"
msgstr "定義のサイズを制限する"

#: ../../chapter6.rst:386
msgid "Limiting repetition of code"
msgstr "コードの繰り返しを制限する"

# TODO:意味あってるか内容見て再検討する(2019/07/18)
#: ../../chapter6.rst:388
msgid "Nameability"
msgstr "命名可能性"

#: ../../chapter6.rst:390
msgid "Information hiding"
msgstr "情報隠蔽"

#: ../../chapter6.rst:392
msgid "Simplifying the command interface"
msgstr "コマンドインターフェイスの単純化"

#: ../../chapter6.rst:396
msgid "Keep definitions short."
msgstr "定義を短く保って下さい。"

#: ../../chapter6.rst:406
msgid "We asked **Moore**, \"How long should a Forth definition be?\""
msgstr "私たちは **ムーア** に、「Forthの定義はどれくらいの長さであるべきですか？」と尋ねました。"

# ここは「言葉」か？
#: ../../chapter6.rst:399
msgid "A word should be a line long. That's the target."
msgstr "ワードは1行の長さであるべきです。それが目標です。"

#: ../../chapter6.rst:401
msgid ""
"When you have a whole lot of words that are all useful in their own right"
"---perhaps in debugging or exploring, but inevitably there's a reason for"
" their existence---you feel you've extracted the essence of the problem "
"and that those words have expressed it."
msgstr "あなたが、自身で有用とする正しい(おそらくデバッグや探索で必然的にそれらが存在する理由がある)ワードをたくさん持っているなら、あなたは問題の本質を抽出し、それらのワードで表現していると言えます。"

#: ../../chapter6.rst:406
msgid "Short words give you a good feeling."
msgstr "短い言葉はあなたに良い感じを与えます。"

#: ../../chapter6.rst:408
msgid ""
"An informal examination of one of Moore’s applications shows that he "
"averages seven references, including both words and numbers, per "
"definition. These are remarkably short definitions. (Actually, his code "
"was divided about 50–50 between one-line and two-line definitions.)"
msgstr "ムーアのアプリケーションの1つを非公式に調べたところ、彼の定義は、ワードと数字が平均7つ含まれていました。これらは非常に短い定義です(実際、彼のコードは1行定義と2行定義の割合が半々でした)。"

#: ../../chapter6.rst:413
msgid ""
"Psychological tests have shown that the human mind can only focus its "
"conscious attention on seven things, plus or minus two, at a time "
"[miller56]_. Yet all the while, day and night, the vast resources of the "
"mind are subconsciously storing immense amounts of data, making "
"connections and associations and solving problems."
msgstr ""
"心理テストでは、人間の心は意識的注意を一度に7つのこと、それか7±2つだけに集中させることができることが示されています。 [miller56]_ "
"それでも、昼夜を問わず、心の膨大なリソースは潜在的に膨大な量のデータを保存し、つながりや関連付けをし、問題を解決しています。"

#: ../../chapter6.rst:419
msgid ""
"Even if out subconscious mind knows each part of an application inside "
"out, our narrow-viewed conscious mind can only correlate seven elements "
"of it at once. Beyond that, our grasp wavers. Short definitions match our"
" mental capabilities."
msgstr ""
"潜在意識がアプリケーションの各部分を内側から知っていても、私たちの狭視野意識は一度にその7つの要素しか関連付けることができません。 "
"それ以上だと、私たちの把握はゆらぎます。短い定義は私たちの精神的な能力と一致します。"

#: ../../chapter6.rst:424
msgid ""
"Something that tempts many Forth programmers to write overly long "
"definitions is the knowledge that headers take space in the dictionary. "
"The coarser the factoring, the fewer the names, and the less memory that "
"will be wasted."
msgstr "多くのForthプログラマーが過度に長い定義を書きたくなるのは、ヘッダが辞書内のスペースを取るという知識です。 ファクタリング(要素分解)が粗いほど、名前が少なくなり、無駄になるメモリが少なくなります。"

#: ../../chapter6.rst:429
msgid ""
"It’s true that more memory will be used, but it’s hard to say that "
"anything that helps you test, debug and interact with your code is a "
"“waste.” If your application is large, try using a default width of "
"three, with the ability to switch to a full-length name to avoid a "
"specific collision. (“Width” refers to a limit on the number of "
"characters stored in the name field of each dictionary header.)"
msgstr ""
"より多くのメモリが使用されるのは事実ですが、テスト、デバッグ、コードとの対話など全てにに役立つものが「無駄」になるとは言い難い。アプリケーションが大きい場合は、各辞書ヘッダーの名前フィールドに格納される文字数のデフォルトを3文字で使用してみてください。"
" 衝突を避けるために、特定の名前について長さ制限無しに切り替えます。"

#: ../../chapter6.rst:436
msgid ""
"If the application is still too big, switch to a Forth with multiple "
"dictionaries on a machine with extended memory, or better yet, a 32-bit "
"Forth on a machine with 32-bit addressing."
msgstr "それでもアプリケーションが大きすぎる場合は、拡張メモリを搭載したマシンで複数の辞書を含むForthに切り替えるか、32ビットアドレッシングを搭載したマシンで32ビットForthに切り替えます。"

#: ../../chapter6.rst:440
msgid ""
"A related fear is that over-factoring will decrease performance due to "
"the overhead of Forth’s inner interpreter. Again, it’s true that there is"
" some penalty for each level of nesting. But ordinarily the penalty for "
"extra nesting due to proper factoring will not be noticeable. If you "
"timings are that tight, the real solution is to translate something into "
"assembler."
msgstr ""
"関連する恐怖は、Forthの内部インタプリタのオーバーヘッドのために過剰分解がパフォーマンスを低下させることです。 "
"繰り返しますが、ネスティングの各レベルにはいくらかのペナルティがあります。 "
"しかし、通常は、適切な分解による追加のネスティングに対するペナルティは目立ちません。 "
"あなたの納期がそれほど厳しくないなら、本当の解決策はアセンブラに翻訳することです。"

#: ../../chapter6.rst:449
msgid ""
"Factor at the point where you feel unsure about your code (where "
"complexity approaches the conscious limit)."
msgstr "分解するポイントは、あなたがあなたのコードがわけわかめと感じるポイントです（複雑さが意識的な限界に近づいていると感じるポイントです）。"

#: ../../chapter6.rst:452
msgid ""
"Don’t let your ego take over with an “I can lick this!” attitude. Forth "
"code should never feel uncomfortably complex. Factor!"
msgstr "「オレはこれを征服してやる！」なんて態度で挑む必要はありません。Forthコードは不快で複雑に感じることはありません。分解せよ！"

#: ../../chapter6.rst:463 ../../chapter6.rst:513 ../../chapter6.rst:593
#: ../../chapter6.rst:1008 ../../chapter6.rst:1375
msgid "**Moore**:"
msgstr "**ムーア** は言います。"

#: ../../chapter6.rst:456
msgid ""
"Feeling like you might have introduced a bug is one reason for factoring."
" Any time you see a doubly-nested ``DO``  ``LOOP``, that's a sign that "
"something's wrong because it will be hard to debug. Almost always take "
"the inner ``DO``  ``LOOP`` and make a word."
msgstr ""
"あなたがバグを導入したかもしれないと感じることは除外化する理由の一つです。 二重にネストされた ``DO…LOOP`` "
"を見たときはいつでも、それはデバッグが難しいので何かが間違っているというサインです。 ほとんどの場合、内側の ``DO…LOOP`` "
"を取り出しワードを作ります。"

#: ../../chapter6.rst:461
msgid ""
"And having factored out a word for testing, there's no reason for putting"
" it back. You found it useful in the first place. There's no guarantee "
"you won't need it again."
msgstr ""
"テスト用のワードをまとめたら、元に戻す理由はありません。 あなたはそれがそもそも役に立つと思ったのです。 "
"あなたが再びそれを必要としないという保証はありません。"

#: ../../chapter6.rst:465
msgid "Here’s another facet of the same principle:"
msgstr "これは同じ原則の別の側面です。"

#: ../../chapter6.rst:469
msgid "Factor at the point where a comment seems necessary"
msgstr "コメントが必要と思われる時点でのファクタリング(要素分解)"

#: ../../chapter6.rst:471
msgid ""
"Particularly if you feel a need to remind yourself what’s on the stack, "
"this may be a good time to “make a break.”"
msgstr "特に、スタックの内容を思い出す必要があると感じた場合は、「休憩をとる」のがよいでしょう。"

#: ../../chapter6.rst:474
msgid "Suppose you have"
msgstr "以下のようなのがあるとします。"

#: ../../chapter6.rst:481
msgid ""
"which begins by computing the balance and ends by displaying it. In the "
"meantime, several lines of code use the balance for purposes of their "
"own. Since it’s difficult to see that the balance is still on the stack "
"when ``SHOW`` executes, the programmer has interjected a stack picture."
msgstr "残高を計算することで始まり、それを表示することで終わります。 それまでの間、数行のコードでは、独自の目的で残高を使用しています。 ``SHOW`` を実行するときに残高がまだスタック上にあることを確認するのは困難なので、プログラマはスタック状況を差し挟みました。"

#: ../../chapter6.rst:486
msgid "This solution is generally a sign of bad factoring. Better to write:"
msgstr "この解決策は一般的に悪いファクタリング(要素分解)の兆候です。 以下のように書くほうがよいです。"

#: ../../chapter6.rst:494
msgid ""
"No narrative stack pictures are needed. Furthermore, the programmer now "
"has a reusable, testable subset of the definition."
msgstr "物語スタック状況は必要ありません。更に、 さらに、プログラマは現在、再利用可能でテスト可能な定義のサブセットを持っています。"

#: ../../chapter6.rst:499
msgid "Limit repetition of code."
msgstr "コードの繰り返しを制限してください。"

#: ../../chapter6.rst:501
msgid ""
"The second reason for factoring, to eliminate repeated fragments of code,"
" is even more important than reducing the size of definitions."
msgstr "ファクタリング(要素分解)の2番目の理由は、コードの繰り返しの断片を排除することです。それは定義のサイズを小さくすることよりもさらに重要です。"

#: ../../chapter6.rst:506
msgid ""
"When a word is just a piece of something, it's useful for clarity or "
"debugging, but not nearly as good as a word that is used multiple times. "
"Any time a word is used only once you want to question its value."
msgstr "ワードが単に何かの一部である場合、明瞭さやデバッグには役立ちますが、何度も使用されるワードほどではありません。いつでも、一度だけしか使われないワードはその価値を疑問視したくなります。"

#: ../../chapter6.rst:511
msgid ""
"Many times when a program has gotten too big I will go back through it "
"looking for phrases that strike my eye as candidates for factoring. The "
"computer can't do this; there are too many variables."
msgstr "プログラムが大きくなりすぎると、私はファクタリング(要素分解)のための候補として、目に止まるフレーズを探して何度も右往左往します。コンピュータはこれを行うことができません。 変数が多すぎます。"

#: ../../chapter6.rst:515
msgid ""
"In looking over your work, you often find identical phrases or short "
"passages duplicated several times. In writing an editor I found this "
"phrase repeated several times:"
msgstr "自分の作品を見てみると、同じフレーズや短い文章が何度か重複しているのがよくわかります。 エディタを書く際に、以下のフレーズが数回繰り返されているのがわかりました。"

#: ../../chapter6.rst:523
msgid ""
"Because it appeared several times I factored it into a new word called "
"``AT``."
msgstr "それが何度か現れたので、私はそれを ``AT`` と呼ばれる新しいワードにまとめました。"

#: ../../chapter6.rst:526
msgid ""
"It’s up to you to recognize fragments that are coded differently but "
"functionally equivalent, such as:"
msgstr "次のように、コーディング方法が異なるが機能的に同等の断片を認識するのは、あなた次第です。"

#: ../../chapter6.rst:533
msgid ""
"The ``1-`` appears to make this phrase different from the one defined as "
"``AT.`` But in fact, it can be written"
msgstr "``1-`` は、このフレーズを ``AT`` の定義とは異なるもののように見せていますが、実際には以下のように ``AT`` を使って書くことができます。"

#: ../../chapter6.rst:540
msgid "On the other hand:"
msgstr "その反面、"

#: ../../chapter6.rst:544
msgid ""
"When factoring out duplicate code, make sure the factored code serves a "
"single purpose."
msgstr "重複するコードを括り出すときは、括り出されたコードが単一の目的を果たすことを確認してください。"

#: ../../chapter6.rst:547
msgid ""
"Don’t blindly seize upon duplications that may not be useful. For "
"instance, in several places in one application I used this phrase:"
msgstr "役に立たないかもしれない重複を盲目的に掴まえないでください。 たとえば、1つのアプリケーションのいくつかの場所で以下のフレーズを使用しました。"

#: ../../chapter6.rst:554
msgid ""
"I turned it into a new word and called it ``LETTER``, since it returned "
"the letter being pointed to by the interpreter."
msgstr "私はそれを新しいワードに変えて、それを ``LETTER`` と呼びました。なぜならそれはインタプリタが指し示す文字を返すからです。"

#: ../../chapter6.rst:557
msgid "In a later revision, I unexpectedly had to write:"
msgstr "後の改訂では、予想外に、以下のように書かなければなりませんでした。"

#: ../../chapter6.rst:563
msgid ""
"I could have used the existing ``LETTER`` were it not for its ``C@`` at "
"the end. Rather than duplicate the bulk of the phrase in the new section,"
" I chose to refactor ``LETTER`` to a finer resolution, taking out the "
"``C@``. The usage was then either ``LETTER C@`` or ``LETTER C!``. This "
"change required me to search through the listing changing all instances "
"of ``LETTER`` to ``LETTER C@``. But I should have done that in the first "
"place, separating the computation of the letter’s address from the "
"operation to be performed on the address."
msgstr "最後の ``C@`` のためではないのであれば、既存の ``LETTER`` を使用することができました。 新しいセクションでフレーズの大部分を複製するのではなく、私は ``LETTER`` をより細かい粒度にリファクタリングして ``C@`` を取り出すことを選びました。 そのときの用法は ``LETTER C@`` か ``LETTER C!`` のどちらかでした。 この変更により、リスト全体を検索して、 ``LETTER`` のすべてのインスタンスを ``LETTER C@`` に変更する必要がありました。 しかし、私は最初に文字の住所の計算と住所で実行される操作とを区別して、それを行うべきでした。"

#: ../../chapter6.rst:573
msgid "Similar to our injunction against repetition of code:"
msgstr "以下のヒントは、私たちのコード繰り返し禁止令と同じ意味です。"

#: ../../chapter6.rst:577
msgid "Look for repetition of patterns."
msgstr "パターンの繰り返しを探して下さい。"

#: ../../chapter6.rst:579
msgid ""
"If you find yourself referring back in the program to copy the pattern of"
" previously-used words, then you may have mixed in a general idea with a "
"specific application. The part of the pattern you are copying perhaps can"
" be factored out as an independent definition that can be used in all the"
" similar cases."
msgstr "プログラム内の既存のコードでワードのパターンをコピーするように参照している場合は、一般的なアイデアと特定のアプリケーションが混在している可能性があります(訳注:それは、詳細に分析しない限り、書いた人にしか分からない)。 あなたが自身がコピーしているパターンは、おそらくすべての同様の場合に使用できる独立した定義として括り出すことができます。"

#: ../../chapter6.rst:587
msgid "Be sure you can name what you factor."
msgstr "自分が分解したものに名前を付けることができることを確認してください。"

#: ../../chapter6.rst:590
msgid ""
"If you have a concept that you can't assign a single name to, not a "
"hyphenated name, but a name, it's not a well-formed concept. The ability "
"to assign a name is a necessary part of decomposition. Certainly you get "
"more confidence in the idea."
msgstr "ハイフンで繋がれた名前でなく単一の名前を割り当てる事ができない概念がある場合は、それは名前ではなく、整形式の概念ではありません。名前を割り当てる能力は分解の主要な部分です。あなたはその考えに必ずや自信を持つようになります。"

#: ../../chapter6.rst:595
msgid ""
"Compare this view with the criteria for decomposing a module espoused by "
"structured design in :doc:`Chapter One<chapter1>`. According to that "
"method, a module should exhibit “functional binding,” which can be "
"verified by describing its function in a single, non-compound, "
"*sentence*. Forth’s “atom,” a *name*, is an order of magnitude more "
"refined."
msgstr "この見方と、:doc:`第１章<chapter1>` の中の構造化設計に基づくモジュールを分解する基準とを比較してください。 その方法によれば、モジュールは「機能的結合」を示すべきであり、それはその機能を単一の非複合的な「文」で記述することによって検証することができます。 Forthの「アトム」である「名前」は、さらに洗練された命令です。"

#: ../../chapter6.rst:604
msgid "Factor definitions to hide details that may change."
msgstr "変化する可能性のある詳細を隠すために定義を分解して下さい。"

#: ../../chapter6.rst:606
msgid ""
"We’ve seen the value of information hiding in earlier chapters, "
"especially with regard to preliminary design. It’s useful to remember "
"this criterion during the implementation stage as well."
msgstr "特に予備設計に関しては、情報隠蔽の価値を前述しました。実装段階でもこの基準を覚えておくと便利です。"

#: ../../chapter6.rst:610
msgid "Here’s a very short definition that does little except hide information:"
msgstr "以下は、非常に短い定義で、情報を隠すこと以外はほとんど何もしていません。"

#: ../../chapter6.rst:616
msgid ""
"This definition allows you to convert an acf (address of code field) to "
"an apf (address of parameter field) without depending on the actual "
"structure of a dictionary definition. If you were to use ``2+`` instead "
"of the word ``>BODY``, you would lose transportability if you ever "
"converted to a Forth system in which the heads were separated from the "
"bodies. (This is one of a set of words suggested by Kim Harris, and "
"included as an Experimental Proposal in the Forth-83 Standard "
"[harris83]_.)"
msgstr "この定義により、辞書定義の実際の構造に依存せずに、acf(コードフィールドのアドレス)をapf(パラメータフィールドのアドレス)に変換できます。 もし ``>BODY`` の代わりに ``2+`` を使ったら、ヘッダがボディから分離されているForthシステムに変換した時にポータビリティを失うでしょう(これは、キム・ハリスによって提案されたワード・セット1つであり、Forth-83標準の[実験的提案] [harris83]_ に含まれています)。"

#: ../../chapter6.rst:626
msgid "Here’s a group of definitions that might be used in writing an editor:"
msgstr "以下は、エディタを書くのに使われるかもしれない定義のグループです。"

#: ../../chapter6.rst:634
msgid ""
"These three definitions can form the basis for all calculations of "
"addresses necessary for moving text around. Use of these three "
"definitions completely separates your editing algorithms from a reliance "
"on Forth blocks."
msgstr "これら3つの定義は、テキストを動かすために必要なすべてのアドレス計算の基礎を形成することができます。 これら3つの定義を使用すると、編集アルゴリズムとForthブロックへの依存が完全に分離されます。"

#: ../../chapter6.rst:639
msgid ""
"What good is that? If you should decide, during development, to create an"
" editing buffer to protect the user from making errors that destroy a "
"block, you merely have to redefine two of these words, perhaps like this:"
msgstr "それの何がいいのでしょうか？ 開発中に、ユーザがブロックを破壊するようなエラーを起こさないようにするための編集バッファを作成することにした場合は、単に次の2つのワードを再定義するだけで済みます。"

#: ../../chapter6.rst:649
msgid "The rest of your code can remain intact."
msgstr "あなたのコードの残りはそのままです。"

#: ../../chapter6.rst:653
msgid "Factor functions out of definitions that display results."
msgstr "結果を表示する定義の機能を括り出して下さい。"

#: ../../chapter6.rst:655
msgid "This is really a question of decomposition."
msgstr "これは本当に分解の問題です。"

#: ../../chapter6.rst:657
msgid ""
"Here’s an example. The word defined below, pronounced “people-to-paths,” "
"computes how many paths of communication there are between a given number"
" of people in a group. (This is a good thing for managers of programmer "
"teams to know—the number of communication paths increases drastically "
"with each new addition to the team.)"
msgstr "ここに一例があります。以下で定義される「人々から経路へ(people-to-paths)」と発音されるワードは、グループ内の所与の数の人の間にいくつのコミュニケーション経路があるかを計算します(これは、プログラマチームの管理者にとって知っておくとよいことです。チームが新しく追加されるたびにコミュニケーション経路の数が劇的に増加します)。"

#: ../../chapter6.rst:667
msgid ""
"This definition does the calculation only. Here’s the “user definition” "
"that invokes ``PEOPLE>PATHS`` to perform the calculation, and then "
"displays the result:"
msgstr "この定義は計算のみを行います。 以下は、``PEOPLE>PATHS`` を呼び出して計算を実行し、その結果を表示する「ユーザ定義」です。"

#: ../../chapter6.rst:676
msgid "This produces:"
msgstr "以下のようになります。"

#: ../../chapter6.rst:685
msgid ""
"Even if you think you’re going to perform a particular calculation only "
"once, to display it in a certain way, believe me, you’re wrong. You will "
"have to come back later and factor out the calculation part. Perhaps "
"you’ll need to display the information in a right-justified column, or "
"perhaps you’ll want to record the results in a data base—you never know. "
"But you’ll always have to factor it, so you might as well do it right the"
" first time. (The few times you might get away with it aren’t worth the "
"trouble.)"
msgstr "特定の計算を1回しか実行しないと思う場合でも、それを特定の方法で表示しようと思う場合でも、私を信じて下さい。あなたは間違っています。あなたは後で戻ってきて、計算部分を括り出す必要があります。 おそらく、情報を右寄せの列に表示する必要があるか、結果をデータベースに記録する必要があるでしょう。 しかし、あなたは常にそれを考慮に入れなければならないので、あなたはそれを最初から正しくやるかもしれません(あなたがそれを回避するかもしれない数回はトラブルに値しません)。"

#: ../../chapter6.rst:694
#, python-format
msgid ""
"The word ``.`` (dot) is a prime example. Dot is great 99% of the time, "
"but occasionally it does too much. Here’s what it does, in fact (in "
"Forth–83):"
msgstr ""

#: ../../chapter6.rst:702
msgid ""
"But suppose you want to convert a number on the stack into an ASCII "
"string and store it in a buffer for typing later. Dot converts it, but "
"also types it. Or suppose you want to format playing cards in the form "
"``10C`` (for “ten of clubs”). You can’t use dot to display the 10 because"
" it prints a final space."
msgstr ""

#: ../../chapter6.rst:708
msgid "Here’s a better factoring found in some Forth systems:"
msgstr ""

#: ../../chapter6.rst:715
msgid ""
"We find another example of failing to factor the output function from the"
" calculation function in our own Roman numeral example in :doc:`Chapter "
"Four<chapter4>` Four. Given our solution, we can’t store a Roman numeral "
"in a buffer or even center it in a field. (A better approach would have "
"been to use ``HOLD`` instead of ``EMIT``.)"
msgstr ""

#: ../../chapter6.rst:721
msgid ""
"Information hiding can also be a reason *not* to factor. For instance, if"
" you factor the phrase"
msgstr ""

#: ../../chapter6.rst:728
msgid "into the definition"
msgstr ""

#: ../../chapter6.rst:734
msgid ""
"remember you are doing so only because you may want to change the "
"location of the editing frame. Don’t blindly replace all occurrences of "
"the phrase with the new word ``FRAME,`` because you may change the "
"definition of ``FRAME`` and there will certainly be times when you really"
" want ``SCR``  ``@``  ``BLOCK``."
msgstr ""

#: ../../chapter6.rst:742
msgid ""
"If a repeated code fragment is likely to change in some cases but not "
"others, factor out only those instances that might change. If the "
"fragment is likely to change in more than one way, factor it into more "
"than one definition."
msgstr ""

#: ../../chapter6.rst:747
msgid ""
"Knowing when to hide information requires intuition and experience. "
"Having made many design changes in your career, you’ll learn the hard way"
" which things will be most likely to change in the future."
msgstr ""

#: ../../chapter6.rst:751
msgid ""
"You can never predict everything, though. It would be useless to try, as "
"we’ll see in the upcoming section called “The Iterative Approach in "
"Implementation.”"
msgstr ""

#: ../../chapter6.rst:757
msgid "Simplify the command interface by reducing the number of commands."
msgstr ""

#: ../../chapter6.rst:759
msgid ""
"It may seem paradoxical, but good factoring can often yield *fewer* "
"names. In :doc:`Chapger Five<chapter5>` we saw how six simple names "
"(``LEFT``, ``RIGHT``, ``MOTOR``, ``SOLENOID``, ``ON``, and ``OFF``) could"
" do the work of eight badly-factored, hyphenated names."
msgstr ""

#: ../../chapter6.rst:765
msgid ""
"As another example, I found two definitions circulating in one department"
" in which Forth had recently introduced. Their purpose was purely "
"instructional, to remind the programmer which vocabulary was ``CURRENT``,"
" and which was ``CONTEXT``:"
msgstr ""

#: ../../chapter6.rst:775
msgid "If you typed"
msgstr ""

#: ../../chapter6.rst:781
msgid "the system would respond"
msgstr ""

#: ../../chapter6.rst:787
msgid ""
"(They worked—at least on the system used there—by backing up to the name "
"field of the vocabulary definition, and displaying it.)"
msgstr ""

#: ../../chapter6.rst:790
msgid ""
"The obvious repetition of code struck my eye as a sign of bad factoring. "
"It would have been possible to consolidate the repeated passage into a "
"third definition:"
msgstr ""

#: ../../chapter6.rst:798
msgid "shortening the original definitions to:"
msgstr ""

#: ../../chapter6.rst:805
msgid ""
"But in this approach, the only difference between the two definitions was"
" the pointer to be displayed. Since part of good factoring is to make "
"fewer, not more definitions, it seemed logical to have only one "
"definition, and let it take as an argument either the word ``CONTEXT`` or"
" the word ``CURRENT``."
msgstr ""

#: ../../chapter6.rst:811
msgid "Applying the principles of good naming, I suggested:"
msgstr ""

#: ../../chapter6.rst:817
msgid "allowing the syntax(``CONTEXT IS`` \\[:kbd:`Enter`\\])"
msgstr ""

#: ../../chapter6.rst:823
msgid "or(``CURRENT IS`` \\[:kbd:`Enter`\\])"
msgstr ""

#: ../../chapter6.rst:829
msgid ""
"The initial clue was repetition of code, but the final result came from "
"attempting to simplify the command interface."
msgstr ""

#: ../../chapter6.rst:832
msgid ""
"Here’s another example. The IBM PC has four modes four displaying text "
"only:"
msgstr ""

#: ../../chapter6.rst:835
msgid "40 column monochrome"
msgstr ""

#: ../../chapter6.rst:837
msgid "40 column color"
msgstr ""

#: ../../chapter6.rst:839
msgid "80 column monochrome"
msgstr ""

#: ../../chapter6.rst:841
msgid "80 column color"
msgstr ""

#: ../../chapter6.rst:843
msgid ""
"The word ``MODE`` is available in the Forth system I use. ``MODE`` takes "
"an argument between 0 and 3 and changes the mode accordingly. Of course, "
"the phrase 0 ``MODE`` or 1 ``MODE`` doesn’t help me remember which mode "
"is which."
msgstr ""

#: ../../chapter6.rst:848
msgid ""
"Since I need to switch between these modes in doing presentations, I need"
" to have a convenient set of words to effect the change. These words must"
" also set a variable that contains the current number of columns—40 or "
"80."
msgstr ""

#: ../../chapter6.rst:853
msgid "Here’s the most straightforward way to fulfill the requirements:"
msgstr ""

#: ../../chapter6.rst:862
msgid "By factoring to eliminate the repetition, we come up with this version:"
msgstr ""

#: ../../chapter6.rst:872
msgid ""
"But by attempting to reduce the number of commands, and also by following"
" the injunctions against numerically-prefixed and hyphenated names, we "
"realize that we can use the number of columns as a stack argument, and "
"*calculate* the mode:"
msgstr ""

#: ../../chapter6.rst:882
msgid "This gives us this syntax:"
msgstr ""

#: ../../chapter6.rst:891
msgid "We’ve reduced the number of commands from four to two."
msgstr ""

#: ../../chapter6.rst:893
msgid ""
"Once again, though, we have some duplicate code. If we factor out this "
"code we get:"
msgstr ""

#: ../../chapter6.rst:903
msgid ""
"Now we’ve achieved a nicer syntax, and at the same time greatly reduced "
"the size of the object code. With only two commands, as in this example, "
"the benefits may be marginal. But with larger sets of commands the "
"benefits increase geometrically."
msgstr ""

#: ../../chapter6.rst:908
msgid ""
"Our final example is a set of words to represent colors on a particular "
"system. Names like ``BLUE`` and ``RED`` are nicer than numbers. One "
"solution might be to define:"
msgstr ""

#: ../../chapter6.rst:923
msgid ""
"These colors can be used with words such as BACKGROUND, FOREGROUND, and "
"BORDER:"
msgstr ""

#: ../../chapter6.rst:930
msgid ""
"But this solution requires 16 names, and many of them are hyphenated. Is "
"there a way to simplify this?"
msgstr ""

#: ../../chapter6.rst:933
msgid ""
"We notice that the colors between 8 and 15 are all “lighter” versions of "
"the colors between 0 and 7. (In the hardware, the only difference between"
" these two sets is the setting of the “intensity bit.”) If we factor out "
"the “lightness,” we might come up with this solution:"
msgstr ""

#: ../../chapter6.rst:949
msgid "With this syntax, the word"
msgstr ""

#: ../../chapter6.rst:955
msgid "by itself will return a “1” on the stack, but the phrase"
msgstr ""

#: ../../chapter6.rst:961
msgid ""
"will return a “9.” (The adjective LIGHT sets flag which is used by the "
"hues, then cleared.)"
msgstr ""

#: ../../chapter6.rst:964
msgid "If necessary for readability, we still might want to define:"
msgstr ""

#: ../../chapter6.rst:971
msgid ""
"Again, through this approach we’ve achieved a more pleasant syntax and "
"shorter object code."
msgstr ""

#: ../../chapter6.rst:976
msgid "Don't factor for the sake of factoring. Use clich\\'es."
msgstr ""

#: ../../chapter6.rst:978
msgid "The phrase"
msgstr ""

#: ../../chapter6.rst:984
msgid ""
"may be seen commonly in certain applications. (It converts an address and"
" count into an ending address and starting address appropriate for a ``DO"
" LOOP``.)"
msgstr ""

#: ../../chapter6.rst:988
msgid "Another commonly seen phrase is"
msgstr ""

#: ../../chapter6.rst:994
msgid ""
"(It rearranges a first-number and last-number into the last-number-plus-"
"one and first-number order required by ``DO``.)"
msgstr ""

#: ../../chapter6.rst:998
msgid ""
"It’s a little tempting to seize upon these phrases and turn them into "
"words, such as (for the first phrase) ``RANGE``."
msgstr ""

#: ../../chapter6.rst:1002
msgid ""
"That particular phrase ``OVER``  ``+``   ``SWAP`` is one that's right on "
"the margin of being a useful word. Often, though, if you define something"
" as a word, it turns out you use it only once. If you name such a phrase,"
" you have trouble knowing exactly what ``RANGE`` does. You can't see the "
"manipulation in your mind. ``OVER``  ``+``   ``SWAP`` has greater "
"mnemonic value than ``RANGE``."
msgstr ""

#: ../../chapter6.rst:1010
msgid ""
"I call these phrases “clich\\'es.” They stick together as meaningful "
"functions. You don’t have to remember how the phrase works, just what it "
"does. And you don’t have to remember an extra name."
msgstr ""

#: ../../chapter6.rst:1015
msgid "Compile-Time Factoring"
msgstr ""

#: ../../chapter6.rst:1017
msgid ""
"In the last section we looked at many techniques for organizing code and "
"data to reduce redundancy."
msgstr ""

#: ../../chapter6.rst:1020
msgid ""
"We can also apply limited redundancy during compilation, by letting Forth"
" do some of out dirty work."
msgstr ""

#: ../../chapter6.rst:1025
msgid "For maximum maintainability, limit redundancy even at compile time."
msgstr ""

#: ../../chapter6.rst:1027
msgid ""
"Suppose in our application we must draw nine boxes as shown in "
":numref:`fig6-1` ."
msgstr ""

#: ../../chapter6.rst:1030
msgid "What we\\'re supposed to display"
msgstr ""

#: ../../chapter6.rst:1052
msgid ""
"In our design we need to have constants that represent values such as the"
" size of each box, the size of the gap between boxes, and the left-most "
"and top-most coordinates of the first box."
msgstr ""

#: ../../chapter6.rst:1056
msgid "Naturally we can define:"
msgstr ""

#: ../../chapter6.rst:1065
msgid "(Streets run east and west; avenues run north and south.)"
msgstr ""

#: ../../chapter6.rst:1067
msgid ""
"Now, to define the left margin, we might compute it mentally, We want to "
"center all these boxes on a screen 80 columns wide. To center something, "
"we subtract its width from 80 and divide by two to determine the left "
"margin. To figure the total width of all the boxes, we add"
msgstr ""

#: ../../chapter6.rst:1072
msgid ""
"8 + 4 + 8 + 4 + 8 = 32  (three widths and two avenues). :math:`(80-31) / "
"2 = 24`."
msgstr ""

#: ../../chapter6.rst:1078
msgid "So we could, crudely, define:"
msgstr ""

#: ../../chapter6.rst:1084
msgid "and use the same approach for ``TOPMARGIN``."
msgstr ""

#: ../../chapter6.rst:1086
msgid ""
"But what if we should later redesign the pattern, so that the width "
"changed, or perhaps the gap between the boxes? We’d have to recompute the"
" left margin ourselves."
msgstr ""

#: ../../chapter6.rst:1090
msgid ""
"In the Forth environment, we can use the full power of Forth even when "
"we’re compiling. Why not let Forth do the figuring?"
msgstr ""

#: ../../chapter6.rst:1100
msgid ""
"If a constant's value depends on the value of an earlier constant, use "
"Forth to calculate the value of the second."
msgstr ""

#: ../../chapter6.rst:1103
msgid ""
"None of these computations are performed when the application is running,"
" so run-time speed is not affected."
msgstr ""

#: ../../chapter6.rst:1106
msgid ""
"Here’s another example.  :numref:`fig6-2`  shows the code for a word that"
" draws shapes. The word ``DRAW`` emits a star at every x–y coordinate "
"listed in the table called ``POINTS``. (Note: the word ``XY`` positions "
"the cursor to the ( x y ) coordinate on the stack.)"
msgstr ""

#: ../../chapter6.rst:1111
msgid "Notice the line immediately following the list of points:"
msgstr ""

#: ../../chapter6.rst:1117
msgid "Another example of limiting compile-time redundancy."
msgstr ""

#: ../../chapter6.rst:1130
msgid ""
"The phrase ``HERE POINTS -`` computes the number of x–y coordinates in "
"the table: this value becomes the constant ``#POINTS``, used as the limit"
" in ``DRAW`` \\’s ``DO``   ``LOOP``."
msgstr ""

#: ../../chapter6.rst:1134
msgid ""
"This construct lets you add or subtract points from the table without "
"worrying about the number of points there are. Forth computes this for "
"you."
msgstr ""

#: ../../chapter6.rst:1139
msgid "Compile-Time Factoring through Defining Words"
msgstr ""

#: ../../chapter6.rst:1141
msgid ""
"Let’s examine a series of approaches to the same problem—defining a group"
" of related addresses. Here’s the first try:"
msgstr ""

#: ../../chapter6.rst:1153
msgid ""
"The idea is right, but the implementation is ugly. The only elements that"
" change from port to port are the numeric offset and the name of the port"
" being defined; everything else repeats. This repetition suggests the use"
" of a defining word."
msgstr ""

#: ../../chapter6.rst:1158
msgid ""
"The following approach, which is more readable, combines all the repeated"
" code into the “does” part of a defining word:"
msgstr ""

#: ../../chapter6.rst:1170
msgid ""
"In this solution we’re performing the offset calculation at *run*-time, "
"every time we invoke one of these names. It would be more efficient to "
"perform the calculation at compile time, like this:"
msgstr ""

#: ../../chapter6.rst:1183
msgid ""
"Here we’ve created a defining word, ``PORT``, that has a unique "
"*compile*-time behavior, namely adding the offset to "
"``BASE.PORT.ADDRESS`` and defining a ``CONSTANT``."
msgstr ""

#: ../../chapter6.rst:1187
msgid ""
"We might even go one step further. Suppose that all port addresses are "
"two bytes apart. In this case there’s no reason we should have to specify"
" these offsets. The numeric sequence"
msgstr ""

#: ../../chapter6.rst:1191
msgid "0 2 4 6"
msgstr ""

#: ../../chapter6.rst:1193
msgid "is itself redundant."
msgstr ""

#: ../../chapter6.rst:1195
msgid ""
"In the following version, we begin with the ``BASE.PORT.ADDRESS`` on the "
"stack. The defining word ``PORT`` duplicates this address, makes a "
"constant out of it, then adds 2 to the address still on the stack, for "
"the next invocation of ``PORT``."
msgstr ""

#: ../../chapter6.rst:1211
msgid ""
"Notice we must supply the initial port address on the stack before "
"defining the first port, then invoke ``DROP`` when we’ve finished "
"defining all the ports to get rid of the port address that’s still on the"
" stack."
msgstr ""

#: ../../chapter6.rst:1216
msgid ""
"One final comment. The base-port address is very likely to change, and "
"therefore should be defined in only one place. This does *not* mean it "
"has to be defined as a constant. Provided that the base-port address "
"won’t be used outside of this lexicon of port names, it’s just as well to"
" refer to it by number here."
msgstr ""

#: ../../chapter6.rst:1233
msgid "The Iterative Approach in Implementation"
msgstr ""

#: ../../chapter6.rst:1235
msgid ""
"Earlier in the book we discussed the iterative approach, paying "
"particular attention to its impact on the design phase. Now that we’re "
"talking about implementation, let’s see how the approach is actually used"
" in writing code."
msgstr ""

#: ../../chapter6.rst:1243
msgid "Work on only one aspect of a problem at a time."
msgstr ""

#: ../../chapter6.rst:1245
msgid ""
"Suppose we’re entrusted with the job of coding a word to draw or erase a "
"box at a given x–y coordinate. (This is the same problem we introduced in"
" the section called “Compile-Time Factoring.”)"
msgstr ""

#: ../../chapter6.rst:1249
msgid ""
"At first we focus our attention on the problem of drawing a box—never "
"mind erasing it. We might come up with this:"
msgstr ""

#: ../../chapter6.rst:1259
msgid ""
"Having tested this to make sure it works correctly, we turn now to the "
"problem of using the same code to *un*\\ draw a box. The solution is "
"simple: instead of hard-coding the ``ASCII *`` we\\’d like to change the "
"emitted character from an asterisk to a blank. This requires the addition"
" of a variable, and some readable words for setting the contents of the "
"variable. So:"
msgstr ""

#: ../../chapter6.rst:1273
msgid ""
"The definition of ``BOX``, along with the remainder of the application, "
"remains the same."
msgstr ""

#: ../../chapter6.rst:1276
msgid "This approach allows the syntax"
msgstr ""

#: ../../chapter6.rst:1282
msgid "or"
msgstr ""

#: ../../chapter6.rst:1288
msgid ""
"By switching from an explicit value to a variable that contains a value, "
"we’ve added a level of indirection. In this case, we’ve added indirection"
" “backwards,” adding a new level of complexity to the definition of "
"``LAYER`` without substantially lengthening the definition."
msgstr ""

#: ../../chapter6.rst:1293
msgid ""
"By concentrating on one dimension of the problem at a time, you can solve"
" each dimension more efficiently. If there’s an error in your thinking, "
"the problem will be easier to see if it’s not obscured by yet another "
"untried, untested aspect of your code."
msgstr ""

#: ../../chapter6.rst:1300
msgid "Don't change too much at once."
msgstr ""

#: ../../chapter6.rst:1302
msgid ""
"While you’re editing your application—adding a new feature or fixing "
"something—it’s often tempting to go and fix several other things at the "
"same time. Our advice: Don’t."
msgstr ""

#: ../../chapter6.rst:1306
msgid ""
"Make as few changes as you can each time you edit-compile. Be sure to "
"test the results of each revision before going on. You’d be amazed how "
"often you can make three innocent modifications, only to recompile and "
"have nothing work!"
msgstr ""

#: ../../chapter6.rst:1311
msgid ""
"Making changes one at a time ensures that when it stops working, you know"
" why."
msgstr ""

#: ../../chapter6.rst:1316
msgid "Don't try to anticipate ways to factor too early."
msgstr ""

#: ../../chapter6.rst:1318
msgid ""
"Some people wonder why most Forth systems don’t include the definition "
"word ARRAY. This rule is the reason."
msgstr ""

#: ../../chapter6.rst:1323
msgid ""
"I often have a class of things called arrays. The simplest array merely "
"adds a subscript to an address and gives you back an address. You can "
"define an array by saying"
msgstr ""

#: ../../chapter6.rst:1331
msgid "then saying"
msgstr ""

#: ../../chapter6.rst:1337
msgid "Or you can say"
msgstr ""

#: ../../chapter6.rst:1343
msgid ""
"One of the problems that\\'s most frustrating for me is knowing whether "
"it\\'s worth creating a defining word for a particular data structure. "
"Will I have enough instances to justify it?"
msgstr ""

#: ../../chapter6.rst:1347
msgid ""
"I rarely know in advance if I\\'m going to have more than one array. So I"
" don't define the word ``ARRAY``."
msgstr ""

#: ../../chapter6.rst:1350
msgid "After I discover I need two arrays, the question is marginal."
msgstr ""

#: ../../chapter6.rst:1352
msgid ""
"If I need three then it\\'s clear. Unless they\\'re different. And odds "
"are they will be different. You may want it to fetch it for you. You may "
"want a byte array, or a bit array. You may want to do bounds checking, or"
" store its current length so you can add things to the end."
msgstr ""

#: ../../chapter6.rst:1358
msgid ""
"I grit my teeth and say, \"Should I make the byte array into a cell "
"array, just to fit the data structure into the word I already have "
"available?\""
msgstr ""

#: ../../chapter6.rst:1362
msgid ""
"The more complex the problem, the less likely it will be that you\\'ll "
"find a universally applicable data structure. The number of instances in "
"which a truly complex data structure has found universal use is very "
"small. One example of a successful complex data structure is the Forth "
"dictionary. Very firm structure, great versatility. It's used everywhere "
"in Forth. But that\\s rare."
msgstr ""

#: ../../chapter6.rst:1369
msgid ""
"If you choose to define the word ``ARRAY``, you\\'ve done a decomposition"
" step. You've factored out the concept of an array from all the words "
"you\\'ll later back in. And you've gone to another level of abstraction."
msgstr ""

#: ../../chapter6.rst:1374
msgid ""
"Building levels of abstraction is a dynamic process, not one you can "
"predict."
msgstr ""

#: ../../chapter6.rst:1379
msgid "Today, make it work. Tomorrow, optimize it."
msgstr ""

#: ../../chapter6.rst:1404
msgid ""
"Again **Moore**. On the day of this interview, Moore had been completing "
"work on the design of a board-level Forth computer, using commercially "
"available ICs. As part of his toolkit for designing the board, he created"
" a simulator in Forth, to test the board\\'s logic:"
msgstr ""

#: ../../chapter6.rst:1382
msgid ""
"This morning I realized I\\'ve been mixing the descriptions of the chips "
"with the placement of the chips on the board. This perfectly convenient "
"for my purposes at the moment, but when I come up with another board that"
" I want to use the same chips for, I have arranged things very badly."
msgstr ""

#: ../../chapter6.rst:1388
msgid ""
"I should have factored it with the descriptions here and the uses there. "
"I would then have had a chip description language. Okay. At the time I "
"was doing this I was not interested in that level of optimization."
msgstr ""

#: ../../chapter6.rst:1393
msgid ""
"Even if the thought had occurred to me then, I probably would have said, "
"\"All right, I'll do that later,\" then gone right ahead with what I was "
"doing. Optimization wasn't the most important thing to me at the time."
msgstr ""

#: ../../chapter6.rst:1398
msgid ""
"Of course I try to factor things well. But if there doesn't seem to be a "
"good way to do something, I say, \"Let's just make it work.\""
msgstr ""

#: ../../chapter6.rst:1401
msgid ""
"My motivation isn't laziness, it's knowing that there are other things "
"coming down the pike that are going to affect this decision in ways I "
"can't predict. Trying to optimize this now is foolish. Until I get the "
"whole picture in front of me, I can't know what the optimum is."
msgstr ""

#: ../../chapter6.rst:1406
msgid ""
"The observations in this section shouldn’t contradict what’s been said "
"before about information hiding and about anticipating elements that may "
"change. A good programmer continually tries to balance the expense of "
"building-in changeability against the expense of changing things later if"
" necessary."
msgstr ""

#: ../../chapter6.rst:1412
msgid "These decisions take experience. But as a general rule:"
msgstr ""

#: ../../chapter6.rst:1416
msgid ""
"Anticipate things-that-may-change by organizing information, not by "
"adding complexity. Add complexity only as necessary to make the current "
"iteration work."
msgstr ""

#: ../../chapter6.rst:1421
msgid "Summary"
msgstr ""

#: ../../chapter6.rst:1423
msgid ""
"In this chapter we’ve discussed various techniques and criteria for "
"factoring. We also examined how the iterative approach applies to the "
"implementation phase."
msgstr ""

#: ../../chapter6.rst:1428
msgid "REFERNCES"
msgstr "参考文献"

#: ../../chapter6.rst:1430
msgid ""
"W.P. Stevens, G.J. Myers,and L.L. Constantine, ** IBM Systems Journal** ,"
" vol. 13, no. 2, 1974, Copyright 1974 byInternational Business Machines "
"Corporation."
msgstr ""
"W.P. Stevens, G.J. Myers,and L.L. Constantine, **IBM Systems Journal** , "
"vol. 13, no. 2, 1974, Copyright 1974 byInternational Business Machines "
"Corporation."

#: ../../chapter6.rst:1431
msgid ""
"G.A. Miller, \"The Magical Number Seven, Plus orMinus Two: Some Limits on"
" our Capacity for Processing Information,\" **Psychol. Rev** ., vol. 63, "
"pp. 81-97, Mar. 1956."
msgstr ""
"G.A. Miller, \"The Magical Number Seven, Plus orMinus Two: Some Limits on"
" our Capacity for Processing Information,\" **Psychol. Rev** ., vol. 63, "
"pp. 81-97, Mar. 1956."

#: ../../chapter6.rst:1432
msgid ""
"Kim R. Harris, \"Definition Field AddressConversion Operators,\"  **Forth"
"--83 Standard** , Forth StandardsTeam."
msgstr ""
"Kim R. Harris, \"Definition Field AddressConversion Operators,\"  **Forth"
"--83 Standard** , Forth StandardsTeam."

