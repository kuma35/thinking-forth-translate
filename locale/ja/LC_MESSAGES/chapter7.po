# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Leo Brodie
# This file is distributed under the same license as the Thinking Forth
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Thinking Forth 0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-29 05:55+0900\n"
"PO-Revision-Date: 2019-07-29 06:01+0900\n"
"Last-Translator: kuma35\n"
"Language: ja_JP\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

# Statesに関してはステート(state)とすべきか？状態でいいか？
#: ../../chapter7.rst:4
msgid "7. Handling Data: Stacks and States"
msgstr "第７章 データの取り扱い：スタックと状態"

#: ../../chapter7.rst:6
msgid ""
"Forth handles data in one of two ways: either on the stack or in data "
"structures. When to use which approach and how to manage both the stack "
"and data structures are the topics of this chapter."
msgstr "Forthは2つの方法のいずれかでデータを取扱います。それはスタックかデータ構造のいずれかです。この章の話題は、どのアプローチを使用するか、そしてスタックとデータ構造の両方をどのように管理するかです。"

#: ../../chapter7.rst:12
msgid "The Stylish Stack"
msgstr "スタイリッシュ・スタック"

#: ../../chapter7.rst:14
msgid ""
"The simplest way for Forth words to pass arguments to each other is via "
"the stack. The process is “simple” because all the work of pushing and "
"popping values to and from the stack is implicit."
msgstr ""
"Forthのワードがお互いに引数を渡す最も簡単な方法はスタックを使うことです。 "
"スタックとの間で値をプッシュしたりポップしたりする作業はすべて暗黙的であるため、このプロセスは「シンプル」です。"

#: ../../chapter7.rst:23 ../../chapter7.rst:668
msgid "**Moore**:"
msgstr "ムーアは言います。"

#: ../../chapter7.rst:19
msgid ""
"The data stack uses this idea of \"hidden information.\" The arguments "
"being passed between subroutines are not explicit in the calling "
"sequence. The same argument might ripple through a whole lot of words "
"quite invisibly, even below the level of awareness of the programmer, "
"simply because it doesn't have to be referred to explicitly."
msgstr ""
"データスタックは、この「隠し情報」の概念を使用しています。 サブルーチン間で渡される引数は、呼び出しシーケンスでは明示的ではありません。 "
"プログラマの意識レベルを下回っていても、まったく同じワードがまったく目に見えないほどたくさんのワードに波及している可能性があります。これは、単に明示的に言及する必要がないからです。"

#: ../../chapter7.rst:25
msgid ""
"One important result of this approach: Arguments are unnamed. They reside"
" on the stack, not in named variables. This effect is one of the reasons "
"for Forth’s elegance. At the same time it’s one of the reasons badly "
"written Forth code can be unreadable. Let’s explore this paradox."
msgstr ""
"このアプローチの1つの重要な結果として、引数は名前が付けられていません。 それらは名前付き変数ではなく、スタック上にあります。 "
"この効果はForthの優雅さの理由の1つです。 同時にそれは、不適切に書かれたForthコードが読めなくなる可能性がある理由の一つです。 "
"この矛盾を探って見ましょう。"

#: ../../chapter7.rst:30
msgid ""
"The invention of the stack is analogous to that of pronouns in English. "
"Consider the passage:"
msgstr "スタックの発明は、英語の代名詞の発明と似ています。その箇所について考えてみましょう。"

#: ../../chapter7.rst:33
msgid "Take this gift, wrap it in tissue paper and put it in a box."
msgstr "Take this gift, wrap it in tissue paper and put it in a box."

#: ../../chapter7.rst:35
msgid ""
"Notice the word “gift” is mentioned only once. The gift is referred to "
"henceforth as “it.”"
msgstr "「gift(贈り物)」という言葉が一度だけ述べられていることに注意してください。 gift(贈り物)は、以後「それ(it)」と呼ばれます。"

#: ../../chapter7.rst:38
msgid ""
"The informality of the “it” construct makes English more readable "
"(provided the reference is unambiguous). So with the stack, the implicit "
"passing of arguments makes code more readable. We emphasize the "
"*processes*, not the *passing of arguments* to the processes."
msgstr ""
"「それ(it)」構文が形式が張らない構文なので、英語が読みやすくなります(「それit)」を参照するものが明確である場合)。 "
"そのため、スタックでは、暗黙的に引数を渡すことでコードが読みやすくなります。 プロセスへの引数の受け渡しではなく、プロセスを重視します。"

#: ../../chapter7.rst:43
msgid ""
"Our analogy to pronouns suggests why bad Forth can be so unreadable. The "
"spoken language gets confusing when too many things are referred to with "
"pronouns."
msgstr ""
"私たちの代名詞への類推は、なぜ悪いForthがそれほど読めなくなる可能性があるかを示唆しています。 "
"あまりにも多くのことが代名詞で参照されている場合、話し言葉は混乱します。"

#: ../../chapter7.rst:47
msgid "Take off the wrapping and open the box. Remove the gift and throw it away."
msgstr "Take off the wrapping and open the box. Remove the gift and throw it away."

#: ../../chapter7.rst:50
msgid ""
"The problem with this passage is that we’re using “it” to refer to too "
"many things at once. There are two solutions to this error. The easiest "
"solution is to supply a real name instead of “it”:"
msgstr ""
"この箇所の問題は、一度に多くのものを参照するために「それ(it)」を使用していることです。 このエラーには2つの解決策があります。 "
"最も簡単な解決策は、「それ(it)」の代わりに実際の名前を指定することです。"

#: ../../chapter7.rst:54
msgid ""
"Remove the wrapping and open the box. Take out the gift and throw **the "
"box** away."
msgstr ""
"Remove the wrapping and open the box. Take out the gift and throw **the "
"box** away."

#: ../../chapter7.rst:57
msgid ""
"Or we can introduce the words “former” and “latter.” But the best "
"solution is to redesign the passage:"
msgstr "あるいは、「前者(former)」と「後者(latter)」という言葉を紹介することもできます。しかし、最良の解決策は、当該箇所を再設計することです。"

#: ../../chapter7.rst:60
msgid "Remove the wrapping and open the present. Throw away the box."
msgstr "Remove the wrapping and open the present. Throw away the box."

#: ../../chapter7.rst:62
msgid "So in Forth we have analogous observations:"
msgstr "Forthでは以下のような類似の観察結果があります。"

#: ../../chapter7.rst:66
msgid ""
"Simplify code by using the stack. But don't stack too deeply within any "
"single definition. Redesign, or, as a last resort, use a named variable."
msgstr ""
"スタックを使用してコードを単純化してください。しかし、どの定義内でも深く積み重ねないでください。 "
"再設計するか、最後の手段として、名前付き変数を使用します。"

#: ../../chapter7.rst:69
msgid ""
"Some newcomers to Forth view the stack the way a gymnast views a "
"trampoline: as a fun place to bounce around on. But the stack is meant "
"for data-passing, not acrobatics."
msgstr "Forthの初心者の中には、体操選手が楽しく飛び跳ねるトランポリンのようにスタックをとらえる人が居ます。しかし、スタックはアクロバットではなくデータの受け渡しを目的としています。"

#: ../../chapter7.rst:73
msgid ""
"So how deep is “too deep?” Generally, three elements on the stack is the "
"most you can manage within a single definition. (In double-length "
"arithmetic, each “element” occupies two stack positions but is logically "
"treated as a single element by operators such as ``2DUP``, ``2OVER``, "
"etc.)"
msgstr ""
"では、どのぐらいの深さが「深すぎる」のでしょうか？一般的に、スタック上の3つの要素が1つの定義内で管理できる最大の要素です(。2倍長演算では、各「要素」は2つのスタック位置を占めますが、"
" ``2DUP`` 、 ``2OVER`` などの演算子によって論理的に単一の要素として扱われます)。"

#: ../../chapter7.rst:79
msgid ""
"In your ordinary lexicon of stack operators, ``ROT`` is the only one that"
" gives you access to the third stack item. Aside from ``PICK`` and "
"``ROLL`` (which we’ll comment on soon), there’s no easy way to get at "
"anything below that."
msgstr ""
"通常のスタック演算子の用語集は、 ``ROT`` が3番目のスタック項目にアクセスできる唯一のものです。 ``PICK`` と ``ROLL`` "
"(これについてはすぐに説明します）以外に、それより深いものを見つける簡単な方法はありません。"

# どう訳すんだこんなの
#: ../../chapter7.rst:85
msgid ""
"To stretch our analogy to the limit, perhaps three elements on the stack "
"corresponds to the three English pronouns “this,” “that,” and “t’other.”"
msgstr "私たちの類推を限界にまで広げると、スタック上の3つの要素は、3つの英語の代名詞「this(これ)」、「that(それ)」、および「t’other(その他)」に対応する可能性があります。"

#: ../../chapter7.rst:90
msgid "Redesign"
msgstr "再設計"

#: ../../chapter7.rst:92
msgid ""
"Let’s witness a case where a wrong-headed approach leads to a messy stack"
" problem. Suppose we’re trying to write the definition of ``+THRU`` (see "
":doc:`Chapter Five<chapter5>`, “Listing Organization” section, “Relative "
"Loading” subsection). We’ve decided that our loop body will be"
msgstr ""
"間違った向きのアプローチが厄介なスタック問題につながるケースを見てみましょう。``+THRU`` の定義を書き込もうとしているとします( "
":doc:`第5章<chapter5>` の「リストの整理」の節の「相対ロード」の部分を参照)。 私たちはループ本体を以下のように定めました。"

#: ../../chapter7.rst:100
msgid ""
"that is, we’ll put ``LOAD`` in a loop, then arrange for the index and "
"limit to correspond to the absolute screens being loaded."
msgstr "つまり、 ``LOAD`` をループに入れてから、ロードされる絶対スクリーンに対応するようにインデックスと制限を調整します。"

#: ../../chapter7.rst:104
msgid "On the stack initially we have:"
msgstr "スタック上に最初にこれがあります。"

#: ../../chapter7.rst:110
msgid "where “lo” and “hi” are the *offsets* from ``BLK``."
msgstr "ここで、「lo」と「hi」は ``BLK`` からのオフセットです。"

#: ../../chapter7.rst:112
msgid "We need to permute them for ``DO``, like this:"
msgstr "私たちは、以下のようにこれらを ``DO`` の為に並べ替える必要があります。"

#: ../../chapter7.rst:118
msgid "Our biggest problem is adding the value of ``BLK`` to both offsets."
msgstr "最大の問題は両方のオフセットに ``BLK`` の値を追加することです。"

#: ../../chapter7.rst:120
msgid ""
"We’ve already taken a wrong turn but we don’t know it yet. So let’s "
"proceed. We try:"
msgstr "すでに間違った方向に進んでいますが、私たちはまだそれを知りません。なので引き続き進みましょう。 私たちは以下のように試してみます。"

#: ../../chapter7.rst:141
msgid "We made it, but what a mess!"
msgstr "私たちははそれを作りました、しかし、酷いなコレ。"

#: ../../chapter7.rst:143
msgid ""
"If we’re gluttons for punishment, we might make two more stabs at it "
"arriving at:"
msgstr "もし私たちが罪深き者なら、更に以下のコードを書いたでしょう。"

#: ../../chapter7.rst:150
msgid "and"
msgstr "と"

#: ../../chapter7.rst:156
msgid ""
"All three sequences do the same thing, but the code seems to be getting "
"blurrier, not better."
msgstr "3つのシーケンスはすべて同じことを行いますが、コードがぼやけているように見え、良くありません。"

#: ../../chapter7.rst:159
msgid ""
"With experience we learn to recognize the combination ``ROT ROT`` as a "
"danger sign: the stack is too crowded. Without having to work out the "
"alternates, we recognize the problem: once we make two copies of “blk,” "
"we have four elements on the stack."
msgstr ""
"経験を重ねると、 ``ROT ROT`` の組み合わせを危険の兆候として認識することを学びます。つまり、スタックが混雑しすぎているためです。 "
"代替案を考え出すまでもなく、私たちは問題を認識しています。「blk」のコピーを2つ作成すると、スタックには4つの要素ができます。"

#: ../../chapter7.rst:164
msgid "At this point, the first resort is usually the return stack:"
msgstr "この時点では、最初の手段は通常リターンスタックです。"

#: ../../chapter7.rst:171
msgid ""
"(See “The Stylish Return Stack,” coming up next.) Here we’ve ``DUP``\\ ed"
" “blk,” saving one copy on the return stack and adding the other copy to "
"“hi.”"
msgstr ""
"(スタイリッシュ・リターン・スタックについては次節参照) ここでは ``DUP`` を付けて “blk” "
"し、コピーの一つをリターン・スタックに保存し、コピーのもう一つを「hi」に追加します。"

#: ../../chapter7.rst:175
msgid "Admittedly an improvement. But readable?"
msgstr "これは確かに改善です。 しかし読めますかコレ？"

#: ../../chapter7.rst:177
msgid ""
"Next we think, “Maybe we need a named variable.” Of course, we have one "
"already: ``BLK``. So we try:"
msgstr ""
"次に私たちは、「名前付き変数が必要かもしれません」と思います。もちろん1つは既にあります。それは ``BLK`` "
"です。だから私たちは以下を試みます。"

#: ../../chapter7.rst:184
msgid ""
"Now it’s more readable, but it’s still rather long, and redundant too. "
"``BLK @ +`` appears twice."
msgstr "だいぶ読みやすくなりました。それでもまだ長く冗長です。 ``BLK @ +`` は2回現れています。"

#: ../../chapter7.rst:187
msgid "“``BLK @ +``”? That sounds familiar. Finally our neurons connect."
msgstr "``BLK @ +`` がおなじみのようですね。最後に私たちの頭脳が閃きます。"

#: ../../chapter7.rst:189
msgid "We look back at the source for ``+LOAD`` just defined:"
msgstr "私たちは、先ほど定義した ``+LOAD`` のソースを振り返ってみましょう。"

#: ../../chapter7.rst:195
msgid "This word, ``+LOAD``, should be doing the work. All we have to write is:"
msgstr "このワード、 ``+LOAD`` は仕事を為しているはずです。 私達が書かなければならないのは以下の通りです。"

#: ../../chapter7.rst:201
msgid ""
"We haven’t created a more efficient version here, because the work of "
"``BLK @ +`` will be done on every pass of the loop. But we have created a"
" cleaner, conceptually simpler, and more readable piece of code. In this "
"case, the inefficiency is unnoticeable because it only occurs as each "
"block is loaded."
msgstr ""
"ここではより効率的なバージョンを作成していません。なぜなら、 ``BLK @ +`` の作業はループのすべてのパスで行われるためです。 "
"しかし、私たちは、よりクリーンで、概念的によりシンプルで、より読みやすいコードを作成しました。 "
"この場合、非効率は各ブロックがロードされるときにのみ発生するため、目立ちません。"

#: ../../chapter7.rst:207
msgid ""
"Redesigning, or rethinking the problem, was the path we should have taken"
" as soon as things got ugly."
msgstr "問題を再設計すること、つまり問題を再考することは、状況が悪くなったらすぐにすべき道でした。"

#: ../../chapter7.rst:211
msgid "Local Variables"
msgstr "ローカル変数"

#: ../../chapter7.rst:213
msgid ""
"Most of the time problems can be arranged so that only a few arguments "
"are needed on the stack at any one time. Occasionally, however, there’s "
"nothing you can do."
msgstr ""
"ほとんどの場合問題は、スタック上で一度にいくつかの引数しか必要とされないように調整することができます。 "
"しかし時折、あなたができることが何もない事があります。"

#: ../../chapter7.rst:217
msgid ""
"Here’s an example of a worst case. Assume you have a word called ``LINE``"
" which draws a line between any two points, specified as coordinates in "
"this order:"
msgstr "以下がその最悪の例です。 以下の順番で座標として指定された、任意の2点間に線を引く ``LINE`` というワードがあるとします。"

#: ../../chapter7.rst:225
msgid ""
"where ``x1,y1`` represent the ``x,y`` coordinates for the one end-point, "
"and ``x2,y2`` represent the opposite end-point."
msgstr "ここで、 ``x1,y1`` は始点の、 ``x2,y2`` は終点の ``x,y`` 座標をを表します。"

#: ../../chapter7.rst:228
msgid ""
"Now you have to write a box-drawing word called ``[BOX]`` which takes "
"four arguments in this order:"
msgstr "続けて、この順番の4つの引数で、``[BOX]`` と呼ばれる箱を描くワードを書かなければなりません。"

#: ../../chapter7.rst:235
msgid ""
"where x1 y1 represent the ``x,y`` coordinates for the upper left-hand "
"corner of the box, and x2 y2 represent the lower right-hand corner "
"coordinates. Not only do you have four elements on the stack, they each "
"have to be referred to more than once as you draw lines from point to "
"point."
msgstr "ここで ``x1 y1`` はボックスの左上隅の ``x,y`` 座標を表し、``x2 y2`` は右下隅の座標を表します。 スタック上に4つの要素があるだけでなく、ポイントからポイントへと線を引くときにそれらをそれぞれ複数回参照する必要があります。"

#: ../../chapter7.rst:241
msgid ""
"Although we’re using the stack to get the four arguments, the algorithm "
"for drawing a box doesn’t lend itself to the nature of the stack. If "
"you’re in a hurry, it would probably be best to take the easy way out:"
msgstr ""
"4つの引数を取得するためにスタックを使用していますが、ボックスを描画するためのアルゴリズムの為には、スタックの特長は役立ちません。 "
"急いでいる場合は、簡単な方法で脱出することをお勧めします。"

#: ../../chapter7.rst:257
msgid ""
"What we’ve done is create four named variables, one for each coordinate. "
"The first thing ``[BOX]`` does is fill these variables with the arguments"
" from the stack. Then the four lines are drawn, referencing the "
"variables. Variables such as these that are used only within a definition"
" (or in some cases, within a lexicon) are called “local variables.”"
msgstr ""
"私たちがここで行ったことは、各座標に1つずつ、4つの名前付き変数を作成することです。 ``[BOX]`` "
"が最初に行うことは、これらの変数にスタックからの引数を入れることです。 次に、変数を参照して4本の線が描かれます。 "
"これらのような定義内(または場合によっては用語集内)でのみ使用される変数は、「ローカル変数」と呼ばれます(訳注：他の言語で言う、構文・スコープ上他からアクセスできない「局所的」な変数ではないので注意。意味的な区別に過ぎない。)。"

#: ../../chapter7.rst:264
msgid ""
"I’ve been guilty many times of playing hotshot, trying to do as much as "
"possible on the stack rather than define a local variable. There are "
"three reasons to avoid this cockiness."
msgstr ""
"私は、ローカル変数を定義するのではなく、スタック上で可能な限り多くのことを試みることで、名プレイヤーを演じるという罪を何度も犯してきました。 "
"この生意気な行為を避けなければならない理由は以下の3つです。"

#: ../../chapter7.rst:268
msgid ""
"First, it’s a pain to code that way. Second, the result is unreadable. "
"Third, all your work becomes useless when a design change becomes "
"necessary, and the order of two arguments changes on the stack. The "
"``DUP``\\ s, ``OVER``\\ s and ``ROT``\\ s weren’t really solving the "
"problem, just jockeying things into position."
msgstr ""
"第一に、そのようにコーディングするのは面倒です。 "
"第二に、結果は読めたものではありません。第三に、設計変更が必要になり、2つの引数の順序がスタック上で変わると、このすべての作業が無駄になります。 "
"``DUP`` 、 ``OVER`` 、 ``ROT`` は、問題を解決するためのものではなく、モノの場所をあっちこっち組み替えているだけでした。"

#: ../../chapter7.rst:274
msgid "With this third reason in mind, I recommend the following:"
msgstr "この第三の理由を念頭に置いて、私は次のことをお勧めします。"

#: ../../chapter7.rst:278
msgid ""
"Especially in the design phase, keep on the stack only the arguments "
"you're using immediately. Create local variables for any others. (If "
"necessary, eliminate the variables during the optimization phase.)"
msgstr ""
"特に設計段階では、すぐに使用する引数だけをスタックに残してください。 "
"他のためにはローカル変数を作成します(必要に応じて、最適化段階で変数を削除してください)。"

#: ../../chapter7.rst:282
msgid ""
"Fourth, if the definition is extremely time-critical, those tricky stack "
"manipulators, (e.g., ``ROT ROT``) can really eat up clock cycles. Direct "
"access to variables is faster."
msgstr ""
"第四に、定義が非常に時間的にクリティカルな場合、それらの扱いにくいスタック演算子(例えば ``ROT ROT`` "
")は実際に、クロックサイクルを使い果たす可能性があります。 変数に直接アクセスする方が速いです。"

#: ../../chapter7.rst:286
msgid ""
"If it’s *really* time-critical, you may need to convert to assembler "
"anyway. In this case, all your stack problems fly out the door, because "
"all your data will be referenced either in registers or indirectly "
"through registers. Luckily, the definitions with the messiest stack "
"arguments are often the ones written in code. Our ``[BOX]`` primitive is "
"a case in point. ``CMOVE>`` is another."
msgstr ""
"それが「本当に」時間的にクリティカルな場合は、とにかくアセンブラに変換する必要があるかもしれません。 "
"この場合、すべてのデータがレジスタ内または間接的にレジスタを介して参照されるため、スタックに関するすべての問題が発生します。 "
"幸いなことに、最も扱いにくいスタック引数を持つ定義は、多くの場合機械語で書かれたものです。 我々の ``[BOX]`` "
"プリミティブはその一例です。 ``CMOVE>`` がもう一つの例です。"

#: ../../chapter7.rst:293
msgid ""
"The approach we took with ``[BOX]`` certainly beats spending half an hour"
" juggling items on the stack, but it is by no means the best solution. "
"What’s nasty about it is the expense of creating four named variables, "
"headers and all, solely for use within this one routine."
msgstr ""
"``[BOX]`` "
"で行ったアプローチは、確かに30分掛けてスタック上のアイテムをジャグリングするのに費やすドキドキよりは優れていますが、それは決して最善の解決策ではありません。"
" 最低なのは、この1つのルーチン内で使用するためだけに、4つの名前付き変数、ヘッダー、およびすべてを作成することの費用です。"

#: ../../chapter7.rst:298
msgid ""
"(If you’re target compiling an application that will not require headers "
"in the dictionary, the only loss will be the 8 bytes in RAM for the "
"variables. In Forth systems of the future, headers may be separated into "
"other pages of memory anyway; again the loss will be only 8 bytes.) Let "
"me repeat: This example represents a worst-case situation, and occurs "
"rarely in most Forth applications. If words are well-factored, then each "
"word is designed to do very little. Words that do little generally "
"require few arguments."
msgstr ""
"（辞書のヘッダを必要としないアプリケーションをコンパイルすることを目標としているならば、唯一の損失は変数のためのRAMの8バイトです。将来のForthシステムでは、ヘッダはとにかくメモリの他のページに分けられるかもしれません)。"
" 繰り返しますが、この例は最悪の状況を表しており、ほとんどのForthアプリケーションではめったに発生しません。 "
"ワードがよくファクタリング(要素分解)されているならば、それぞれのワードがすることはほんの少しになるように設計できています。。 "
"ほんの少ししかすることがない無いワードでは、一般に引数はほとんど必要ありません。"

#: ../../chapter7.rst:307
msgid ""
"In this case, though, we are dealing with two points each represented by "
"two coordinates."
msgstr "ただし、この場合は、それぞれ2つの座標で表される2つの点を扱います。"

#: ../../chapter7.rst:310
msgid ""
"Can we change the design? First, ``LINE`` may be *too* primitive a "
"primitive. It requires four arguments because it can draw lines between "
"any two points, diagonally, if necessary."
msgstr ""
"デザインを変更できるでしょうか？ まず、 ``LINE`` はあまりに原始的なプリミティブ・ワードなのかもしれません。 "
"必要に応じて任意の2点間に斜めに線を引くことができるので、4つの引数が必要です。"

#: ../../chapter7.rst:314
msgid ""
"In drawing our box, we may only need perfectly vertical and horizontal "
"lines. In this case we can write the more powerful, but less specific, "
"words ``VERTICAL`` and ``HORIZONTAL`` to draw these lines. Each requires "
"only *three* arguments: the starting position’s x and y, and the length. "
"This factoring of function simplifies the definition of ``[BOX]``."
msgstr ""
"私たちの箱を描くとき、私たちは完全に垂直と完全に水平の線を必要とするだけです。この場合、これらの線を引くために、もっと強力ではあるが割と普遍的なワード"
" ``VERTICAL`` と ``HORIZONTAL`` を書くことができます。 "
"それぞれに必要な引数は3つだけです。開始位置のxとy、そして長さです。 この機能のファクタリング((要素分解)は ``[BOX]`` "
"の定義を簡単にします。"

#: ../../chapter7.rst:320
msgid "Or we might discover that this syntax feels more natural to the user:"
msgstr "または、以下の構文がユーザーにとってより自然に感じられることを発見するかもしれません。"

#: ../../chapter7.rst:326
msgid ""
"where ``ORIGIN!`` sets a two-element pointer to the “origin,” the place "
"where the box will start (the upper left-hand corner). Then ``30 30 BOX``"
" draws a box 30 units high and 30 units wide, relative to the origin."
msgstr ""
"ここで ``ORIGIN!`` は箱が始まる位置(左上隅)を指す「原点(origin)」への2要素のポインタを設定します。 それから ``30 "
"30 BOX`` は原点から高さ30単位、幅30単位の箱を描きます。"

#: ../../chapter7.rst:330
msgid ""
"This approach reduces the number of stack arguments to ``BOX`` as part of"
" the design."
msgstr "このアプローチは設計の一部として ``BOX`` の為のスタック引数の数を減らします。"

#: ../../chapter7.rst:335
msgid ""
"When determining which arguments to handle via data structures rather "
"than via the stack, choose the arguments that are the more permanent or "
"that represent a current state."
msgstr "スタックを介してではなくデータ構造を介してどの引数を処理するかを決定するときは、より永続的な引数、または現在の状態を表す引数を選択してください。"

#: ../../chapter7.rst:340
msgid "On PICK and ROLL"
msgstr "``PICK`` と ``ROLL``"

#: ../../chapter7.rst:342
msgid ""
"Some folks like the words ``PICK`` and ``ROLL``. They use these words to "
"access elements from any level on the stack. We don’t recommend them. For"
" one thing, ``PICK`` and ``ROLL`` encourage the programmer to think of "
"the stack as an array, which it is not. If you have so many elements on "
"the stack that you need ``PICK`` and ``ROLL``, those elements should be "
"in an array instead."
msgstr ""
"``PICK`` や ``ROLL`` というワードが好きな人もいます。 "
"彼らはこれらのワードを使ってスタックのどの深さの要素にでもにアクセスします。 私はお勧めしません。まず、 ``PICK`` と ``ROLL`` "
"はプログラマがスタックを配列と考えることを奨励しますが、実際はそうではありません。スタックに非常に多くの要素があり、 ``PICK`` と "
"``ROLL`` が必要な場合は、それらの要素は代わりに配列に含まれるべきです。"

#: ../../chapter7.rst:351
msgid ""
"Second, they encourage the programmer to refer to arguments that have "
"been left on the stack by higher-level, calling definitions without being"
" explicitly *passed* as arguments. This makes the definition dependent on"
" other definitions. That’s unstructured—and dangerous."
msgstr ""
"第二に、彼らは、目の前で引数として渡されたものに対して定義を呼び出すのではなく、より間接的なレベルでスタックに残されている引数を参照することをプログラマに奨励します。これにより、定義は他の定義に依存します。"
" それは構造化されていない。危険です。"

#: ../../chapter7.rst:356
msgid ""
"Finally, the position of an element on the stack depends on what’s above "
"it, and the number of things above it can change constantly. For "
"instance, if you have an address at the fourth stack position down, you "
"can write"
msgstr ""
"最後に、スタック上の要素の位置は、その上にあるものによって異なり、その上にあるものの数は常に変化します。 "
"たとえば、4番目のスタック位置の下にアドレスがある場合は以下のように書くことができます。"

#: ../../chapter7.rst:365
msgid "to fetch its contents. But you must write"
msgstr "その内容を取得します。 しかし、あなたは以下のように書く必要があります。"

#: ../../chapter7.rst:371
msgid ""
"because with ``n`` on the stack, the address is now in the fifth "
"position. Code like this is hard to read and harder to modify."
msgstr "なぜなら、スタックに ``n`` があると、アドレスは現在5番目の位置にあるからです。 このようなコードは読みにくく、修正が困難です。"

#: ../../chapter7.rst:375
msgid "Make Stack Drawings"
msgstr "スタック図面の作成"

#: ../../chapter7.rst:377
msgid ""
"When you do have a cumbersome stack situation to solve, it’s best to work"
" it out with paper and pencil. Some people even make up forms, such as "
"the one in :numref:`fig7-1` . Done formally like this (instead of on the "
"back of your phone bill), stack commentaries serve as nice auxiliary "
"documentation."
msgstr ""
"解決するのが面倒なスタック状況があるときは、紙と鉛筆で解決するのが最善です。 :numref:`fig7-1` のような書式を作る人もいます。 "
"正式に（電話の請求書の裏面にではなく）このように行われている場合、スタック解説は素晴らしい補助資料として役立ちます。"

#: ../../chapter7.rst:384
msgid "Stack Tips"
msgstr "スタックに関するヒント"

#: ../../chapter7.rst:388
msgid "Make sure that stack effects balance out under all possible control flows"
msgstr "スタック効果がすべての可能な制御フローの下でバランスが取れていることを確認してください。"

#: ../../chapter7.rst:390
msgid ""
"In the stack commentary for ``CMOVE>`` in :numref:`fig7-1` , the inner "
"brace represents the contents of the ``DO``  ``LOOP``. The stack depth "
"upon exiting the loop is the same as upon entering it: one element. "
"Within the outer braces, the stack result of the ``IF`` clause is the "
"same as that of the ``ELSE`` clause: one element left over. (What that "
"leftover element represents doesn’t matter, as symbolized by the “x” next"
" to ``THEN``.)"
msgstr ""
":numref:`fig7-1` の ``CMOVE>`` のためのスタック解説では、内側の波括弧が ``DO…LOOP`` "
"の内容を表しています。 ループから出るときのスタックの深さは、ループに入るときと同じです。1要素です。 外側の中括弧内では、 ``IF`` "
"節のスタック結果は ``ELSE`` 節の結果と同じです。1つの要素が残ります( ``THEN`` "
"のところに「x」が付くように、残りの要素が何を表しているかは問題ではありません)。"

#: ../../chapter7.rst:404
msgid "Example of a stack commentary."
msgstr "スタック解説の例"

#: ../../chapter7.rst:408
msgid ""
"When doing two things with the same number, perform the function that "
"will go underneath first."
msgstr "同じ数値で2つのことをするときは、最初にスタックの下に置く方の機能を実行してください。"

#: ../../chapter7.rst:411
msgid "For example:"
msgstr "例えば以下のように。"

#: ../../chapter7.rst:417
msgid "(where you first get the count) is more efficiently written:"
msgstr "（あなたが最初にカウント( ``1+`` )を得るなら）もっと効率的に書く事ができます。"

#: ../../chapter7.rst:423
msgid "(where you first compute the address)."
msgstr "(あなたは最初にアドレスを計算します。)"

#: ../../chapter7.rst:427
msgid ""
"Where possible, keep the number of return arguments the same in all "
"possible cases."
msgstr "可能な場合は、可能な限りすべての戻り引数の数を同じにしてください。"

#: ../../chapter7.rst:430
msgid ""
"You’ll often find a definition which does some job and, if something goes"
" wrong, returns an error-code identifying the problem. Here’s one way the"
" stack interface might be designed:"
msgstr ""
"あなたはしばしば何らかの仕事をする定義を見つけるでしょう、そして何かがうまくいかないなら、問題を特定するエラーコードを返します。 "
"これがスタックインターフェースの設計方法の1つです。"

#: ../../chapter7.rst:439
msgid ""
"If the flag is true, the operation was successful. If the flag is false, "
"it was unsuccessful and there’s another value on the stack to indicate "
"the nature of the error."
msgstr "フラグがtrueの場合、操作は成功しました。 フラグがfalseの場合は失敗し、エラーの性質を示す別の値がスタックにあります。"

#: ../../chapter7.rst:443
msgid ""
"You’ll find stack manipulation easier, though, if you redesign the "
"interface to look like this:"
msgstr "ただし、インターフェイスを以下のように設計し直すと、スタック操作が簡単になります。"

#: ../../chapter7.rst:450
msgid ""
"One value serves both as a flag and (in case of an error) the error code."
" Note that reverse-logic is used; non-zero indicates an error. You can "
"use any values for the error codes except zero."
msgstr ""
"1つの値がフラグとしても（エラーの場合には）エラーコードとしても機能します。 逆論理が使用されていることに注意してください。 "
"ゼロ以外はエラーを示します。 エラーコードには、ゼロ以外の任意の値を使用できます。"

#: ../../chapter7.rst:456
msgid "The Stylish Return Stack"
msgstr "スタイリッシュ・リターン・スタック"

#: ../../chapter7.rst:458
msgid ""
"What about this use of the return stack to hold temporary arguments? Is "
"it good style or what?"
msgstr "一時的な引数を保持するためのリターンスタックの使用についてはどうでしょうか？それは良いスタイルなのでしょうか？"

#: ../../chapter7.rst:461
msgid ""
"Some people take great offense to its use. But the return stack offers "
"the simplest solution to certain gnarly stack jams. Witness the "
"definition of ``CMOVE>`` in the previous section."
msgstr ""
"何人かの人々はその使用に大いに立腹します。 しかし、リターンスタックは、特定のぎくしゃくしたスタックの詰まりに対して最も簡単な解決策を提供します。"
" 前節の ``CMOVE>`` の定義を見てください。"

#: ../../chapter7.rst:465
msgid ""
"If you decide to use the return stack for this purpose, remember that you"
" are using a component of Forth for a purpose other than that intended. "
"(See the section called “Sharing Components,” later in this chapter.)"
msgstr ""
"この目的でリターンスタックを使用することにした場合は、意図した以外の目的でForthのコンポーネントを使用していることに注意してください。 "
"（この章で後述する「コンポーネントの共有」という節を参照してください。）"

#: ../../chapter7.rst:470
msgid "Here’s some suggestions to keep you from shooting yourself in the foot:"
msgstr "ここで、あなたが自分の足を撃たないようにするためのいくつかの提案があります。"

#: ../../chapter7.rst:474
msgid "Keep return stack operators symmetrical."
msgstr "リターンスタック演算子を対称に保って下さい。"

#: ../../chapter7.rst:475
msgid "Keep return stack operators symmetrical under all control flow conditions."
msgstr "リターンスタック演算子は、すべての制御フロー条件下で対称に保って下さい。"

#: ../../chapter7.rst:477
msgid ""
"In factoring definitions, watch out that one part doesn't contain one "
"return stack operator, and the other its counterpart."
msgstr "定義のファクタリング(要素分解)では、片方の部分にだけリターンスタック演算子が含まれてなかったり、対応が合ってないなんてことにならないように注意してください。"

#: ../../chapter7.rst:479
msgid ""
"If used inside a ``DO``  ``LOOP`` , return stack operators must be "
"symmetrical within the loop, and ``I`` is no longer valid in code bounded"
" by ``>R`` and ``R>``."
msgstr ""
"``DO…LOOP`` の中で使われる場合、リターンスタック演算子はループ内で対称的でなければなりません、そして ``I`` は ``>R`` と"
" ``R>`` で囲まれたコードではもはや有効ではありません。 "

#: ../../chapter7.rst:483
msgid ""
"For every ``>R`` there must be a ``R>`` in the same definition. Sometimes"
" the operators will appear to be symmetrical, but due to the control "
"structure they aren’t. For instance:"
msgstr ""
"すべての ``>R`` に対して、同じ定義内に `` R> `` がなければなりません。 "
"演算子は対称に見えることがありますが、それらは制御構造ではありません。 たとえば以下"

#: ../../chapter7.rst:492
msgid ""
"If this construction is used in the outer loop of your application, "
"everything will run fine until you exit (perhaps hours later) when you’ll"
" suddenly blow up. The problem? The last time through the loop, the "
"resolving ``R>`` has been skipped."
msgstr ""
"この構造がアプリケーションの外側のループで使用されている場合は、突然爆発して終了するまで（おそらく数時間後）、すべて正常に動作します。 "
"何が問題なのでしょう？ 最後のループで ``R>`` はスキップされます。"

#: ../../chapter7.rst:498
msgid "The Problem With Variables"
msgstr "変数に伴う問題"

#: ../../chapter7.rst:500
msgid ""
"Although we handle data of immediate interest on the stack, we depend on "
"much information tucked away in variables, ready for recurring access. A "
"piece of code can change the contents of a variable without necessarily "
"having to know anything about how that data will be used, who will use "
"it, or when and if it will be used. Another piece of code can fetch the "
"contents of a variable and use it without knowing where that value came "
"from."
msgstr ""
"私たちはスタック上ですぐに関心のあるデータを処理しますが、変数に入れられた多くの情報に依存しており、繰り返しアクセスできるようになっています。 "
"コードの一部は、そのデータがどのように使用されるのか、誰がそれを使用するのか、いつ使用されるのか、そしていつ使用されるのかについて必ずしも何かを知る必要なく、変数の内容を変更できます。"
" 別のコードでは、変数の内容を取得して、その値がどこから来たのかを知らなくても使用できます。"

#: ../../chapter7.rst:508
msgid ""
"For every word that pushes a value onto the stack, another word must "
"consume that value. The stack gives us point-to-point communication, like"
" the post office."
msgstr ""
"値をスタックにプッシュするワードごとに、別のワードがその値を消費する必要があります。 "
"このスタックは、郵便局のように、ポイントツーポイントの通信を可能にします。"

#: ../../chapter7.rst:512
msgid ""
"Variables, on the other hand, can be set by any command and accessed any "
"number of times—or not at all—by any command. Variables are available for"
" anyone who cares to look—like graffiti."
msgstr "一方、変数は任意のコマンドで設定でき、任意のコマンドで何度でもアクセス(または、全くアクセスしない事が)できます。落書きのように、目に止めた人は誰でも変数を利用できます。"

#: ../../chapter7.rst:516
msgid "Thus variables can be used to reflect the current state of affairs."
msgstr "したがって、変数は現在の状況を反映するために使用できます。"

#: ../../chapter7.rst:518
msgid ""
"Using currentness can simplify problems. In the Roman numeral example of "
":doc:`Chapter Four<chapter4>`, we used the variable ``COLUMN#`` to "
"represent the current decimal-place; the words ``ONER``, ``FIVER``, and "
"``TENER`` depended on this information to determine which type of symbol "
"to display. We didn’t have to specify both descriptions every time, as in"
" ``TENS ONER``, ``TENS FIVER``, etc."
msgstr ""
"現時性を利用すると問題を単純化できます。 :doc:`第４章<chapter4>` のローマ数字の例では、現在の桁位置を表すために変数 "
"``COLUMN#`` を使いました。 ``ONER`` 、 ``FIVER`` 、``TENER`` "
"というワード、どの種類のシンボルを表示するかを決定するためにこの情報に依存していました。 ``TENS ONER`` や ``TENS "
"FIVER`` などのように、毎回両方の説明を指定する必要はありませんでした。"

#: ../../chapter7.rst:526
msgid ""
"On the other hand, currentness adds a new level of complexity. To make "
"something current we must first define a variable or some type of data "
"structure. We also must remember to initialize it, if there’s any chance "
"that part of our code will refer to it before another part has had a "
"chance to set it."
msgstr ""
"一方で、現時性は新しいレベルの複雑さを追加します。 最新の情報にするには、最初に変数またはある種のデータ構造を定義する必要があります。 "
"他の部分がそれを設定する機会がある前に、私たちのコードの部分がそれを参照する可能性があるならば、我々はそれを初期化することを忘れないでください。"

#: ../../chapter7.rst:532
msgid ""
"A more serious problem with variables is that they are not “reentrant.” "
"On a multi-tasked Forth system, each task which requires local variables "
"must have its own copies. Forth’s ``USER`` variables serve this purpose. "
"(See *Starting Forth*, Chapter Nine, “Forth Geography.”)"
msgstr ""
"変数に関するより深刻な問題は、それらが「再入可能(リエントラント)」ではないということです。マルチタスクのForthシステムでは、ローカル変数を必要とする各タスクはそれ自身のコピーを持たなければなりません。"
" Forthの ``USER`` 変数はこの目的を果たします( *Starting Forth* Chapter 9、\"Forth "
"Geography\";邦訳 FORTH入門 第９章「仮面の下に」参照)。"

#: ../../chapter7.rst:538
msgid ""
"Even within a single task, a definition that refers to a variable is "
"harder to test, verify, and reuse in a different situation than one in "
"which arguments are passed via the stack."
msgstr "単一のタスク内でも、変数を参照する定義は、引数がスタックを介して渡される場合とは異なる状況でテスト、検証、および再利用するのが困難です。"

#: ../../chapter7.rst:542
msgid ""
"Suppose we are implementing a word-processor editor. We need a routine "
"that calculates the number of characters between the current cursor "
"position and the previous carriage-return/line-feed sequence. So we write"
" a word that employs a ``DO``   ``LOOP`` starting at the current position"
" (``CURSOR @``) and ending at the zeroth position, searching for the line"
" feed character."
msgstr ""
"ワープロ、エディタを実装しているとします。 現在のカーソル位置と前の改行文字との間の文字数を計算するルーチンが必要です。 そのため、現在位置( "
"``CURSOR @`` )から始まり、0番目の位置まで、 ``DO…LOOP`` を使って改行文字を検索するワードを書きます。"

#: ../../chapter7.rst:550
msgid ""
"Once the loop has found the character sequence, we subtract its relative "
"address from our current cursor position"
msgstr "ループが当該文字パターンを見つけたら、現在のカーソル位置からその相対アドレスを引きます。"

#: ../../chapter7.rst:557
msgid "to determine the distance between them."
msgstr "それらの間の距離を決定します。"

#: ../../chapter7.rst:559
msgid "Our word’s stack effect is:"
msgstr "私たちのワードのスタック効果は以下のようになります。"

#: ../../chapter7.rst:565
msgid ""
"But in later coding we find we need a similar word to compute the "
"distance from an arbitrary character—\\ *not* the current cursor "
"position—to the first previous line-feed character. We end up factoring "
"out the “``CURSOR @``” and allowing the starting address to be passed as "
"an argument on the stack, resulting in:"
msgstr ""
"しかし、のちのコーディングで、現在のカーソル位置ではなく任意の文字から最初の前の改行文字までの距離を計算するための同様のワードが必要なことが分かりました。"
" ``CURSOR @`` を取り除き、開始アドレスをスタックの引数として渡すことができるようすると、以下のようになります。"

#: ../../chapter7.rst:575
msgid ""
"By factoring-out the reference to the variable, we made the definition "
"more useful."
msgstr "変数への参照を括り出すことで、定義をより便利にしました。"

#: ../../chapter7.rst:580
msgid ""
"Unless it involves cluttering up the stack to the point of unreadability,"
" try to pass arguments via the stack rather than pulling them out of "
"variables."
msgstr "読みにくくなるまでスタックを乱雑にしない限り、引数を変数から引き出すのではなく、スタックを介して引数を渡すようにしてください。"

#: ../../chapter7.rst:597
msgid "**Kogge**:"
msgstr "Koggeは言います。"

# 机の上の友人の下りはちと意味不明
#: ../../chapter7.rst:585
msgid ""
"Most of the modularity of Forth comes from designing and treating Forth "
"words as \"functions\" in the mathematical sense. In my experience a "
"Forth programmer usually tries quite hard to avoid defining any but the "
"most essential global variables (I have a friend who has the sign \"Help "
"stamp out variables\" above his desk), and tries to write words with what"
" is called \"referential transparency,\" i.e., given the same stack "
"inputs a word will always give the same stack outputs regardless of the "
"more global context in which it is executed."
msgstr ""
"Forthのモジュール性のほとんどは、Forthのワードを数学的な意味での「関数(function)」として設計および処理することによって得られます。"
" "
"私の経験では、Forthのプログラマは通常、最も重要なグローバル変数以外のものを定義しないようにします(机の上に「変数を打ち出すヘルプ」という書き込みのある友人が居ます）。"
" "
"つまり、参照透過性のあるワードを書こうとします。すなわち、同じスタック入力が与えられると、それが実行されるより大域的な文脈に関係なく、ワードは常に同じスタック出力を与えるでしょう。"

#: ../../chapter7.rst:594
msgid ""
"In fact this property is exactly what we use when we test words in "
"isolation.  Words that do not have this property are significantly harder"
" to test. In a sense a \"named variable\" whose value changes frequently "
"is the next worst thing to the now \"forbidden\" GOTO."
msgstr ""
"実際、この性質は、ワードを単独でテストするときに使用するものとまったく同じです。 この性質を持たないワードはテストするのがかなり難しいです。 "
"ある意味では、値が頻繁に変わる「名前付き変数」は、今どきは「禁止されている」GOTOの次に良くない代物です。"

#: ../../chapter7.rst:603
msgid ""
"\"Shot from a cannon on a fast-moving train, hurtling between the blades "
"of a windmill, and expecting to grab a trapeze dangling from a hot-air "
"balloon... I told you Ace, there were too many variables!\""
msgstr "「高速移動する列車から大砲で撃ち出され、風車の羽根の間をくぐりぬけ、そして熱気球からぶら下がっているブランコをつかむ事を期待して…あなたはエースだけど、あまりにも変数が多すぎたわ」"

#: ../../chapter7.rst:605
msgid ""
"Earlier we suggested the use of local variables especially during the "
"design phase, to eliminate stack traffic. It’s important to note that in "
"doing so, the variables were referred to only within the one definition. "
"In our example, ``[BOX]`` receives four arguments from the stack and "
"immediately loads them into local variables for its own use. The four "
"variables are not referred to outside of this definition, and the word "
"behaves safely as a function."
msgstr ""
"以前、スタック渋滞を排除するために、特に設計段階でローカル変数を使用することをお勧めしました。 "
"その際、変数は1つの定義内でのみ参照されることに注意することが重要です。 私たちの例では、 ``[BOX]`` "
"はスタックから4つの引数を受け取り、すぐにそれらをローカル変数にロードして使用します。 "
"4つの変数はこの定義外では参照されず、ワードは関数として安全に動作します。"

#: ../../chapter7.rst:613
msgid ""
"Programmers unaccustomed to a language in which data can be passed "
"implicitly don’t always utilize the stack as fully as they should. "
"Michael Ham suggests the reason may be that beginning Forth users don’t "
"trust the stack [ham83]_. He admits to initially feeling safer about "
"storing values into variables than leaving them on the stack. “No telling"
" *what* might happen with all that thrashing about on the stack,” he "
"felt."
msgstr ""
"暗黙のうちにデータを渡すことができる言語に慣れていないプログラマは、必要なだけスタックを利用するとは限りません。マイケル・ハムは、その理由はおそらくForthユーザがスタックを信頼していないことにあると示唆しています。"
" [ham83]_ \n"
"最初は値をスタックに残すことよりも、変数に値を格納することがより安全だと感じる事を、彼は認めています。「スタック上で転げ回っているすべてのことで何が起こるのかわからない」と彼は感じました。"

#: ../../chapter7.rst:622
msgid ""
"It took some time for him to appreciate that “if words keep properly to "
"themselves, using the stack only for their expected input and output and "
"cleaning up after themselves, they can be looked upon as sealed systems …"
" I could put the count on the stack at the beginning of the loop, go "
"through the complete routine for each group, and at the end the count "
"would emerge, back on top of the stack, not a hair out of place.”"
msgstr "「期待される入力と出力のためだけにスタックを使用し、自分自身が後でクリーンアップすることを、ワードそれ自身が正しく守れば、それらは封印されたシステムとみなすことができます…私はループの初めにスタックにカウントを置くことができます。各グループの為の完全なルーチンを実行させ、そしてそれが終わると、最後にスタックの先頭にはカウントがあります。髪の毛ほどもズレていません」彼がこれを理解するには少し時間がかかりました。"

#: ../../chapter7.rst:631
msgid "Local and Global Variables/Initialization"
msgstr "ローカル、グローバル変数と、その初期化"

#: ../../chapter7.rst:633
msgid ""
"As we saw earlier, a variable that is used exclusively within a single "
"definition (or single lexicon), hidden from other code, is called a local"
" variable. A variable used by more than one lexicon is called a global "
"variable. As we’ve seen in an earlier chapter, a set of global variables "
"that collectively describe a common interface between several lexicons is"
" called an “interface lexicon.”"
msgstr ""
"前に見たように、他のコードから隠された、単一の定義（または単一の用語集）内で排他的に使用される変数は、ローカル変数と呼ばれます。 "
"複数の用語集で使用される変数は、グローバル変数と呼ばれます。 "
"前章で見たように、いくつかの用語集間の共通のインターフェースをまとめて記述するグローバル変数のセットは「インターフェース用語集」と呼ばれます。"

#: ../../chapter7.rst:640
msgid ""
"Forth makes no distinction between local and global variables. But Forth "
"programmers do."
msgstr "Forthは、ローカル変数とグローバル変数を区別しません。 しかし、Forthプログラマはそうしています。"

#: ../../chapter7.rst:644
msgid ""
"We should be writing for the reader. If something is referred to only "
"locally, a temporary variable just for accumulating a sum in, we should "
"define it locally. It's handier to define it in the block where it's "
"used, where you can see its comment."
msgstr ""
"私たちは読者のために書くべきです。 ローカルでのみ参照される場合、合計を累積するための一時的な変数である場合は、ローカルで定義する必要があります。"
" それが使用されているブロック内でそれを定義するほうが便利で、あなたはそこにそれのコメントを見ることができます。"

#: ../../chapter7.rst:649
msgid ""
"If it's used globally, we should collect things according to their "
"logical function, and define them together on a separate screen. One per "
"line with a comment."
msgstr ""
"もしそれがグローバルに使われているのであれば、私達はそれらの論理的機能に従って物事を集め、そして別のスクリーン上でそれらを一緒に定義するべきです。"
" 1行に１つ、コメント付きで。"

#: ../../chapter7.rst:653
msgid ""
"The question is, where do you initialize them? Some say on the same line,"
" immediately following its definition. But that messes up the comments, "
"and there isn't room for any decent comment. And it scatters the "
"initialization all over the application."
msgstr ""
"問題は、どこでそれらを初期化するかです。その定義のすぐ後に、同じ行で、と言う人もいます。 "
"しかし、それはコメントをめちゃめちゃにします、そしてまともなコメントの余地はありません。 "
"そして、それはアプリケーション全体にわたって初期化を散乱させます。"

#: ../../chapter7.rst:658
msgid ""
"I tend to do all my initialization in the load screen. After I've loaded "
"all my blocks, I initialize the things that have to be initialized. It "
"might also set up color lookup tables or execute some initialization "
"code."
msgstr ""
"私は、初期化はすべてロード・スクリーンで行います。 すべてのブロックをロードしたら、初期化する必要があるものを初期化します。 "
"カラールックアップ表を設定したり、初期化コードを実行したりする可能性もあります。"

#: ../../chapter7.rst:662
msgid ""
"If your program is destined to be target compiled, then it's easy to "
"write a word at the point that encompasses all the initialization."
msgstr "あなたのプログラムがターゲットコンパイルされることになっているならば、すべての初期化を包含する場所にワードを書くのは簡単です。"

#: ../../chapter7.rst:665
msgid ""
"It can get much more elaborate. I've defined variables in ROM where the "
"variables were all off in an array in high memory, and the initial values"
" are in ROM, and I copy up the initial values at initialization time. But"
" usually you're only initializing a few variables to anything other than "
"zero."
msgstr ""
"もっと複雑になることがあります。 "
"私は変数をROM内で定義しました。変数はすべてハイメモリの配列でオフになっていて、初期値はROM内にあります。初期値は初期化時にコピーします。 "
"しかし、通常は、いくつかの変数をゼロ以外のものに初期化するだけです。"

#: ../../chapter7.rst:671
msgid "Saving and Restoring a State"
msgstr "状態の保存と復元"

#: ../../chapter7.rst:673
msgid ""
"Variables have the characteristic that when you change their contents, "
"you clobber the value that was there before. Let’s look at some of the "
"problems this can create, and some of the things we can do about them."
msgstr ""
"変数には、内容を変更すると以前に存在していた値が上書きされるという特性があります。 "
"これが引き起こす問題と、それらについて我々ができることのいくつかを見てみましょう。"

#: ../../chapter7.rst:677
msgid ""
"``BASE`` is a variable that indicates the current number radix for all "
"numeric input and output. The following words are commonly found in Forth"
" systems:"
msgstr "``BASE`` は全ての数値入出力に対する現在の基数を示す変数です。 以下のワードは、Forthシステムで一般的に見られます。"

#: ../../chapter7.rst:686
msgid ""
"Suppose we’ve written a word that displays a “dump” of memory. "
"Ordinarily, we work in decimal mode, but we want the dump in hexadecimal."
" So we write:"
msgstr ""
"メモリダンプを表示するワードを書いたとします。 通常、私たちは10進数モードで作業しますが、ダンプは16進数で行います。 "
"だから私たちは以下ように書きます。"

#: ../../chapter7.rst:695
msgid ""
"This works—most of the time. But there’s a presumption that we want to "
"come back to decimal mode. What if it had been working in hexadecimal, "
"and wants to come back to hexadecimal? Before we change the base to "
"``HEX``, we have to save its current value. When we’re done dumping, we "
"restore it."
msgstr ""
"ほとんどの場合、これは機能します。 しかし、それらは10進数モードに戻りたいだろうという推測に基づいています。 "
"16進数で機能していて、16進数に戻りたい場合はどうなりますか？ 基数を ``HEX`` に変更する前に、現在の値を保存する必要があります。 "
"そしてダンプが完了したら復元します。"

#: ../../chapter7.rst:701
msgid ""
"This means we have to tuck away the saved value temporarily, while we "
"format the dump. The return stack is one place to do this:"
msgstr ""
"これは、ダンプをフォーマットしている間、保存した値を一時的に隠しておく必要があることを意味します。 "
"リターンスタックはこれを行うための1つの場所です。"

#: ../../chapter7.rst:710
msgid "If things get too messy, we may have to define a temporary variable:"
msgstr "面倒になりすぎる場合は、一時変数を定義する必要があります。"

#: ../../chapter7.rst:719
msgid "How quickly things get complicated."
msgstr "物事はすぐに複雑になります。"

#: ../../chapter7.rst:721
msgid ""
"In this situation, if both the current and the old version of a variable "
"belong only to your application (and not part of your system), and if "
"this same situation comes up more than once, apply a technique of "
"factoring:"
msgstr "このような場合、現在のバージョンと古いバージョンの変数の両方が自分のアプリケーションだけに属していて（システムの一部ではない）、同じ状況が複数回発生する場合は、以下のようにファクタリング(要素分解)の手法を適用します。"

#: ../../chapter7.rst:731
msgid ""
"Then instead of defining two variables, such as ``CONDITION`` and ``OLD-"
"CONDITION``, define one double-length variable:"
msgstr "それから ``CONDITION`` と ``OLD-CONDITION`` のように2つの変数を定義する代わりに、1つの2倍長変数を定義します。"

#: ../../chapter7.rst:738
msgid "Use ``BURY`` and ``EXHUME`` to save and restore the original value:"
msgstr "元の値を保存し復元するには、 ``BURY`` と ``EXHUME`` を使います。"

#: ../../chapter7.rst:745
msgid "``BURY`` saves the “old” version of condition at ``CONDITION 2+``."
msgstr "``BURY`` は ``CONDITION 2 +`` で条件の「古い」バージョンを保存します。"

#: ../../chapter7.rst:747
msgid ""
"You still have to be careful. Going back to our ``DUMP`` example, suppose"
" you decided to add the friendly feature of letting the user exit the "
"dump at any time by pressing the “escape” key. So inside the loop you "
"build the test for a key being pressed, and if so execute ``QUIT``. But "
"what happens?"
msgstr ""
"あなたはまだ注意する必要があります。 私たちの ``DUMP`` の例に戻って、あなたが :kbd:`ESC` "
"キーを押すことによっていつでもユーザーにダンプを終了させるという親しみやすい機能を追加することに決めたとしましょう。 "
"それでループの中であなたは押されたキーのテストを構築し、もしそうなら ``QUIT`` を実行します。 しかし、そうすると何が起こるでしょうか？"

#: ../../chapter7.rst:754
msgid ""
"The user starts in decimal, then types ``DUMP``. He exits ``DUMP`` midway"
" through and finds himself, strangely, in hexadecimal."
msgstr ""
"ユーザは基数10進数で始めてから ``DUMP`` とタイプします。 彼が途中で ``DUMP`` "
"終了させると、不思議なことに、基数は16進数になっているではありませんか。"

#: ../../chapter7.rst:758
msgid ""
"In the simple case at hand, the best solution is to not use ``QUIT``, but"
" rather a controlled exit from the loop (via ``LEAVE``, etc.) to the end "
"of the definition where ``BASE`` is reset."
msgstr ""
"当面の単純な場合、最善の解決策は ``QUIT`` ではなく、 定義の末尾の ``BASE`` のリセットを行う場所へ( ``LEAVE`` "
"などを介して)、ループからの制御された終了を使って脱出する事です。"

#: ../../chapter7.rst:763
msgid ""
"In very complex applications a controlled exit is often impractical, yet "
"many variables must somehow be restored to a natural condition."
msgstr "非常に複雑なアプリケーションでは、制御された出口は実際には実用的ではありませんが、それでも多くの変数を何らかの方法で自然な状態に復元する必要があります。"

#: ../../chapter7.rst:782
msgid "**Moore** responds to this example:"
msgstr "**ムーア** はこの例に対して、以下のように言います。"

#: ../../chapter7.rst:767
msgid ""
"You really get tied up in a knot. You're creating problems for yourself. "
"If I want a hex dump I say ``HEX``   ``DUMP``. If I want a decimal dump I"
" say ``DECIMAL``   ``DUMP``. I don't give ``DUMP`` the privilege of "
"messing around with my environment."
msgstr ""
"あなたは自縄自縛に陥っています。あなたは自分自身のせいで問題を引き起こしています。 16進ダンプが欲しいのなら、私は ``HEX DUMP`` "
"と言います。 10進数のダンプが欲しいなら、 ``DECIMAL DUMP`` と言います。 私は ``DUMP`` "
"に自分の環境をいじり回す特権を与えません。"

#: ../../chapter7.rst:772
msgid ""
"There's a philosophical choice between restoring a situation when you "
"finish and establishing the situation when you start. For a long time I "
"felt you should restore the situation when you're finished. And I would "
"try to do that consistently everywhere. But it's hard to define "
"\"everywhere.\" So now I tend to establish the state before I start."
msgstr ""
"あなたが終了したときに状況を回復することとあなたが開始したときに状況を確定することの間に哲学的な選択があります。 "
"長い間、私はあなたが終わったときあなたが状況を回復するべきであると感じました。 そして私はそれをどこでも一貫してやろうとするでしょう。 "
"しかし、「どこでも」を定義するのは困難です。 だから今、私は始める前に状態を確立する傾向があります。"

#: ../../chapter7.rst:778
msgid ""
"If I have a word which cares where things are, it had better set them. If"
" somebody else changes them, they don't have to worry about resetting "
"them."
msgstr ""
"物事がどこにあるかを気にするワードがあれば、それを設定したほうがよいでしょう。 "
"他の誰かがそれらを変更しても、それらをリセットすることを心配する必要はありません。"

#: ../../chapter7.rst:782
msgid "There are more exits than there are entrances."
msgstr "入り口よりも多くの出口の方が多いのです。"

#: ../../chapter7.rst:784
msgid ""
"In cases in which I need to do the resetting before I’m done, I’ve found "
"it useful to have a single word (which I call ``PRISTINE``) to perform "
"this resetting. I invoke ``PRISTINE``:"
msgstr ""
"やり直す前にリセットを実行する必要がある場合は、このリセットを実行するために1つのワード( ``PRISTINE`` "
"と呼びます)があると便利です。 以下のようにして ``PRISTINE`` を起動します。"

#: ../../chapter7.rst:788
msgid "at the normal exit point of the application"
msgstr "アプリケーションの通常の出口で"

#: ../../chapter7.rst:790
msgid "at the point where the user may deliberately exit (just before ``QUIT``)"
msgstr "ユーザが意図的に終了する可能性がある場所( ``QUIT`` の直前）"

#: ../../chapter7.rst:792
msgid "at any point where a fatal error may occur, causing an abort."
msgstr "致命的なエラーが発生してアボートを引き起こす可能性がある場所で"

#: ../../chapter7.rst:794
msgid ""
"Finally, when you encounter this situation of having to save/restore a "
"value, make sure it’s not just a case of bad factoring. For example, "
"suppose we have written:"
msgstr ""
"最後に、値を保存または復元しなければならないというこのような状況に遭遇したときには、それが単なる悪い要素ではないことを確認してください。 "
"たとえば、次のように書いたとします。"

#: ../../chapter7.rst:804
msgid "The current ``GAME`` is either ``LONG`` or ``SHORT``."
msgstr "現在の ``GAME`` は ``LONG`` か ``SHORT`` のどちらかです。"

#: ../../chapter7.rst:806
msgid ""
"Later we decide we need a word to play *any* number of holes. So we "
"invoke ``GAME`` making sure not to clobber the current value of "
"``#HOLES``:"
msgstr ""
"後になって、私たちは任意の数のホール(hole)をプレイするためのワードが必要だと決心しました。 そこで、 ``#HOLES`` "
"の現在の値を上書きしないように ``GAME`` を起動します。"

#: ../../chapter7.rst:813
msgid ""
"Because we needed ``HOLES`` after we’d defined ``GAME``, it seemed to be "
"of greater complexity; we built ``HOLES`` around ``GAME``. But in "
"fact—perhaps you see it already—rethinking is in order:"
msgstr ""
"``GAME`` を定義した後は ``HOLES`` が必要だったので、それはもっと複雑なように思えました。 私たちは ``GAME`` の周りに"
" ``HOLES`` を作りました。 しかし、実際には、おそらくあなたはすでにそれを見ているはずですが、再考するのが正しいのです。"

#: ../../chapter7.rst:822
msgid ""
"We can build ``GAME`` around ``HOLES`` and avoid all this "
"saving/restoring nonsense."
msgstr "私たちは ``HOLES`` の周囲に ``GAME`` を構築し、このような保存/復元のナンセンスをすべて回避することができます。"

#: ../../chapter7.rst:826
msgid "Application Stacks"
msgstr "アプリケーションスタック"

#: ../../chapter7.rst:828
msgid ""
"In the last section we examined some ways to save and restore a single "
"previous value. Some applications require *several* values to be saved "
"and restored. You may often find the best solution to this problem in "
"defining your own stack."
msgstr ""
"前節では、単一の値を保存および復元する方法をいくつか検討しました。 一部のアプリケーションでは、複数値を保存および復元する必要があります。 "
"自分のスタックを定義することで、この問題に対する最善の解決策が見つかることがよくあります。"

#: ../../chapter7.rst:833
msgid ""
"Here is the code for a user stack including very simple error checking "
"(an error clears the stack):"
msgstr "以下は、非常に単純なエラーチェックを含むユーザスタックのコードです(エラー発生時はスタックをクリアする)。"

#: ../../chapter7.rst:845
msgid ""
"The word ``PUSH`` takes a value from off of your data stack and “pushes” "
"it onto this new stack. ``POP`` is the opposite, “popping” a value from "
"off the new stack, and onto Forth’s data stack."
msgstr ""
"``PUSH`` というワード、データスタックから値を取り出し、それをこの新しいスタックに「プッシュ」します。 ``POP`` "
"は反対で、新しいスタックから値をForthのデータスタックに「ポップ」します。"

#: ../../chapter7.rst:849
msgid ""
"In a real application you might want to change the names ``PUSH`` and "
"``POP`` to better match their conceptual purposes."
msgstr "実際のアプリケーションでは、概念的な目的に合うように ``PUSH`` と ``POP`` の名前を変更することをお勧めします。"

#: ../../chapter7.rst:853
msgid "Sharing Components"
msgstr "共有コンポーネント"

#: ../../chapter7.rst:857
msgid ""
"It's legal to use a component for an additional purpose besides its "
"intended one, provided:"
msgstr "以下の条件で、意図した目的以外に追加の目的でコンポーネントを使用することは合法です。"

#: ../../chapter7.rst:860
msgid "All uses of the component are mutually exclusive"
msgstr "このコンポーネントの使用はすべて相互に排他的です。"

#: ../../chapter7.rst:861
msgid ""
"Each interrupting use of the component restores the component to its "
"previous state when finished."
msgstr "コンポーネントの使用を中断するたびに、コンポーネントは終了時の前の状態に復元されます。"

#: ../../chapter7.rst:864
msgid "Otherwise you need an additional component or level of complexity."
msgstr "それ以外の場合は、追加のコンポーネントまたは追加の複雑さのレベルが必要です。"

#: ../../chapter7.rst:866
msgid ""
"We’ve seen a simple example of this principle with the return stack. The "
"return stack is a component of the Forth system designed to hold return "
"addresses, and thereby serve as an indication of where you’ve been and "
"where you’re going. To use the return stack as a holder for temporary "
"values is possible, and in many cases desirable. Problems occur when one "
"of the above restrictions is ignored."
msgstr ""
"私たちは前にリターンスタックを使ったこの原則の簡単な例を見ました。 "
"リターンスタックは、リターンアドレスを保持するように設計されたForthシステムの構成要素であり、それによって、自分がどこにいて、どこに向かっているのかを示すものとして機能します。"
" 戻り値のスタックを一時的な値を保持するものとして使用することは可能であり、多くの場合は望ましいことです。 "
"但し、上記の制限の1つを無視すると問題が発生します。"

#: ../../chapter7.rst:874
msgid ""
"In my text formatter the output can go invisible. This feature has two "
"purposes:"
msgstr "私のテキストフォーマッタでは、出力は見えなくすることができます。 この機能には2つの目的があります。"

#: ../../chapter7.rst:877
msgid "for looking ahead to see whether something will fit, and"
msgstr "何かが合うかどうかを見るために先を見越して、そして"

#: ../../chapter7.rst:879
msgid ""
"for formatting the table of contents (the entire document is formatted "
"and page numbers are calculated without anything actually being "
"displayed)."
msgstr "目次をフォーマットするためのものです（実際には何も表示されずに文書全体がフォーマットされ、ページ番号が計算されます）。"

#: ../../chapter7.rst:883
msgid ""
"It was tempting to think that once having added the ability to make the "
"output invisible, I could use this feature to serve both purposes. "
"Unfortunately, the two purposes are not mutually exclusive."
msgstr ""
"出力を非表示にする機能を追加した後は、この機能を使用して両方の目的を果たすことができると思いがちでした。 "
"残念ながら、この2つの目的は相互に排他的ではありません。"

#: ../../chapter7.rst:887
msgid ""
"Let’s see what would happen if I tried to violate this rule. Imagine that"
" the word ``DISPLAY`` does the output, and it’s smart enough to know "
"whether to be visible or invisible. The words ``VISIBLE`` and "
"``INVISIBLE`` set the state respectively."
msgstr ""
"この規則に違反しようとするとどうなるか見てみましょう。 ``DISPLAY`` "
"というワードが出力を行い、目に見えるか見えないかを判断するのには十分賢いです。 ``VISIBLE`` と ``INVISIBLE`` "
"というワードはそれぞれ状態を設定します。"

#: ../../chapter7.rst:892
msgid ""
"My code for looking ahead will first execute ``INVISIBLE``, then test-"
"format the upcoming text to determine its length, and finally execute "
"``VISIBLE`` to restore things to the normal state."
msgstr ""
"私の、先読みコードは、最初に ``INVISIBLE`` を実行し、次に来るテキストをテストフォーマットしてその長さを決定し、そして最後に "
"``VISIBLE`` を実行して通常の状態に戻します。"

#: ../../chapter7.rst:896
msgid "This works fine."
msgstr "これはうまくいきます。"

#: ../../chapter7.rst:898
msgid ""
"Later I add the table-of-contents feature. First the code executes ``IN-"
"VI-SI-BLE``, then runs through the document determining page numbers "
"etc.; then finally executes ``VISIBLE`` to restore things to normal."
msgstr ""
"後で目次機能を追加します。 最初にコードは ``IN-VI-SI-BLE`` を実行し、それからページ番号などを決定するドキュメントを実行します。"
" それから、最後に ``VISIBLE`` を実行して物事を通常の状態に戻します。"

#: ../../chapter7.rst:903
msgid ""
"The catch? Suppose I’m running a table of contents and I hit one of those"
" places where I look ahead. When I finish looking ahead, I execute "
"``VISIBLE``. Suddenly I start printing the document when I was supposed "
"to be running the table of contents."
msgstr ""
"落とし穴は？目次を実行していて、先を見越している場所の1つにヒットしたとします。 先を見終わったら、 ``VISIBLE`` を実行します。 "
"目次を実行しようとしていたときに、突然文書の印刷を開始しました。"

#: ../../chapter7.rst:908
msgid "The solution? There are several."
msgstr "解決策は？ いくつかあります。"

#: ../../chapter7.rst:910
msgid ""
"One solution views the problem as being that the lookahead code is "
"clobbering the visible/invisible flag, which may have been preset by "
"table-of-contents. Therefore, the lookahead code should be responsible "
"for saving, and later restoring, the flag."
msgstr ""
"１つの解決策は、先読みコードが、目録によって予め設定されている可能性がある可視／不可視フラグを潰していることが問題です。 "
"したがって、先読みコードはフラグを保存し、後で復元する責任があります。"

#: ../../chapter7.rst:915
msgid ""
"Another solution involves keeping two separate variables—one to indicate "
"we’re looking ahead, the other to indicate we’re printing the table of "
"contents. The word ``DISPLAY`` requires that both flags be false in order"
" to actually display anything."
msgstr ""
"もう1つの解決策は、2つの別々の変数を保持することです。1つは先読みを示し、もう1つは目次を印刷していることを示します。 ``DISPLAY`` "
"というワードは実際に何かを表示するために両方のフラグが偽であることを要求します。"

#: ../../chapter7.rst:920
msgid ""
"There are two ways to accomplish the latter approach, depending on how "
"you want to decompose the problem. First, we could nest one condition "
"within the other:"
msgstr ""
"あなたが問題をどのように分解したいかに応じて、後者のアプローチを達成するための2つの方法があります。 "
"まず、以下のように、ある条件を別の条件の中に入れ子にすることができます。"

#: ../../chapter7.rst:933
msgid ""
"``DISPLAY`` checks that we’re not setting the table of contents and "
"invokes ``<DISPLAY>``, which in turn checks that we’re not looking ahead "
"and invokes ``[DISPLAY]``."
msgstr ""
"``DISPLAY`` は、目次を設定していないことを確認してから、 ``<DISPLAY>`` "
"を呼び出します。これにより、先読みしていないことが確認され、 ``[DISPLAY]`` が呼び出されます。"

#: ../../chapter7.rst:937
msgid ""
"In the development cycle, the word ``[DISPLAY]`` that always does the "
"output was originally called ``DISPLAY``. Then a new ``DISPLAY`` was "
"defined to include the lookahead check, and the original definition was "
"renamed ``[DISPLAY]``, thus adding a level of complexity backward without"
" changing any of the code that used ``DISPLAY``."
msgstr ""
"開発段階では、常に出力を行う ``[DISPLAY]`` というワードは、もともとは ``DISPLAY`` と呼ばれていました。 "
"それから、先読みチェックを含むように新しい ``DISPLAY`` が定義され、元の定義は ``[DISPLAY]`` "
"に改名されました。したがって、 ``DISPLAY`` を使用したコードを変更せずに後方レベルの複雑さを追加します。"

#: ../../chapter7.rst:943
msgid ""
"Finally, when the table-of-contents feature was added, a new ``DISPLAY`` "
"was defined to include the table-of-contents check, and the previous "
"``DISPLAY`` was renamed ``<DISPLAY>``."
msgstr ""
"最後に、目次機能が追加されたとき、目次チェックを含むように新しい ``DISPLAY`` が定義され、前の ``DISPLAY`` は "
"``<DISPLAY>`` に改名されました。"

#: ../../chapter7.rst:947
msgid ""
"That’s one approach to the use of two variables. Another is to include "
"both tests within a single word:"
msgstr "これは、2つの変数を使用するための1つの方法です。 もう1つの方法は、以下のように両方のテストを1つのワードに含めることです。"

#: ../../chapter7.rst:954
msgid ""
"But in this particular case, yet another approach can simplify the whole "
"mess. We can use a single variable not as a flag, but as a counter."
msgstr "しかし、この特定のケースでは、さらに別の方法で全体の混乱を単純化できます。 フラグとしてではなく、カウンターとして単一の変数を使用できます。"

#: ../../chapter7.rst:957
msgid "We define:"
msgstr "私たちは以下のように定義します。"

#: ../../chapter7.rst:966
msgid ""
"The lookahead code begins by invoking ``INVISIBLE`` which bumps the "
"counter up one. Non-zero is “true,” so ``DISPLAY`` will not do the "
"output. After the lookahead, the code invokes ``VISIBLE`` which "
"decrements the counter back to zero (“false”)."
msgstr ""
"246/5000\n"
"先読みコードは、カウンタを1つ上げた ``INVISIBLE`` を呼び出すことで始まります。 ゼロ以外は true なので、 "
"``DISPLAY`` は出力を行いません。 先読みの後、コードは ``VISIBLE`` を呼び出してカウンタをゼロ(false)に戻します。"

#: ../../chapter7.rst:971
msgid ""
"The table-of-contents code also begins with ``VISIBLE`` and ends with "
"``IN-VI-SI-BLE``. If we’re running the table of contents while we come "
"upon a lookahead, the second invocation of ``VISIBLE`` raises the counter"
" to two."
msgstr ""
"目次コードも ``VISIBLE`` で始まり ``IN-VI-SI-BLE`` で終わります。 先読みしている間に目次を実行していると、2回目の"
" ``VISIBLE`` の呼び出しでカウンタが2になります。"

#: ../../chapter7.rst:976
msgid ""
"The subsequent invocation of ``INVISIBLE`` decrements the counter to one,"
" so we’re still invisible, and will remain invisible until the table of "
"contents has been run."
msgstr "その後の ``INVISIBLE`` の呼び出しでカウンタが1つ減ります。まだ見えないので、目次が実行されるまで見えません。"

#: ../../chapter7.rst:980
msgid ""
"(Note that we must substitute ``0=`` for ``NOT``. The ’83 Standard has "
"changed ``NOT`` to mean one’s complement, so that ``1 NOT`` yields true. "
"By the way, I think this was a mistake.)"
msgstr ""
"( `'NOT=`` の代わりに ``0=`` を代入しなければならないことに注意してください。FORTH-83規格では、 "
"1の補数を意味するように NOTが変更されました。 私はこれは間違いだと思います。）"

# 意味不明
#: ../../chapter7.rst:986
msgid ""
"This use of a counter may be dangerous, however. It requires parity of "
"command usage: two ``VISIBLE``\\ s yields invisible. That is, unless "
"``VISIBLE`` clips the counter:"
msgstr ""
"ただし、このカウンターの使用は危険な場合があります。 それはコマンド使用の同等性を必要とします。つまり、``VISIBLE`` "
"がカウンターを刻まない限り、2つの ``VISIBLE`` を隠してしまいます。"

#: ../../chapter7.rst:995
msgid "The State Table"
msgstr "状態表"

#: ../../chapter7.rst:997
msgid ""
"A single variable can express a single condition, either a flag, a value,"
" or the address of a function."
msgstr "単一の変数は、フラグ、値、または関数のアドレスのいずれかの単一の条件を表すことができます。"

#: ../../chapter7.rst:1000
msgid ""
"A collection of conditions together represent the *state* of the "
"application or of a particular component [slater83]_. Some applications "
"require the ability to save a current state, then later restore it, or "
"perhaps to have a number of alternating states."
msgstr ""
"条件の集まりは、アプリケーションまたは特定のコンポーネントの状態を表します。 [slater83]_ "
"一部のアプリケーションでは、現在の状態を保存してから後で復元する機能、または複数の状態を交互に表示する機能が必要になります。"

#: ../../chapter7.rst:1007
msgid ""
"When the application requires handling a group of conditions "
"simultaneously, use a state table, not separate variables."
msgstr "アプリケーションが条件のグループを同時に処理する必要がある場合は、変数を分離せずに状態表を使用してください。"

#: ../../chapter7.rst:1010
msgid ""
"The simple case requires saving and restoring a state. Suppose we "
"initially have six variables representing the state of a particular "
"component, as shown in :numref:`fig7-2`."
msgstr ""
"単純な場合としては、状態を保存して復元する必要があります。 :numref:`fig7-2` "
"に示すように、最初に特定のコンポーネントの状態を表す6つの変数があるとします。"

#: ../../chapter7.rst:1014
msgid "A collection of related variables."
msgstr "関連する変数のコレクション"

#: ../../chapter7.rst:1025
msgid ""
"Now suppose that we need to save all of them, so that further processing "
"can take place, and later restore all of them. We could define:"
msgstr "ここで、それらすべてを保存する必要があるとします。保存後、さらに何かしら処理が行われ、後でそれらすべてが復元されます。 以下のように定義できます。"

#: ../../chapter7.rst:1036
msgid ""
"thereby saving all the values on the stack until it’s time to restore "
"them. Or, we might define alternate variables for each of the variables "
"above, in which to save each value separately."
msgstr ""
"それにより、それらが復元される時までスタック上のすべての値を保存します。 "
"または、上記の各変数に対して、各値を個別に保存するための代替変数を定義することもできます。"

#: ../../chapter7.rst:1040
msgid ""
"But a preferred technique involves creating a table, with each element of"
" the table referred to by name. Then creating a second table of the same "
"length. As you can see in :numref:`fig7-3`, we can save the state by "
"copying the table, called ``POINTERS,`` into the second table, called "
"``SAVED``."
msgstr ""
"しかし、推奨される手法では、表の各要素を名前で参照して表を作成します。 次に、同じ長さの2番目の表を作成します。 :numref:`fig7-3`"
" に見られるように、 ``POINTERS`` と呼ばれる表を ``SAVED`` "
"と呼ばれる2番目の表にコピーすることで状態を保存することができます。"

#: ../../chapter7.rst:1050
msgid "Conceptual model for saving a state table."
msgstr "状態表を保存するための概念モデル。"

#: ../../chapter7.rst:1052
msgid "We’ve implemented this approach with the code in :numref:`fig7-4`."
msgstr "このアプローチは  :numref:`fig7-4` のコードで実装しました。"

#: ../../chapter7.rst:1054
msgid "Implementation of save/restorable state table."
msgstr "保存＆復元可能状態表の実装"

#: ../../chapter7.rst:1075
msgid ""
"Notice in this implementation that the names of the pointers, ``TOP``, "
"``BOTTOM``, etc., always return the same address. There is only one "
"location used to represent the current value of any state at any time."
msgstr ""
"この実装では、ポインタの名前、 ``TOP`` 、 ``BOTTOM`` などは常に同じアドレスを返すことに注意してください。 "
"状態の現在値を表すために使用される場所はいつでも1つだけです。"

#: ../../chapter7.rst:1079
msgid ""
"Also notice that we define ``POINTERS`` (the name of the table) with "
"``CON-STANT``, not with ``CREATE``, using a dummy value of zero. This is "
"because we refer to ``POINTERS`` in the defining word ``POSITION``, but "
"it’s not until after we’ve defined all the field names that we know how "
"big the table must be and can actually ``ALLOT`` it."
msgstr ""
"また、 ``CREATE`` ではなく ``CONSTANT`` でダミーのゼロを使って ``POINTERS`` "
"(表の名前)を定義していることにも注意してください。 これは、定義ワード ``POSITION`` で ``POINTERS`` "
"を参照しているためですが、すべてのフィールド名を定義した後で初めて、表がどれだけの大きさでなければならないかを知ることができます。"

#: ../../chapter7.rst:1085
msgid ""
"As soon as we create the field names, we define the size of the table as "
"a constant ``/POINTERS``. At last we reserve room for the table itself, "
"patching its beginning address (``HERE``) into the constant ``POINTERS``."
" (The word ``>BODY`` converts the address returned by tick into the "
"address of the constant’s value.) Thus ``POINTERS`` returns the address "
"of the table allotted later, just as a name defined by ``CREATE`` returns"
" the address of a table allotted directly below the name’s header."
msgstr ""
"私たちはフィールド名を作成したらすぐに、表のサイズを定数 ``/POINTERS`` として定義します。 "
"私たちは終に表自身のためのスペースを確保したので、その先頭アドレス( ``HERE`` ）を定数 ``POINTERS`` にパッチします( "
"``>BODY`` というワードは、ティック( ``'`` )によって返されたアドレスを定数の値のアドレスに変換します)。したがって "
"``POINTERS`` は、 ``CREATE`` で定義された名前のように、後で割り当てられた表のアドレスを返します。 "
"名前のヘッダーのすぐ下に割り当てられている表のアドレスを返します。"

#: ../../chapter7.rst:1094
msgid ""
"Although it’s valid to patch the value of a ``CONSTANT`` at compile time,"
" as we do here, there is a restriction of style:"
msgstr "ここで行っているように、コンパイル時に ``CONSTANT`` の値にパッチを当てることは有効ですが、スタイルの制限があります。"

#: ../../chapter7.rst:1099
msgid ""
"A ``CONSTANT``\\ s value should never be changed once the application is "
"compiled."
msgstr "アプリケーションがコンパイルされたら、 ``CONSTANT`` の値を変更しないでください。"

#: ../../chapter7.rst:1102
msgid ""
"The case of alternating states is slightly more involved. In this "
"situation we need to alternate back and forth between two (or more) "
"states, never clobbering the conditions in each state when we jump to the"
" other state. :numref:`fig7-5` shows the conceptual model for this kind "
"of state table."
msgstr ""
"交互の状態の場合はもう少し複雑です。 "
"このような状況では、2つ（またはそれ以上）の状態を交互に切り替える必要があります。他の状態にジャンプしたときに、各状態の条件を変更することは決してありません。"
" :numref:`fig7-5` はこの種の状態表の概念モデルを示しています。"

#: ../../chapter7.rst:1112
msgid "Conceptual model for alternating-states tables."
msgstr "交互状態表の概念モデル"

#: ../../chapter7.rst:1114
msgid ""
"In this model, the names ``TOP``, ``BOTTOM``, etc., can be made to point "
"into either of two tables, ``REAL`` or ``PSEUDO``. By making the ``REAL``"
" table the current one, all the pointer names reference addresses in the "
"``REAL`` table; by making the ``PSEUDO`` table current, they address the "
"``PSEUDO`` table."
msgstr ""
"このモデルでは、 ``TOP`` 、 ``BOTTOM`` などの名前を、 ``REAL`` または ``PSEUDO`` "
"の2つの表のいずれかを指すようにすることができます。 ``REAL`` 表を現在の表にすることで、すべてのポインタ名は ``REAL`` "
"表のアドレスを参照します。 ``PSEUDO`` 表を最新にすることで、 ``PSEUDO`` 表をアドレス指定します。"

#: ../../chapter7.rst:1120
msgid ""
"The code in :numref:`fig7-6` implements this alternating states "
"mechanism. The words ``WORKING`` and ``PRETENDING`` change the pointer "
"appropriately. For instance:"
msgstr ""
":numref:`fig7-6` のコードはこの交互状態メカニズムを実装しています。 ``WORKING`` と ``PRETENDING`` "
"というワードはポインタを適切に変更します。例えば以下の通り。"

#: ../../chapter7.rst:1124
msgid "Implementation of alternating-states mechanism."
msgstr "交互状態メカニズムの実装"

#: ../../chapter7.rst:1158
msgid ""
"The major difference with this latter approach is that names go through "
"an extra level of indirection (``POINTERS`` has been changed from a "
"constant to a colon definition). The field names can be made to point to "
"either of two state tables. Thus each name has slightly more work to do. "
"Also, in the former approach the names refer to fixed locations; a "
"``CMOVE`` is required each time we save or restore the values. In this "
"approach, we have only to change a single pointer to change the current "
"table."
msgstr ""
"後者のアプローチとの大きな違いは、名前が余分なレベルの間接参照を通過することです( ``POINTERS`` "
"は定数からコロン定義に変更されました)。 フィールド名は、2つの状態表のいずれかを指すようにすることができます。 "
"したがって、それぞれの名前にはもう少し作業が必要です。 また、前者のアプローチでは、名前は固定位置を指します。 値を保存または復元するたびに "
"``CMOVE`` が必要です。このアプローチでは、現在の表を変更するために1つのポインタを変更するだけです。"

#: ../../chapter7.rst:1168
msgid "Vectored Execution"
msgstr "ベクトル化実行"

#: ../../chapter7.rst:1170
msgid ""
"Vectored execution extends the ideas of currentness and indirection "
"beyond data, to functions. Just as we can save values and flags in "
"variables, we can also save functions, because functions can be referred "
"to by address."
msgstr ""
"ベクトル化実行は、データを超えた直接性と間接性の概念を機能にまで拡張します。 "
"値やフラグを変数に保存できるのと同じように、機能はアドレスで参照できるため、機能を保存することもできます。"

#: ../../chapter7.rst:1175
msgid ""
"The traditional techniques for implementing vectored execution are "
"described in *Starting Forth*, Chapter Nine. In this section we’ll "
"discuss a new syntax which I invented and which I think can be used in "
"many circumstances more elegantly than the traditional methods."
msgstr ""
"ベクトル化された実行を実装するための伝統的なテクニックは *Starting Forth*,Chapter Nine(邦訳:FORTH入門 "
"第9章)で説明されています。 "
"この節は、私が開発した新しい構文について説明します。これは、従来の方法よりもエレガントにさまざまな状況で使用できると思います。"

#: ../../chapter7.rst:1180
msgid ""
"The syntax is called ``DOER/MAKE``. (If your system doesn’t include these"
" words, refer to :doc:`Appendix B<appendixb>` for code and implementation"
" details.) It works like this: You define the word whose behavior will be"
" vectorable with the defining word ``DOER``, as in"
msgstr ""
"その構文は ``DOER/MAKE`` と呼ばれます(システムにこれらのワードが含まれていない場合、コードと実装の詳細については "
":doc:`付録B<appendixb>` 参照)。それは以下のように、動作をベクトル化可能なワード ``DOER`` で定義できます。"

#: ../../chapter7.rst:1190
msgid ""
"Initially, the new word ``PLATFORM`` does nothing. Then you can write "
"words that change what ``PLATFORM`` does by using the word ``MAKE``:"
msgstr ""
"最初は、 ``PLATFORM`` という新しいワードは何もしません。 その後、 ``MAKE`` というワードを使って、 "
"``PLATFORM`` の動作を変更するワードを書くことができます。"

#: ../../chapter7.rst:1198
msgid ""
"When you invoke ``LEFTWING``, the phrase ``MAKE PLATFORM`` changes what "
"``PLATFORM`` will do. Now if you type ``PLATFORM``, you’ll see:"
msgstr ""
"``LEFTWING`` を起動すると、 ``MAKE PLATFORM`` というフレーズは ``PLATFORM`` の動作を変更します。 "
"``PLATFORM`` と入力すると、次のようになります。"

# PLATFORM 討論の場、演壇
# proponent  提唱者・味方
# opponet 対談者・敵方
#: ../../chapter7.rst:1206
msgid ""
"``RIGHTWING`` will make ``PLATFORM`` display “opponent.” You can use "
"``PLATFORM`` within another definition:"
msgstr ""
"``RIGHTWING`` は ``PLATFORM`` に「opponent.」を表示させます。他の定義の中で ``PLATFORM`` "
"を使うことができます。"

# SLOGAN スローガン
#: ../../chapter7.rst:1214
msgid "The statement"
msgstr "その声明"

#: ../../chapter7.rst:1220
msgid "will display one campaign statement, while"
msgstr "キャンペーン声明を1つ表示します。"

#: ../../chapter7.rst:1226
msgid "will display another."
msgstr "もう一方の表示。"

#: ../../chapter7.rst:1228
msgid ""
"The ``MAKE`` code can be any Forth code, as much or as long as you want; "
"just remember to conclude it with semicolon. The semicolon at the end of "
"``LEFTWING`` serves for both ``LEFTWING`` and for the bit of code after "
"``MAKE``. When ``MAKE`` redirects execution of the ``DOER`` word, it also"
" *stops* execution of the word in which it appears."
msgstr ""
"``MAKE``コードは、任意のForthコードで、あなたが望むだけの長さで書くことが出来ます。但しそれをセミコロンで終わらせることを忘れないでください。"
" ``LEFTWING`` の末尾のセミコロンは、``LEFTWING`` と、 ``MAKE`` の後のコードの、両方に使用されます。 "
"``MAKE`` が ``DOER`` ワードの実行をリダイレクトすると、それを記述したワードの実行も「停止」します。"

#: ../../chapter7.rst:1234
msgid ""
"When you invoke ``LEFTWING``, for example, ``MAKE`` redirects "
"``PLATFORM`` and exits. Invoking ``LEFTWING`` does not cause “proponent” "
"to be printed. :numref:`fig7-7`  demonstrates this point, using a "
"conceptualized illustration of the dictionary."
msgstr ""
"たとえば、``LEFTWING`` を起動すると、``MAKE`` は ``PLATFORM`` をリダイレクトして終了します。 "
"``LEFTWING`` を起動しても「proponent」は表示されません。  :numref:`fig7-7` "
"は辞書の概念図を使ってこの点を説明しています。"

#: ../../chapter7.rst:1243
msgid "``DOER`` and ``MAKE``."
msgstr "``DOER`` と ``MAKE``"

#: ../../chapter7.rst:1245
msgid ""
"If you want to *continue* execution, you can use the word ``;AND`` in "
"place of semicolon. ``;AND`` terminates the code that the ``DOER`` word "
"points to, and resumes execution of the definition in which it appears, "
"as you can see in :numref:`fig7-8` ."
msgstr ""
"実行を継続したい場合は、セミコロンの代わりにワード ``;AND`` を使用できます。 ``;AND`` は  :numref:`fig7-8` "
"にあるように、 ``DOER`` ワードが指すコードを終了させ、それが現れる定義の実行を再開します。"

#: ../../chapter7.rst:1255
msgid "Multiple ``MAKE``\\ s in parallel using ``;AND``."
msgstr "``;AND`` を使って複数の ``MAKE`` を並列に実行"

#: ../../chapter7.rst:1257
msgid ""
"Finally, you can chain the “making” of ``DOER`` words in series by not "
"using ``;AND``. :numref:`fig7-9`  explains this better than I could write"
" about it."
msgstr ""
"最後に、 ``;AND`` を使わないことで、 ``DOER`` のワードの「メイキング」を連鎖させることができます。 "
":numref:`fig7-9` は、私が説明を書くよりもよりも上手く図示示しています。"

#: ../../chapter7.rst:1265
msgid "Multiple ``MAKE``\\ s in series."
msgstr "複数の ``MAKE`` の連なり"

#: ../../chapter7.rst:1268
msgid "Using DOER/MAKE"
msgstr "DOER/MAKEの使用"

#: ../../chapter7.rst:1270
msgid ""
"There are many occasions when the ``DOER/MAKE`` construct proves "
"beneficial. They are:"
msgstr "``DOER/MAKE`` 組み立てが有益であることが証明される機会はたくさんあります。"

#: ../../chapter7.rst:1273
msgid ""
"To change the state of a function (when external testing of the state is "
"not necessary). The words ``LEFTWING`` and ``RIGHTWING`` change the state"
" of the word ``PLATFORM``."
msgstr ""
"機能の状態を変更する(状態の外部テストが不要な場合)。 ``LEFTWING`` と ``RIGHTWING`` というワードは、 "
"``PLATFORM`` というワードの状態を変更します。"

#: ../../chapter7.rst:1277
msgid ""
"To factor out internal phrases from similar definitions, but within "
"control structures such as loops."
msgstr "内部フレーズを類似の定義から括り出します。しかし、それはループなどの制御構造の中に入っています。"

#: ../../chapter7.rst:1280
msgid ""
"Consider the definition of a word called ``DUMP``, designed to reveal the"
" contents of a specified region of memory."
msgstr "指定されたメモリ領域の内容を表示するように設計された ``DUMP`` と呼ばれるワードの定義を考えてください。"

#: ../../chapter7.rst:1293
msgid ""
"The problem arises when you write a definition called ``CDUMP``, designed"
" to format the output according to bytes, not cells:"
msgstr "この問題は、セルではなくバイト数に従って出力をフォーマットするように設計された ``CDUMP`` と呼ばれる定義を書くときに起こります。"

#: ../../chapter7.rst:1306
msgid ""
"The code within these two definitions is identical except for the "
"fragments in boldface. But factoring is difficult because the fragments "
"occur inside the    ``DO``  ``LOOP``."
msgstr ""
"これら2つの定義内のコードは、3行目を除いて同一です。 しかし、ここは ``DO…LOOP`` "
"の内部にあるため、ファクタリング(要素分解)は困難です。"

#: ../../chapter7.rst:1310
msgid ""
"Here’s a solution to this problem, using ``DOER/MAKE``. The code that "
"changes has been replaced with the word ``.UNIT``, whose behavior is "
"vectored by the code in ``DUMP`` and ``CDUMP``. (Recognize that “``1``  "
"``+LOOP``” has the same effect as “``LOOP``”.)"
msgstr ""
"以下はこの問題に対する解決策です。 ``DOER/MAKE`` を使ってください。 変更されたコードはワード ``.UNIT`` "
"に置き換えられました。その動作は ``DUMP`` と ``CDUMP`` のコードによって管理されています( ``1 +LOOP`` は "
"``LOOP`` と同じ効果があります)。"

#: ../../chapter7.rst:1324
msgid ""
"Notice how ``DUMP`` and ``CDUMP`` *set-up* the vector, then go on to "
"*execute* the shell (the word ``<DUMP>``)."
msgstr "``DUMP`` と ``CDUMP`` がベクトルを設定します。それから、実行シェル(ワード ``<DUMP>``)へ進みます。"

#: ../../chapter7.rst:1327
msgid ""
"To change the state of related functions by invoking a single command. "
"For instance:"
msgstr "単一のコマンドを呼び出して関連機能の状態を変更すること。 たとえば以下のように。"

#: ../../chapter7.rst:1345
msgid ""
"Here we’ve defined a vectorable set of output words, each name having a "
"“prime” mark at the end. ``VISIBLE`` sets them to their expected "
"functions. ``INVISIBLE`` makes them no-ops, eating up the arguments that "
"would normally be passed to them. Say ``INVISIBLE`` and any words defined"
" in terms of these four output operators will *not* produce any output."
msgstr ""
"ここでは、各ワードの末尾に「プライム( ``'`` )」マークが付いた、わかりやすい一連の出力ワードを定義しました。 ``VISIBLE`` "
"はそれらを期待される機能に設定します。 ``INVISIBLE`` はそれらを「何もしない(no-"
"op)」に設定し、通常それらに渡される引数を単に食い尽くします。「 ``INVISIBLE`` "
"」と言うと、これら4つの出力操作ワードに対して定義されたワードは出力を生成しません。"

#: ../../chapter7.rst:1352
msgid ""
"To change the state for the next occurrence only, then change the state "
"(or reset it) again."
msgstr "次回の発生時のみ状態を変更するには、再度状態を変更（またはリセット）します。"

#: ../../chapter7.rst:1355
msgid ""
"Suppose we’re writing an adventure game. When the player first arrives at"
" a particular room, the game will display a detailed description. If the "
"player returns to the same room later, the game will show a shorter "
"message."
msgstr ""
"アドベンチャーゲームを書いているとしましょう。 プレイヤーが最初に特定の部屋に到着すると、ゲームは詳細な説明を表示します。 "
"後でプレイヤーが同じ部屋に戻った場合、ゲームは短いメッセージを表示します。"

#: ../../chapter7.rst:1360
msgid "We write:"
msgstr "私たちは以下のように書きます。"

#: ../../chapter7.rst:1371
msgid ""
"The word ``ANNOUNCE`` will display either message. First we say ``LONG``,"
" to initialize ``ANNOUNCE`` to the long message. Now we can test "
"``ANNOUNCE``, and find that it prints the long message. Having done that,"
" however, it continues to “make” ``ANNOUNCE`` display the short message."
msgstr ""
"ワード  ``ANNOUNCE`` はいずれかのメッセージを表示します。最初に私たちは長いメッセージで ``ANNOUNCE`` "
"を初期化するために ``LONG`` と言います。今や私たちは ``ANNOUNCE`` "
"をテストする事ができ、それは長いメッセージを表示します。その後、続けて、短いメッセージを表示する処理で ``ANNOUNCE`` を書き換えます。"

#: ../../chapter7.rst:1376
msgid ""
"If we test ``ANNOUNCE`` a second time, it prints the short message. And "
"it will for ever more, until we say ``LONG`` again."
msgstr ""
"私たちがもう一度 ``ANNOUNCE`` をテストすると、短いメッセージが表示されます。 そして ``LONG`` "
"と再び言うまでは、それは短いメッセージの表示のままです。"

#: ../../chapter7.rst:1379
msgid ""
"In effect we’re queuing behaviors. We can queue any number of behaviors, "
"letting each one set the next. The following example (though not terribly"
" practical) illustrates the point."
msgstr ""
"事実上、私たちは行動を待ち行列に入れています。 各動作に次の動作を設定させて、動作をいくつでもキューに入れることができます。 "
"次の例は(あんまり実用的ではありませんが)この動作を表しています。"

#: ../../chapter7.rst:1400
msgid ""
"In this code we’ve created a list of variables, then defined an ``ORDER``"
" in which they are to be searched. The word ``HUNT`` looks through each "
"of them, looking for the first one that contains a 17. ``HUNT`` returns "
"either the address of the correct variable, or a zero if none have the "
"value."
msgstr ""
"このコードでは変数のリストを作成し、それからそれらが検索されることになる ``ORDER`` を定義しました。 ワード ``HUNT`` "
"はそれぞれを見て、17を含む最初のものを探します。 ``HUNT`` は正しい変数のアドレスを返します。値がない場合はゼロを返します。"

#: ../../chapter7.rst:1406
msgid ""
"It does this by simply executing ``WHERE`` five times. Each time, "
"``WHERE`` returns a different address, as defined in ``ORDER``, then "
"finally zero."
msgstr ""
"これは単に ``WHERE`` を5回実行することによって行われます。 毎回、 ``WHERE`` は ``ORDER`` "
"で定義されているように異なるアドレスを返し、最後にゼロを返します。"

#: ../../chapter7.rst:1409
msgid ""
"We can even define a ``DOER`` word that toggles its own behavior "
"endlessly:"
msgstr "それ自身の振る舞いを際限なくON/OFFする ``DOER`` というワードを定義することさえできます。"

#: ../../chapter7.rst:1420
msgid ""
"To implement a forward reference. A forward reference is usually needed "
"as a “hook,” that is, a word invoked in a low-level definition but "
"reserved for use by a component defined later in the listing."
msgstr ""
"前方参照を実装します。 "
"通常、前方参照は「フック(hook)」、つまり低レベルの定義で呼び出され、リストの後半で定義されているコンポーネントで使用するために予約されているワードとして必要です。"

#: ../../chapter7.rst:1424
msgid ""
"To implement a forward reference, build the header of the word with "
"``DOER``, before invoking its name."
msgstr "前方参照を実装するには、その名前を呼び出す前に、ワードのヘッダを ``DOER`` で構築します。"

#: ../../chapter7.rst:1431
msgid "Later in the listing, use ``MAKE``;"
msgstr "リストの後半で ``MAKE`` を使います。"

#: ../../chapter7.rst:1437
msgid "(Remember, ``MAKE`` can be used outside a colon definition.)"
msgstr "(覚えておいてください、 ``MAKE`` はコロン定義の外で使うことができます。)"

#: ../../chapter7.rst:1439
msgid "Recursion, direct or indirect."
msgstr "直接的または間接的な再帰"

#: ../../chapter7.rst:1441
msgid ""
"Direct recursion occurs when a word invokes itself. A good example is the"
" recursive definition of greatest-common-denominator:"
msgstr "ワードが自分自身を呼び出すときに直接再帰が発生します。 良い例は、以下のような最大公約数的再帰定義です。"

#: ../../chapter7.rst:1449
msgid "This translates nicely into:"
msgstr "これは以下のように素敵に変換できます。"

#: ../../chapter7.rst:1456
msgid ""
"Indirect recursion occurs when one word invokes a second word, while the "
"second word invokes the first. This can be done using the form:"
msgstr "間接再帰は、あるワードが別のワードを呼び出すときに発生し、2番目のワードが最初のワードを呼び出すときに発生します。 これは以下の形式で行えます。"

#: ../../chapter7.rst:1465
msgid "Debugging. I often define:"
msgstr "デバッグの為に、私はしばしば以下の定義をします。"

#: ../../chapter7.rst:1471
msgid ""
"(short for ``SNAPSHOT``), then edit ``SNAP`` into my application at a "
"point where I want to see what’s going on. For instance, with ``SNAP`` "
"invoked inside the main loop of a keystroke interpreter, I can set it up "
"to let me watch what’s happening to a data structure as I enter keys. And"
" I can change what SNAP does without having to recompile the loop."
msgstr ""
"( ``SNAPSHOT`` の略)それから、何が起こっているのか見たいところで ``SNAP`` を私のアプリケーションに編集してください。 "
"たとえば、キーストロークインタプリタのメインループ内で ``SNAP`` "
"を呼び出すと、キーを入力したときにデータ構造に何が起きているのかを確認できるように設定できます。 "
"そして、ループを再コンパイルしなくても、SNAPの動作を変更できます。"

#: ../../chapter7.rst:1479
msgid ""
"The situations in which it’s preferable to use the tick-and-execute "
"approach are those in which you need control over the address of the "
"vector, such as when vectoring through an element in a decision table, or"
" attempting to save/restore the contents of the vector."
msgstr ""
"tick-and-"
"executeアプローチを使用するのが望ましい状況は、決定表の要素を介してベクトル化するとき、またはその内容を保存/復元しようとするときなど、ベクトルのアドレスを制御する必要がある場合です。"

#: ../../chapter7.rst:1485
msgid "Summary"
msgstr "要約"

#: ../../chapter7.rst:1487
msgid ""
"In this chapter we’ve examined the tradeoffs between using the stack and "
"using variables and other data structures. Using the stack is preferable "
"for testing and reusability, but too many values manipulated on the stack"
" by a single definition hurts readability and writeability."
msgstr ""
"この章では、スタックを使用することと、変数や他のデータ構造を使用することとの間のトレードオフを調べました。 "
"テストと再利用のためにはスタックを使用することをお勧めしますが、単一の定義によってスタック上で操作される値が多すぎると、読みやすさと書き込み性が低下します。"

#: ../../chapter7.rst:1492
msgid ""
"We also explored techniques for saving and restoring data structures, and"
" concluded with a study of vectored execution using ``DOER/MAKE``."
msgstr "また、データ構造を保存したり復元したりするためのテクニックも調べ、 ``DOER/MAKE`` を使ったベクトル実行の研究で締めくくりました。"

#: ../../chapter7.rst:1497
msgid "REFERNCES"
msgstr "参考文献"

#: ../../chapter7.rst:1499
msgid ""
"Michael Ham, \"Why Novices Use So Many Variables,\"    **Forth "
"Dimensions** , vol. 5, no. 4, November/December 1983."
msgstr ""
"Michael Ham, \"Why Novices Use So Many Variables,\" **Forth Dimensions** "
", vol. 5, no. 4, November/December 1983."

#: ../../chapter7.rst:1500
msgid ""
"Daniel Slater, \"A State Space Approach to   Robotics,\"  **The Journal "
"of Forth Application and Research** ,   1, 1 (September 1983), 17."
msgstr ""
"Daniel Slater, \"A State Space Approach to Robotics,\"  **The Journal of "
"Forth Application and Research** ,   1, 1 (September 1983), 17."

