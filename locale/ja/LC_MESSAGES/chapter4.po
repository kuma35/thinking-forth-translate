# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Leo Brodie
# This file is distributed under the same license as the Thinking Forth
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Thinking Forth 0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-29 05:55+0900\n"
"PO-Revision-Date: 2019-08-05 04:49+0900\n"
"Last-Translator: kuma35\n"
"Language: ja_JP\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../chapter4.rst:4
msgid "4. Detailed Design/Problem Solving"
msgstr "第４章 詳細設計と問題解決"

#: ../../chapter4.rst
msgid ""
"**Trivial:** I can see how to do this. I just don't know how long it will"
" take."
msgstr "**些細なこと** これをどうすればいいかはわかる。どのくらいの期間かかるか全くわからない。"

#: ../../chapter4.rst
msgid "**Non-trivial:** I haven't a **clue** how to do this!"
msgstr "**重大なこと** どうすりゃいいのか手がかりが無い。"

#: ../../chapter4.rst
msgid "\\-\\-\\- *Operating philosophy developed at the Laboratory*"
msgstr "― 研究所で開発された運営哲学"

#: ../../chapter4.rst
msgid "*Automation and Instrumentation Design Group,*"
msgstr "ヴァージニア工科大学化学部"

#: ../../chapter4.rst
msgid "*Chemistry Dept., Virginia Polytechnic Institute and State University*"
msgstr "自動化・計測設計グループ"

#: ../../chapter4.rst:12
msgid ""
"Once you’ve decided upon the components in your application, your next "
"step is to design those components. In this chapter we’ll apply problem-"
"solving techniques to the detailed design of a Forth application. This is"
" the time for pure invention, the part that many of us find the most fun."
" There’s a special satisfaction in going to the mat with a non-trivial "
"problem and coming out the victor."
msgstr "アプリケーションのコンポーネントを決定したら、次のステップはそれらのコンポーネントを設計することです。 この章では、問題解決の手法をForthアプリケーションの詳細設計に適用します。 これは純粋な発明のためのひとときです。私たちの多くが最も楽しいと思う部分です。 明白でない問題のもつれに立ち向かい、勝利した人には特別な満足感があります。"

#: ../../chapter4.rst:19
msgid ""
"In English it’s difficult to separate an idea from the words used to "
"express the idea. In writing a Forth application it’s difficult to "
"separate the detailed design phase from implementation, because we tend "
"to design in Forth. For this reason, we’ll get a bit ahead of ourselves "
"in this chapter by not only presenting a problem but also designing a "
"solution to it, right on through to the coded implementation."
msgstr ""
"文章では、アイデアを表現するために使用される単語からアイデアを分離することは困難です。 "
"Forthアプリケーションを書く際には、詳細な設計段階を実装から切り離すことは困難です。なぜなら、私たちはForthで設計する傾向があるからです。"
" このため、この章では、問題を提示するだけでなく、それに対する解決策を設計することによって、コード化された実装に至るまで、少しずつ歩んでいきます。"

#: ../../chapter4.rst:27
msgid "Problem-Solving Techniques"
msgstr "問題解決技法"

#: ../../chapter4.rst:29
msgid ""
"Even neophytes can solve programming problems without devoting any "
"conscious thought to problem solving techniques. So what’s the point in "
"studying techniques of problem solving? To quicken the process. By "
"thinking about the *ways* in which we solve problems, apart from the "
"problems themselves, we enrich our subconscious storehouse of techniques."
msgstr "問題解決技法に意識的な思考を注がなくても、初心者でも、プログラミングの問題を解決はできます。 では、問題解決技法を学習するメリットとは何でしょうか？それは問題解決の速度を上げられることです。 問題自体とは別に、問題を解決するための「方法」を考えることによって、私たちは自分の技法の引き出しを増やします。"

# いかにして問題をとくか
# 原書名     How to Solve It: A New Aspect of Mathematical Method
# 著者名     柿内　賢信 訳
# 発行元     丸善出版
# 発行年月日   1975年04月
# 判型      B6　182×128
# ページ数    266ページ
# ISBN    978-4-621-04593-0
#: ../../chapter4.rst:36
msgid ""
"G\\. Polya has written several books on problem solving, especially of "
"the mathematical problem. The most accessible of these is *How to Solve "
"It* [polya]_ . Although solving a mathematical problem isn’t quite the "
"same as solving a software problem, you’ll find some valuable suggestions"
" there."
msgstr ""
"ジョージ・ポリアは、問題解決、特に数学的問題に関する本をいくつか書いています。 これらのうち最も入手しやすいのは「How to Solve It」"
" [polya]_ です(邦題：いかにして問題をとくか 丸善出版 1975年4月)。 "
"数学的な問題を解くことは、ソフトウェアの問題を解くこととまったく同じではありませんが、そこにはいくつかの有益な提案があります。"

#: ../../chapter4.rst:42
msgid ""
"The following series of tips summarize several techniques recommended by "
"the science of problem solving:"
msgstr "次の一連のヒントは、問題解決の科学で推奨されているいくつかの手法をまとめたものです。"

#: ../../chapter4.rst:47
msgid "Determine your goal."
msgstr "目標を決める。"

#: ../../chapter4.rst:49
msgid ""
"Know what you’re trying to accomplish. As we saw in :doc:`Chapter "
"Two<chapter2>`, this step can be detailed further:"
msgstr ""
"あなたが達成しようとしていることを知ろうとする。あなたが :doc:`第２章<chapter2>` "
"で見たように、このステップはさらに詳細になります。"

#: ../../chapter4.rst:53
msgid ""
"Determine the data interfaces: Know what data will be required to "
"accomplish the goal, and make sure those data are available (input). Know"
" what data the function is expected to produce (output). For a single "
"definition, this means writing the stack-effect comment."
msgstr ""
"データインターフェースを決定します。目標を達成するためにどのデータが必要かを知り、それらのデータが利用可能であることを確認します（入力）。 "
"その機能がどのデータを生成（出力）することを期待されているかを知る。 単一の定義では、これはスタック効果のコメントを書くことを意味します。"

#: ../../chapter4.rst:59
msgid ""
"Determine the rules; review all the facts that you know. In :doc:`Chapter"
" Two<chapter2>` we described the rates for computing the cost of a phone "
"call along with the rules for applying the rates."
msgstr ""
"規則を決めます。 あなたが知っているすべての事実を確認してください。 :doc:`第２章<chapter2>` "
"では、電話料金計算と料金を適用するための規則を説明しました。"

# picture 風景、景色
#: ../../chapter4.rst:67
msgid "Picture the problem as a whole."
msgstr "全体として問題を描きます。"

#: ../../chapter4.rst:69
msgid ""
"In the *analysis* phase we separated the problem into its parts, to "
"clarify our understanding of each piece. We are now entering the "
"*synthesis* phase. We must visualize the problem as a whole."
msgstr "「分析」フェイズでは、各部分の理解を明確にするために、問題を部分に分けました。 私たちは今や「合成」フェイズに入っています。 問題全体を視覚化する必要があります。"

#: ../../chapter4.rst:73
msgid ""
"Try to retain as much information about the problem in your mind as "
"possible. Use words, phrases, figures and tables, or any kind of graphic "
"representation of the data and/or rules to help you see the maximum "
"information at a glance. Fill your mind to bursting with the requirements"
" of the problem you need to solve, the way you might fill your lungs with"
" air."
msgstr ""
"できるだけ多くの問題についての情報を頭に入れておくようにしてください。 "
"一目で最大限の情報を確認するのに役立つように、単語、フレーズ、図、表、またはデータや規則の任意の種類のグラフィック表現を使用してください。 "
"あなたが息を大きく吸い込んで止めた時のように、解決する必要がある問題の要件を頭の中に詰め込んで、そして一気にはき出すようにアイデアの奔流を生み出して下さい。"

#: ../../chapter4.rst:80
msgid "Now hold that mental image, the way you might hold your breath."
msgstr "この、思考的に「大きく吸って息を止める」方法を会得してください。"

#: ../../chapter4.rst:82
msgid "One of two things will happen:"
msgstr "そうすると、次の２つのうちのいずれかが起こります。"

#: ../../chapter4.rst:84
msgid ""
"You may see the solution in a flash of insight. Great! Exhale a sigh of "
"relief and proceed directly to implementation. Or…, the problem is too "
"complex or too unfamiliar to be solved so easily. In this case, you’ll "
"have to turn your attention to analogies and partial solutions. As you do"
" so, it’s important that you have already concentrated on the problem’s "
"requirements all at once, engraving these requirements on your mental "
"retina."
msgstr ""
"あなたは洞察力のひらめきで解決策を見るかもしれません。 すばらしい！ 安心のため息を吐き出し、すぐに実施に進む。 "
"または…、問題は解決するには複雑すぎる、またはなじみのないものです。 この場合は、類推と部分的な解決策に注意を向ける必要があります。 "
"あなたがそうするとき、あなたがすでに問題の必要条件に一度に集中していて、あなたの精神的な網膜の上にこれらの必要条件を刻むことは重要です。"

#: ../../chapter4.rst:94
msgid "Develop a plan."
msgstr "計画を開発する"

#: ../../chapter4.rst:96
msgid ""
"If the solution didn’t come at a glance, the next step is to determine "
"the approach that you will take to solve it. Set a course for action and "
"avoid the trap of fumbling about aimlessly."
msgstr ""
"解決策が一目でわからない場合は、次のステップはあなたがそれを解決するために取るアプローチを決定することです。 "
"行動のためのコースを設定し、無意識のうちにぶつかることの罠を避けてください。"

#: ../../chapter4.rst:100
msgid "The following tips suggest several approaches you might consider."
msgstr "以下のヒントは、検討に値するいいくつかのアプローチを提案します。"

#: ../../chapter4.rst:104
msgid "Think of an analogous problem."
msgstr "同様の問題を考えてください。"

#: ../../chapter4.rst:106
msgid ""
"Does this problem sound familiar? Have you written a definition like it "
"before? Figure out what parts of the problem are familiar, and in what "
"ways this problem might differ. Try to remember how you solved it before,"
" or how you solved something like it."
msgstr "この問題は既におなじみのものでしょうか。 あなたは以前に同様の定義を書きましたか？ 問題のどの部分がよく知られているのか、またこの問題がどのように異なるのかを理解します。 以前にそれをどのように解決しようと試みたか、またはどのようにしてそれを解決したかを覚えておくようにしてください。"

# 前方へ働く
#: ../../chapter4.rst:113
msgid "Work forward."
msgstr "処理の流れに沿って前進して下さい。"

#: ../../chapter4.rst:115
msgid ""
"The normal, obvious way to attack a problem is by beginning with the "
"known, and proceeding to the unknown. In deciding which horse to bet on, "
"you’d begin with their recent histories, their current health, and so on,"
" apply weights to these various factors and arrive at a favorite."
msgstr ""
"問題を攻撃するための通常の明白な方法は、既知のものから始めて未知のものに進むことです。 "
"どの馬に賭けるかを決める際には、最近の歴史や現在の健康状態などから始めて、これらのさまざまな要因に重みを付けてお気に入りに到達します。"

# 後方へ働く
#: ../../chapter4.rst:122
msgid "Work backward."
msgstr "処理の結果から逆方向にさかのぼって下さい。"

#: ../../chapter4.rst:124
msgid ""
"More complicated problems present many possible ways to go with the "
"incoming data. How do you know which route will take you closer to the "
"solution? You don’t. This class of problem is best solved by working "
"backward ( :numref:`fig4-1` )."
msgstr "より複雑な問題は、入ってくるデータを処理するための多くの可能な方法を提示します。 どのルートで進めば解決策に近づくことがでるでしょうか？いいえ進みません。この種の問題は結果から後ろ向きにさかのぼることで最もよく解決されます( :numref:`fig4-1` )。"

#: ../../chapter4.rst:133
msgid "A problem that is easier to solve backward than forward."
msgstr "処理に沿って進むより結果かさかのぼる方ががより簡単な問題。"

#: ../../chapter4.rst:139
msgid "Believe."
msgstr "信じ込んで下さい。"

#: ../../chapter4.rst:141
msgid ""
"Belief is a necessary ingredient for successfully working backward. We’ll"
" illustrate with a famous mathematical problem. Suppose we have two "
"containers. The containers have no graduation marks, but one holds nine "
"gallons and the other holds four gallons. Our task is to measure out "
"exactly six gallons of water from the nearby stream in one of the "
"containers ( :numref:`fig4-2` )."
msgstr "信じ込む事は、結果からさかのぼるために必要な要素です。 私たちは有名な数学的問題で説明します。 2つのバケツがあるとします。 バケツには目盛りはありませんが、一方は9リットル入りで、もう一方には4リットル入りです。 私たちの仕事は、小川から正確に6リットルの水を汲み上げることです( :numref:`fig4-2` ）。"

#: ../../chapter4.rst:152
msgid "Two containers."
msgstr "２つのバケツ"

#: ../../chapter4.rst:156
msgid "Try to solve this on your own before reading further."
msgstr "さらに読み進む前に、これを自分で解決してみてください。"

#: ../../chapter4.rst:158
msgid ""
"How can we get a “six” out of a “nine” and a “four”? We can start out "
"working forward, by mentally transferring water from one container to the"
" other. For example, if we fill the large container twice from the small "
"container, we’ll get eight gallons. If we fill the nine-gallon container "
"to the brim, then empty enough water to fill the four-gallon container, "
"we’ll have exactly five gallons in the large container."
msgstr "どのようにして、「9」と「4」から「6」を得ることができますか？ 私たちは、バケツから別のバケツへと水を移すことを想像することによって、処理を進め始めることができます。 たとえば、小さなバケツ(4リットル)で大きなバケツ(9リットル)に２回注ぐと、8リットルが得られます。 大きなバケツ(9リットル)をいっぱいにしてから、小さなバケツ(4リトル)を満たすと、大きなバケツ(9リットル)には正確に5リットルが余ります。"

#: ../../chapter4.rst:166
msgid ""
"These ideas are interesting, but they haven’t gotten us six gallons. And "
"it’s not clear how they will get us six gallons."
msgstr "これらのアイディアは興味深いですが、私たちはまだ6リットルを手に入れてません。そしてどのように6リットルにするのか明らかではありません。"

#: ../../chapter4.rst:169
msgid ""
"Let’s try working backward. We assume we’ve measured six gallons of "
"water, and it’s sitting in the large container (it won’t fit in the small"
" one!). Now, how did we get it there? What was the state of our "
"containers one step previously?"
msgstr "結果からさかのぼってみましょう。 私たちは6リットルの水を測定したと仮定します、そしてそれは大きなバケツ(9)の中に入っています（それは小さなバケツ(9)には収まりません！） さて、どうやってそこに至りましたか？ 一歩前の私たちのバケツの状態はどうでしたか？"

#: ../../chapter4.rst:174
msgid "There are only two possibilities ( :numref:`fig4-3` ):"
msgstr "２つの可能性があります( :numref:`fig4-3` )。"

#: ../../chapter4.rst:176
msgid ""
"The four-gallon container was full, and we just added it to the large "
"container. This implies that we already had two gallons in the large "
"container. Or…"
msgstr "小さなバケツ(4)満杯の水を大きなバケツ(9)に入れたとすると、その前に大きなバケツ(9)にはすでに2リットル入っていた事になります。あるいは、"

#: ../../chapter4.rst:180
msgid ""
"The nine-gallon container was full, and we just poured off three gallons "
"into the small container."
msgstr "大きなバケツ(9)を満杯にして、そこから、1リットルだけすでに入っていた小さなバケツ(4)に注ごうとしているところです。"

#: ../../chapter4.rst:183
msgid ""
"Which choice? Let’s make a guess. The first choice requires a two-gallon "
"measurement, the second requires a three-gallon measurement. In our "
"initial playing around, we never saw a unit like two. But we did see a "
"difference of one, and one from four is three. Let’s go with version b."
msgstr "どちらを選びますか？推測しましょう。VERSON Aは2リットルの測定を必要とし、VEERSON Bは3リットルの測定を必要とします。 最初の試行では、この2つの結果はありませんでした。 しかし、1リットル差のパターンがありました。4引く1は3です。 ということで、VERSION Bから始めるとしましょう。"

#: ../../chapter4.rst:188
msgid ""
"Now comes the real trick. We must make ourselves *believe* without doubt "
"that we have arrived at the situation described. We have just poured off "
"three gallons into the small container. Suspending all disbelief, we "
"concentrate on how we did it."
msgstr "ここで本物の策を弄します。私たちは、説明した状況にたどり着いたことを疑う余地なく、自分自身に信じ込ませなければなりません。 私達はちょうど3リットルを小さなバケツ(4)に注いだところです。すべての不信を中断して、私たちはそれをどうやったかに集中します。"

#: ../../chapter4.rst:193
msgid ""
"How can we pour off three gallons into the small container? If there had "
"already been one gallon in the small container! Suddenly we’re over the "
"hump. The simple question now is, how do we get one gallon in the small "
"container? We must have started with a full nine-gallon container, poured"
" off four gallons twice, leaving one gallon. Then we transferred the one "
"gallon to the small container."
msgstr ""
"小さなバケツ4)に3リットルを注ぐにはどうすればよいでしょうか。 小さいバケツにすでに1リットルがあったならば！ "
"突然私たちはハードルを乗り越えました。 "
"簡単な質問は、小さなバケツに1リットルをどうやって入れるかということです。大きなバケツ(9)満杯から、小さなバケツ(4)に2回注ぐと、大きなバケツ(9)には1リットルが残りました。それからその1リットルを小さなバケツ(4)に移しました。"

#: ../../chapter4.rst:204
msgid "Achieving the end result."
msgstr "最終結果を達成する。"

#: ../../chapter4.rst:210
msgid "Intent on a complicated problem."
msgstr "複雑な問題の目的"

#: ../../chapter4.rst:212
msgid ""
"Our final step should be to check our logic by running the problem "
"forwards again."
msgstr "私たちの最後のステップは、問題を再び処理に沿って進めてみてロジックをチェックすることです。"

#: ../../chapter4.rst:215
msgid ""
"Here’s another benefit of working backward: If the problem is unsolvable,"
" working backward helps you quickly prove that it has no solution."
msgstr "逆方向に作業することのもう1つの利点は、問題が解決できない場合は、逆方向に作業すると解決策がないことをすぐに証明できます。"

#: ../../chapter4.rst:222
msgid "Recognize the auxiliary problem."
msgstr "補助的な問題を認識してください。"

#: ../../chapter4.rst:224
msgid ""
"Before we’ve solved a problem, we have only a hazy notion of what "
"steps—or even how many steps—may be required. As we become more familiar "
"with the problem, we begin to recognize that our problem includes one or "
"more subproblems that somehow seem different from the main outline of the"
" proposed procedure."
msgstr ""
"問題を解決する前は、どのステップが必要なのか、あるいはいくつのステップが必要なのかという漠然とした概念しかありません。 "
"私たちが問題に慣れてくるにつれて、私たちの問題には、提案している手順の本流とは幾分異なるよう思える複数の副問題が含まれることを認識し始めます。"

#: ../../chapter4.rst:230
msgid ""
"In the problem we just solved, we recognized two subproblems: filling the"
" small container with one gallon and then filling the large container "
"with six gallons."
msgstr "私たちが今さっき解決した問題では、小さなバケツに1リットル入れ、次に大きなバケツに6リットル入れるという2つの副問題がありました。"

#: ../../chapter4.rst:234
msgid ""
"Recognizing these smaller problems, sometimes called “auxiliary "
"problems,” is an important problem-solving technique. By identifying the "
"subproblem, we can assume it has a straightforward solution. Without "
"stopping to determine what that solution might be, we forge ahead with "
"our main problem."
msgstr "「補助問題」と呼ばれることもあるこれらの小さな問題を認識することは、重要な問題解決手法です。副問題を特定することで、それには簡単な解決策があると仮定することができます。 その解決策が何であるかを判断することを放棄せずに、私たちは主な問題とともに先に進みます。"

#: ../../chapter4.rst:240
msgid "(Forth is ideally suited to this technique, as we’ll see.)"
msgstr "（Forthはこの技法に最適です。これについては後で説明します。）"

#: ../../chapter4.rst:244
msgid "Step back from the problem."
msgstr "問題から一歩遠ざかってみる"

#: ../../chapter4.rst:246
msgid ""
"It’s easy to get so emotionally attached to one particular solution that "
"we forget to keep an open mind."
msgstr "ある特定の解決策に簡単に感情的になってしまうので、私たちは偏見を持たずにいることを忘れてしまいます。"

#: ../../chapter4.rst:249
msgid ""
"The literature of problem solving often employs the example of the nine "
"dots. It stumped me, so I’ll pass it along. We have nine dots arranged as"
" shown in  :numref:`fig4-4` . The object is to draw straight lines that "
"touch or pass through all nine dots, without lifting the pen off the "
"paper. The constraint is that you must touch all nine dots with only four"
" lines."
msgstr ""
"問題解決の文献はしばしば9つの点の例を採用しています。 それは私を困惑させたので、ここに示します。 :numref:`fig4-4` "
"のように9つの点が配置されています。 目的は、ペンを紙から持ち上げることなく、9つすべての点に接触または通過する直線を描画することです。 "
"制約は、9つすべての点に4本の線だけで触れる必要があることです。"

#: ../../chapter4.rst:261
msgid "The nine dots problem."
msgstr "9つの点問題"

#: ../../chapter4.rst:265
msgid ""
"You can sit a good while and do no better than the almost-right "
":numref:`fig4-5` . If you concentrate really hard, you may eventually "
"conclude that the problem is a trick—there’s no solution."
msgstr ""
"しばらくの間がんばっても、ほぼ正しい :numref:`fig4-5` よりも良くはありません。 "
"あなたが本当に一生懸命集中するならば、あなたは結局問題は引っ掛けであると結論づけるかもしれません。じつは、解決策はありません。"

#: ../../chapter4.rst:274
msgid "Not quite right."
msgstr "正解は無い"

#: ../../chapter4.rst:278
msgid "But if you sit back and ask yourself,"
msgstr "しかし、あなたは振り返って自分自身にこう尋ねる"

#: ../../chapter4.rst:280
msgid ""
"\"Am I cheating myself out a useful tack by being narrow-minded? Am I "
"assuming any constraints not specified in the problem? What constraints "
"might they be?\""
msgstr "「私は、狭義に捉えることによって自分自身をだましていますか？問題で指定されていない制約を想定していますか？それらはどのような制約になる可能性がありますか？」"

#: ../../chapter4.rst:284
msgid ""
"then you might think of extending some of the lines beyond the perimeter "
"of the nine dots."
msgstr "それなら、9つの点の周囲を超えていくつかの線を延長することを考えるかもしれません。"

#: ../../chapter4.rst:289
msgid "Use whole-brain thinking."
msgstr "右脳左脳全部使って考えましょう。"

#: ../../chapter4.rst:291
msgid ""
"When a problem has you stumped and you seem to be getting nowhere, relax,"
" stop worrying about it, perhaps even forget about it for a while."
msgstr "問題があなたを困らせ、行き詰まっているように思われるときは、リラックスして、心配するのをやめてください。"

#: ../../chapter4.rst:294
msgid ""
"Creative people have always noted that their best ideas seem to come out "
"of the blue, in bed or in the shower. Many books on problem solving "
"suggest relying on the subconscious for the really difficult problems."
msgstr ""
"創造的な人々は、常に彼らの最高のアイデアはベッドの中やシャワーの中で、はるか彼方から出てくるように見えることに気づいていました。 "
"問題解決に関する多くの本は、本当に困難な問題を潜在意識に頼ることを提案しています。"

#: ../../chapter4.rst:298
msgid ""
"Contemporary theories on brain functions explore the differences between "
"rational, conscious thought (which relies on the manipulation of symbols)"
" and subconscious thought (which correlates perceptions to previously "
"stored information, recombining and relinking knowledge in new and useful"
" ways)."
msgstr "現代の脳機能理論は、合理的で意識的な思考（シンボルの操作に依存する）と潜在意識的な思考（知覚を以前に保存された情報と相関させ、新しい有用な方法で知識を再結合し再リンクする）の違いを探ります。"

#: ../../chapter4.rst:304
msgid ""
"Leslie Hart [hart75]_ explains the difficulty of solving a large problem "
"by means of logic:"
msgstr "Leslie Hart [hart75]_ は、ロジックによって大きな問題を解くことの難しさを説明しています。"

#: ../../chapter4.rst:308
msgid ""
"A huge load is placed on that one small function of the brain that can be"
" brought into the attention zone for a period. The feat is possible, like"
" the circus act, but it seems more sensible to... use the full resources "
"of our glorious neocortex... the multibillion-neuron capacity of the "
"brain."
msgstr ""
"しばらくの間注意領域に持ち込まれることができる脳のその1つの小さな機能に大きな負荷がかかります。 "
"サーカスのように偉業は可能ですが、私たちの栄光ある新皮質の全資源を利用すること...脳の数十億個のニューロンの能力を利用することがより賢明です。"

#: ../../chapter4.rst:314
msgid ""
"\\... The work aspect lies in providing the brain with raw input, as in "
"observing, reading, collecting data, and reviewing what others have "
"achieved.  Once in, [subconscious] procedures take over, simultaneously, "
"automatically, outside of the attention zone."
msgstr ""
"…仕事には、観察、読み取り、データの収集、他の人が達成したことの確認など、脳に生の入力を提供する側面があります。 "
"一度入ったら、「[潜在意識」手順が、同時に、自動的に、注意領域の外側を引き継ぎます。"

#: ../../chapter4.rst:319
msgid ""
"\\... It seems apparent... that a search is going on during the interval,"
" though not necessarily continuously, much as in a large computer. I "
"would hazard the guess that the search ramifies, starts and stops, "
"reaches dead ends and begins afresh, and eventually assembles an answer "
"that is evaluated and then popped into conscious attention---often in "
"astonishingly full-blown detail."
msgstr ""
"…それは明らかに思えますが…大型コンピュータと同じように、必ずしも継続的ではありませんが、検索はその間に行われています。 "
"私は、検索が分岐し、開始し、停止し、行き止まりになり、そして新たに始まり、最終的には評価された後に意識的な注意を払うように解答を集めるという推測に疑問を感じます。"

#: ../../chapter4.rst:328
msgid "Evaluate your solution. Look for other solutions."
msgstr "解決策を評価してください。 他の解決策を探してください。"

#: ../../chapter4.rst:330
msgid ""
"You may have found one way of skinning the cat. There may be other ways, "
"and some of them may be better."
msgstr "猫の皮を剥ぐ方法を1つ見つけたのかもしれません。 他の方法があるかもしれません、そしてそれらのうちのいくつかはより良いかもしれません。"

#: ../../chapter4.rst:333
msgid ""
"Don’t invest too much effort in your first solution without asking "
"yourself for a second opinion."
msgstr "最初の解決策にばかり傾注せず、セカンドオピニオンを求めて下さい。"

#: ../../chapter4.rst:340
msgid "\"I\\'m not just sleeping. I\\'m using my neocortex.\""
msgstr "「私はただ眠っているだけじゃありません。大脳新皮質を使ってるんです。」"

# ソフトウェア元祖　ソフトウェア開発者
#: ../../chapter4.rst:343
msgid "Interview with a Software Inventor"
msgstr "ソフトウェア新規開発者へのインタビュー"

#: ../../chapter4.rst:397
msgid ""
"**Donald A. Burgess**, owner and president of Scientek Instrumentation, "
"Inc.:"
msgstr "Scientek Instrumentation, Incのオーナー兼社長である **Donald A. Burgess** は言います。"

#: ../../chapter4.rst:346
msgid ""
"I have a few techniques I've found useful over the years in designing "
"anything, to keep myself flexible. My first rule is, \"Nothing is "
"impossible.\" My second rule is, \"Don't forget, the object is to make a "
"buck.\""
msgstr "私は自分自身を柔軟に保つために、何かを設計する上で長年にわたって私が有用だと思ったいくつかのテクニックを持っています。 私の最初の規則は、「不可能なことは何もない」です。 私の2番目の規則は、「忘れないでください、目的は出力することです」です。"

#: ../../chapter4.rst:351
msgid ""
"First examine the problem, laying out two or three approaches on paper. "
"Then try the most appealing one, to see if it works. Carry it through. "
"Then deliberately go all the way back to the beginning, and start over."
msgstr ""
"まず問題を調べ、2つか3つのアプローチを紙に書きます。 それからそれがはたらくかどうか見るために、最も魅力的なものを試してください。 "
"通して実行してみます。それから、故意に始めまで戻って、最初からやり直します。"

#: ../../chapter4.rst:355
msgid ""
"Starting over has two values. First, it gives you a fresh approach. You "
"either gravitate back to the way you started, or the way you started "
"gravitates toward the new way."
msgstr ""
"最初からやり直すことには2つの価値があります。 まず、それはあなたに新鮮なアプローチを与えます。 "
"あなたはあなたが始めたやり方に引き返すか、あなたが始めたやり方より新しいやり方に引き寄せられます。"

#: ../../chapter4.rst:359
msgid ""
"Second, the new approach may show all kinds of powerful possibilities. "
"Now you have a benchmark. You can look at both approaches and compare the"
" advantages of both. You're in a better position to judge."
msgstr ""
"第二に、新しいアプローチはあらゆる種類の強力な可能性を示すかもしれません。 今や、あなたは(既に一度試行したことで)基準となるものを持っています。"
" 両方のアプローチを見て、両方の利点を比較することができます。 あなたは判断するのにより良い立場にあります。"

#: ../../chapter4.rst:363
msgid ""
"Getting stuck comes from trying too hard to follow a single approach. "
"Remember to say, \"I want this kumquat crusher to be different. Let's "
"reject the traditional design as not interesting. Let's try some crazy "
"ideas.\""
msgstr ""
"身動きできなくなるのは、単一のアプローチに従うのが難しすぎるからです。 "
"「私はこの金柑しぼり器を違うものにしたいのです。伝統的なデザインを面白くないと拒絶しましょう。クレイジーなアイデアを試してみましょう。」"

#: ../../chapter4.rst:368
msgid ""
"The best thing is to start drawing pictures. I draw little men. That "
"keeps it from looking like \"data\" and interfering with my thinking "
"process. The human mind works exceptionally well with analogies. Putting "
"things in context keeps you from getting stuck within the confines of any"
" language, even Forth."
msgstr ""
"一番いいのは絵を描き始めることです。 "
"私は小さな男を描きます。それが「データ」のように見えないようにして私の思考プロセスをいじくります。類推は思考を活性化させます。状況の中に物事を置くことは、Forthをはじめ、あなたがあらゆる言語の中に閉じ込められるのを防ぎます。"

#: ../../chapter4.rst:374
msgid ""
"When I want to focus my concentration, I draw on little pieces of paper. "
"When I want to think in broad strokes, to capture the overall flow, I "
"draw on great big pieces of paper. These are some of the crazy tricks I "
"use to keep from getting stagnant."
msgstr ""
"私は集中したいときは小さな紙切れに描きます。私が全体的な流れをとらえるために広い範囲で考えたいときは大きな一枚の紙に描きます。 "
"これらは私が停滞しないようにするために使用するクレイジーなトリックのいくつかです。"

#: ../../chapter4.rst:379
msgid ""
"When I program in Forth, I spend a day just dreaming, kicking around "
"ideas. Usually before I start typing, I sketch it out in general terms. "
"No code, just talk. Notes to myself."
msgstr ""
"私がForthでプログラムをするとき、私はただ夢を見ながら、アイデアをの周りを蹴って一日過ごします。 "
"通常、打ち込みを始める前に、一般的な用語でそれをスケッチします。 手書きのコードはありません、語りだけです。自分へのメモだけです。"

#: ../../chapter4.rst:383
msgid ""
"Then I start with the last line of code first. I describe what I would "
"like to do, as close to English as I can. Then I use the editor to slide "
"this definition towards the bottom of the screen, and begin coding the "
"internal words. Then I realize that's a lousy way to do it. Maybe I split"
" my top word into two and transfer one of them to an earlier block so I "
"can use it earlier. I run the hardware if I have it; otherwise I simulate"
" it."
msgstr "それから私は最初のコードの最終行から始めます。 できる限り文章に近いように、自分がやりたいことを説明します。 それから私はエディタを使ってこの定義を画面の下にスライドさせ、そして内部のワードのコーディングを始めます。 それから私はそれがそれをするためのお粗末な方法であることに気づきます。 一番上のワードを2つに分割し、そのうちの1つを以前のブロック(スクリーン)に転送して、それをもっと早く使用できるようにするかもしれません。 ハードウェアがある場合は実行してみます。 それ以外の場合はシミュレートします。"

#: ../../chapter4.rst:390
msgid ""
"Forth requires self-discipline. You have to stop diddling with the "
"keyboard. Forth is so willing to do what I tell it to, I'll tell it to do"
" all kinds of ridiculous things that have nothing to do with where I'm "
"trying to go. At those times I have to get away from the keyboard."
msgstr ""
"Forthは自己訓練が必要です。 あなたはひたすらキーボードをいじくるのをやめる必要があります。 "
"Forthは私が言うことをやろうとします。私が行こうとしている場所とは無関係のあらゆるばかげたことやろうとします。 "
"その時は私はキーボードから離れなければなりません。"

#: ../../chapter4.rst:395
msgid ""
"Forth lets you play. That's fine, chances are you'll get some ideas. As "
"long as you keep yourself from playing as a habit. Your head is a whole "
"lot better than the computer for inventing things."
msgstr "Forthはあなたに遊ばせます。 それで結構です。あなたはそれでいくつかのアイデアを得ることができるでしょう。あなたがForthで遊ぶ習慣はあっても、あなたが自分自身を保つ限り、あなたの頭はコンピュータよりもはるかに優れています。"

#: ../../chapter4.rst:400
msgid "Detailed Design"
msgstr "詳細設計"

#: ../../chapter4.rst:402
msgid ""
"We’re now at the point in the development cycle at which we’ve decided we"
" need a component (or a particular word). The component will consist of a"
" number of words, some of which (those that comprise the lexicon) will be"
" used by other components and some of which (the internal words) will be "
"only used within this component."
msgstr ""
"私たちは今、開発サイクルの中で、コンポーネント（または特定のワード）が必要だと決心したところです。 "
"コンポーネントはいくつかのワードで構成され、その一部（用語集を構成するもの）は他のコンポーネントによって使用され、一部（内部のワード）はこのコンポーネント内でのみ使用されます。"

#: ../../chapter4.rst:408
msgid "Create as many words as necessary to obey the following tip:"
msgstr "次のヒントに従うために必要な数のワードを作成します。"

#: ../../chapter4.rst:412
msgid "Each definition should perform a simple, well-defined task."
msgstr "各定義は、単純で明確に定義されたタスクを実行する必要があります。"

#: ../../chapter4.rst:414
msgid "Here are the steps generally involved in designing a component:"
msgstr "コンポーネントの設計に一般的に含まれる手順は次のとおりです。"

#: ../../chapter4.rst:417
msgid ""
"Based on the required functions, decide on the names and syntax for the "
"external definitions (define the interfaces)."
msgstr "要求される機能に基づいて、外部定義の名前と構文を決定します（インターフェースを定義します）。"

#: ../../chapter4.rst:420
msgid ""
"Refine the conceptual model by describing the algorithm(s) and data "
"structure(s)."
msgstr "アルゴリズムとデータ構造を記述して、概念モデルを改良します。"

#: ../../chapter4.rst:423
msgid "Recognize auxiliary definitions."
msgstr "補助定義を認識します。"

#: ../../chapter4.rst:425
msgid "Determine what auxiliary definitions and techniques are already available."
msgstr "どのような補助的な定義と技法が、すでに利用可能かを判断します。"

#: ../../chapter4.rst:428
msgid "Describe the algorithm with pseudocode."
msgstr "擬似コードを使用してアルゴリズムを説明します。"

#: ../../chapter4.rst:430
msgid "Implement it by working backwards from existing definitions to the inputs."
msgstr "既存の定義から入力に逆方向に作業することによってそれを実装します。"

#: ../../chapter4.rst:433
msgid "Implement any missing auxiliary definitions."
msgstr "不足している補助定義を実装します。"

#: ../../chapter4.rst:435
msgid ""
"If the lexicon contains many names with strong elements in common, design"
" and code the commonalities as internal definitions, then implement the "
"external definitions."
msgstr "強力な要素を持つ共通の名前が多く含まれている場合は、共通性を内部定義として設計およびコーディングしてから、外部定義を実装します。"

#: ../../chapter4.rst:439
msgid ""
"We’ll discuss the first two steps in depth. Then we’ll engage in an "
"extended example of designing a lexicon."
msgstr "私たちは最初の2つのステップについて深く掘り下げます。それから拡張の例として用語集を設計します。"

#: ../../chapter4.rst:444
msgid "Forth Syntax"
msgstr "Forth構文"

#: ../../chapter4.rst:446
msgid ""
"At this point in the development cycle you must decide how the words in "
"your new lexicon will be used in context. In doing so, keep in mind how "
"the lexicon will be used by subsequent components."
msgstr ""
"開発サイクルのこの時点で、新しい用語集のワードをどのように使用するのかを決定する必要があります。 "
"その際、後続のコンポーネントがその用語集をどのように使用するかを覚えておいてください。"

#: ../../chapter4.rst:452
msgid ""
"In designing a component, the goal is to create a lexicon that will make "
"your later code readable and easy to maintain."
msgstr "コンポーネントを設計する際の目標は、それ以降のコードを読みやすく、保守しやすくする用語集を作成することです。"

#: ../../chapter4.rst:455
msgid ""
"Each component should be designed with components that use it in mind. "
"You must design the syntax of the lexicon so that the words make sense "
"when they appear in context. Hiding interrelated information within the "
"component will ensure maintainability, as we’ve seen."
msgstr ""
"各コンポーネントはそれを使用するコンポーネントを念頭に置いて設計する必要があります。 "
"ワードが文脈の中で現れるときに意味がわかるように、あなたは用語集の構文を設計しなければなりません。 "
"これまで見てきたように、相互に関連する情報をコンポーネント内に隠すことで、保守性を確保します。"

#: ../../chapter4.rst:460
msgid ""
"At the same time, observe Forth’s own syntax. Rather than insisting on a "
"certain syntax because it seems familiar, you may save yourself from "
"writing a lot of unnecessary code by choosing a syntax that Forth can "
"support without any special effort on your part."
msgstr "同時に、Forth自身の構文を観察してください。 あなたが親しんでいるという理由で特定の構文を主張するのではなく、Forthが特別な努力をしなくてもサポートできる構文を選択することで、不要なコードをたくさん書く必要がなくなります。"

#: ../../chapter4.rst:465
msgid "Here are some elementary rules of Forth’s natural syntax:"
msgstr "Forthの自然な構文の基本的な規則は次のとおりです。"

#: ../../chapter4.rst:469
msgid "Let numbers precede names."
msgstr "数を名前の前に置く。"

#: ../../chapter4.rst:471
msgid ""
"Words that require a numeric argument will naturally expect to find that "
"number on the stack. Syntactically speaking, then, the number should "
"precede the name. For instance, the syntax of the word ``SPACES``, which "
"emits ``n`` number of spaces, is"
msgstr "数値引数を必要とするワードは、当然その数値をスタック上で見つけることを期待します。 構文としては、数値は名前の前に置きます。 たとえば、 n個のスペースを出力する ``SPACES`` というワードの構文は、"

#: ../../chapter4.rst:480
msgid ""
"Sometimes this rule violates the order that our ear is accustomed to "
"hearing. For instance, the Forth word ``+`` expects to be preceded by "
"both arguments, as in"
msgstr "です。時々、この規則は(英語圏の)私たちが聞き慣れている順番に違反します。 たとえば、Forthのワード ``+`` の前には、以下の通り両方の引数が置かれることを想定しています。"

#: ../../chapter4.rst:488
msgid "This ordering, in which values precede operators, is called “postfix.”"
msgstr "値が演算子に先行するこの順序付けは「後置」と呼ばれます。"

#: ../../chapter4.rst:491
msgid ""
"Forth, in its magnanimity, won’t *insist* upon postfix notation. You "
"could redefine ``+`` to expect one number in the input stream, like this:"
msgstr "Forthは心が広いので、後置記法(訳注：しばしば逆ポーランド記法とも言われる)を無理強いする事はありません。以下のように、入力ストリーム内で数の1つを期待するように ``+`` を再定義することもできます。"

#: ../../chapter4.rst:498
msgid "by defining it so:"
msgstr "この定義は以下です。"

#: ../../chapter4.rst:504
msgid ""
"(where ``WORD`` is 79/83 Standard, returning an address, and ``NUMBER`` "
"returns a double-length value as in the 83 Standard Uncontrolled "
"Reference Words)."
msgstr ""
"(ここで、``WORD`` は79および83標準のワードで、アドレスを返し、そして83標準では非推奨のワード(Forth-83 Appendix "
"B. Uncontorlled Reference Words 参照)である ``NUMBER`` は倍長整数を返します)"

#: ../../chapter4.rst:508
msgid ""
"Fine. But you wouldn’t be able to use this definition inside other colon "
"definitions or pass it arguments, thereby defeating one of Forth’s major "
"advantages."
msgstr "これはいい。しかし、この定義を他のコロン定義の中で使用したり引数を渡したりすることはできず、それによってForthの大きな利点の1つが無効になります。"

#: ../../chapter4.rst:512
msgid ""
"Frequently, \"noun\" type words pass their addresses (or any type of "
"pointer) as a stack argument to “verb” type words. The Forth-like syntax "
"of"
msgstr "多くの場合、「名詞(noun)」タイプのワードは、そのアドレス（または任意のタイプのポインタ）を「動詞(verb)」タイプのワードのスタック引数として渡します。以下がForth流の構文です。"

#: ../../chapter4.rst:520
msgid "will generally prove easiest to implement because of the stack."
msgstr "これらはスタックを使って普通に実装するのが最も簡単です。"

#: ../../chapter4.rst:525
msgid ""
"In some cases this word order sounds unnatural. For instance, suppose we "
"have a file named ``INVENTORY``. One thing we can do with that file is "
"``SHOW`` it; that is, format the information in pretty columns. If "
"``INVENTORY`` passes a pointer to ``SHOW``, which acts upon it, the "
"syntax becomes"
msgstr ""
"(英語では)場合によっては、この語順は不自然に聞こえます。 たとえば、 ``INVENTORY`` というファイルがあるとします。 "
"そのファイルを使ってできることの1つは、 ``SHOW`` です。 つまり、情報をきれいな列にフォーマットします。 ``INVENTORY`` "
"がそれに作用する ``SHOW`` へのポインタを渡すと、構文は以下のようになります。"

#: ../../chapter4.rst:536
msgid ""
"If your spec demands the English word-order, Forth offers ways to achieve"
" it. But most involve new levels of complexity. Sometimes the best thing "
"to do is to choose a better name. How about"
msgstr ""
"あなたの仕様が英語の語順を要求するならば、Forthはそれを達成する方法を提供します。 しかしほとんどの場合、新しいレベルの複雑さが伴います。 "
"時々、よりよい名前を選ぶ事に最善を尽くしてください。例えばこんなのはどうですか？"

#: ../../chapter4.rst:547
msgid "(We’ve made the “pointer” an adjective, and the “actor” a noun.)"
msgstr "（ここでは、 ``INVENTORY`` を形容詞として扱い、``REPORT`` 名詞として扱いました。）"

#: ../../chapter4.rst:549
msgid "If the requirements insist on the syntax"
msgstr "要件で構文の指定があった場合は以下のようにします。"

#: ../../chapter4.rst:555
msgid ""
"we have several options. ``SHOW`` might set a flag and ``INVENTORY`` "
"would act according to the flag. Such an approach has certain "
"disadvantages, especially that ``INVENTORY`` must be “smart” enough to "
"know all the possible actions that might be taken on it. (We’ll treat "
"these problems in Chapters :doc:`Chapter Seven<chapter7>` and "
":doc:`Chapter Eight<chapter8>` .)"
msgstr ""
"いくつかの選択肢があります。 ``SHOW`` はフラグを立て、 ``INVENTORY`` はそのフラグに従って動作します。 "
"このようなアプローチには、特に ``INVENTORY`` "
"がそれに対して実行される可能性のあるすべてのアクションを認識するのに十分「スマート」でなければならないという欠点があります(これらの問題は、 "
":doc:`第７章<chapter7>` と :doc:`第８章<chapter8>` で扱っています)。"

#: ../../chapter4.rst:562
msgid ""
"Or, ``SHOW`` might look ahead at the next word in the input stream. We’ll"
" discuss this approach in a tip, “Avoid expectations,” later in this "
"chapter."
msgstr ""
"あるいは、 ``SHOW`` は入力ストリームの次のワードを先読みするかもしれません。 "
"この章で後述する「期待を避ける」というヒントで、このアプローチについて説明します。"

#: ../../chapter4.rst:566
msgid ""
"Or, the recommended approach, ``SHOW`` might set an “execution variable” "
"that ``INVENTORY`` will then execute. (We’ll discuss vectored execution "
"in :doc:`Chapter Seven<chapter7>`.)"
msgstr ""
"あるいは、推奨されるアプローチとして、 ``SHOW`` は ``INVENTORY`` "
"が実行する「ワードへのポインタ」を設定するかもしれません(ベクトル実行については :doc:`第７章<chapter7>` で議論します)。"

#: ../../chapter4.rst:572
msgid "Let text follow names."
msgstr "テキストは名前の後ろに続けます。"

#: ../../chapter4.rst:574
msgid ""
"If the Forth interpreter finds a string of text that is neither a number "
"nor a predefined word, it will abort with an error message. For this "
"reason, an undefined string must be preceded by a defined word."
msgstr ""
"Forthインタプリタが数字でも定義済みのワードでもないテキスト文字列を見つけると、エラーメッセージを出力して中断します。 "
"このため、未定義の文字列の前には定義済みのワードを置かなければなりません。"

#: ../../chapter4.rst:578
msgid ""
"An example is ``.\"`` (dot-quote), which precedes the text it will later "
"print. Another example is ``CREATE`` (as well as all defining words), "
"which precedes the name that is, at the moment, still undefined."
msgstr "例としては  ``.\"`` (ドット・クォート）があります。これはその後ろに続く出力するテキストの前に置きます(訳注： ``.\"`` をワードとして認識させるために、その間に空白を置かねばならない。これが他言語と比べて間違いやすいところ)。もう1つの例は ``CREATE`` (そしてすべての定義ワード)です。 現時点ではまだ定義されていない名前の直前に置かれます(訳注：各々ワードとして認識させるために、定義ワードと名前の間に空白を置かねばならない)。"

#: ../../chapter4.rst:583
msgid ""
"The rule also applies to defined words that you want to refer to, but not"
" execute in the usual way. An example is ``FORGET`` , as in"
msgstr "この規則は参照したい定義済ワードにも適用されますが、通常の方法では実行されません。その一つの例として以下の ``FORGET`` があります。"

#: ../../chapter4.rst:592
msgid ""
"Syntactically, ``FORGET`` must precede ``TASK`` so that ``TASK`` doesn’t "
"execute."
msgstr "構文としては ``FORGET`` は ``TASK`` が実行されないように、 ``TASK`` の前に置く必要があります。"

#: ../../chapter4.rst:597
msgid "Let definitions consume their arguments."
msgstr "定義に引数を消費させます。"

#: ../../chapter4.rst:599
msgid ""
"This syntax rule is more a convention of good Forth programming than a "
"preference of Forth."
msgstr "この構文規則は、Forth的に必要というより、優れたForthプログラミングの規則です。"

#: ../../chapter4.rst:602
msgid ""
"Suppose you’re writing the word ``LAUNCH``, which requires the number of "
"a launch pad and fires the appropriate rocket. You want the definition to"
" look roughly like this:"
msgstr ""
"発射台の番号を必要とし、適切なロケットを発射する ``LAUNCH`` というワードを書いているとしましょう。 "
"この定義は、おおよそ次のようになります。"

#: ../../chapter4.rst:610
msgid ""
"Each of the three internal definitions will require the same argument, "
"the launch pad number. You’ll need two ``DUP`` s somewhere. The question "
"is where? If you put them inside ``LOAD`` and ``AIM``, then you can keep "
"them out of ``LAUNCH``, as in the definition above. If you leave them out"
" of ``LOAD`` and ``AIM``, you’ll have to define:"
msgstr ""
"3つの内部定義のそれぞれは、発射台番号という同じ引数が必要です。どこかに2つの ``DUP`` が必要です。 問題はどこですか？ それらを "
"``LOAD`` と ``AIM`` の中に入れると、上の定義のように、それらを ``LAUNCH`` から除外することができます。 "
"もしあなたがそれらを ``LOAD`` と ``AIM`` から除外するならば、あなたは次のように定義しなければなりません。"

#: ../../chapter4.rst:620
msgid ""
"By convention, the latter version is preferable, because ``LOAD`` and "
"``AIM`` are cleaner. They do what you expect them to do. Should you have "
"to define ``READY``, you can do it so:"
msgstr "慣例により、後者の方が望ましいです、なぜなら ``LOAD`` と ``AIM`` はきれいだからです。 それらはあなたがそれらに期待することをします。 あなたが ``READY`` を定義しなければならないなら、あなたはそうすることができます。"

#: ../../chapter4.rst:628
msgid "and not"
msgstr "慣例に従わなかった場合、以下のようにするハメになります。"

#: ../../chapter4.rst:636
msgid "Use zero-relative numbering."
msgstr "0から始まる番号を使います。"

#: ../../chapter4.rst:638
msgid ""
"By habit we humans number things starting with one: “first, second, "
"third,” etc. Mathematical models, on the other hand, work more naturally "
"when starting with zero. ince computers are numeric processors, software "
"becomes easier to write when we use zero-relative numbering."
msgstr ""
"私たち人間は習慣から1で始まる番号を付けます。「第1、第2、第3」などです。一方、数学モデルは、ゼロから始めるとより自然です。 "
"数学モデルに近親のコンピュータは数値プロセッサなので、ゼロから始まる番号を使用するとソフトウェアの記述が簡単になります。"

#: ../../chapter4.rst:644
msgid ""
"To illustrate, suppose we have a table of eight-byte records. The first "
"record occupies the first eight bytes of the table. To compute its "
"starting address, we add “0” to ``TABLE``. To compute the starting "
"address of the “second” record, we add “8” to ``TABLE``."
msgstr ""
"例として、レコード長8バイトの表があるとします。 最初のレコードは表の最初の8バイトを占めます。 その開始アドレスを計算するために、 "
"``TABLE`` に \"0\"を追加します。 「2番目」のレコードの開始アドレスを計算するには、「8」を ``TABLE`` に追加します。"

#: ../../chapter4.rst:653
msgid "A table of 8-byte records."
msgstr "レコード長8バイトの表"

#: ../../chapter4.rst:655
msgid "It’s easy to derive a formula to achieve these results:"
msgstr "これらの結果を達成するための公式を導き出すのは簡単です。"

#: ../../chapter4.rst:660
msgid "first record starts at:"
msgstr "1番目のレコードの開始は"

#: ../../chapter4.rst:661
msgid "0 × 8 ="
msgstr "0 × 8 ="

#: ../../chapter4.rst:662 ../../chapter4.rst:1230
msgid "0"
msgstr "0"

#: ../../chapter4.rst:663
msgid "second record starts at:"
msgstr "2番目のレコードの開始は"

#: ../../chapter4.rst:664
msgid "1 × 8 ="
msgstr "1 × 8 ="

#: ../../chapter4.rst:665 ../../chapter4.rst:1246
msgid "8"
msgstr "8"

#: ../../chapter4.rst:666
msgid "third record starts at:"
msgstr "3番目のレコードの開始は"

#: ../../chapter4.rst:667
msgid "2 × 8 ="
msgstr "2 × 8 ="

#: ../../chapter4.rst:668
msgid "16"
msgstr "16"

#: ../../chapter4.rst:670
msgid ""
"We can easily write a word which converts a record# into the address "
"where that record begins:"
msgstr "レコード数(record#)をそのレコードが始まるアドレスに変換するワードを簡単に書くことができます。"

#: ../../chapter4.rst:678
msgid ""
"Thus in computer terms it makes sense to call the “first record” the 0th "
"record."
msgstr "したがって、コンピュータの観点では、「最初のレコード」を0番目のレコードと呼ぶのが理にかなっています。"

#: ../../chapter4.rst:681
msgid ""
"If your requirements demand that numbering start at one, that’s fine. Use"
" zero-relative numbering throughout your design and then, only in the "
"“user lexicons” (the set of words that the end-user will use) include the"
" conversion from zero-to one-relative numbering:"
msgstr "あなたの要件が1から始まる番号付けを要求しても大丈夫です。 設計全体でゼロから始まる番号を使用してから、「ユーザ用語集」（エンドユーザが使用する一連のワード）にのみ、ゼロから1への相対番号の変換を含めます。"

#: ../../chapter4.rst:694
msgid "Let addresses precede counts."
msgstr "アドレスをカウントの前に置きます。"

#: ../../chapter4.rst:696
msgid ""
"Again, this is a convention, not a requirement of Forth, but such "
"conventions are essential for readable code. You’ll find examples of this"
" rule in the words ``TYPE``, ``ERASE``, and ``BLANK``."
msgstr ""
"繰り返しになりますが、これは規約であり、Forthの要求ではありませんが、そのような規約は読み取り可能なコードには不可欠です。 この規則の例は "
"``TYPE`` 、 ``ERASE`` 、そして ``BLANK`` の中にあります。"

#: ../../chapter4.rst:702
msgid "Let sources precede destinations."
msgstr "ソースをディスティネーションに先行させます。"

#: ../../chapter4.rst:704
msgid ""
"Another convention for readability. For instance, in some systems, the "
"phrase"
msgstr "読みやすさに関するもう1つの規約。 例えば、いくつかのシステムでは、以下のフレーズ、"

#: ../../chapter4.rst:711
msgid ""
"copies Screen 22 to Screen 37. The syntax of ``CMOVE`` incorporates both "
"this convention and the previous convention:"
msgstr "は、スクリーン22をスクリーン37にコピーします。以下の ``CMOVE`` の構文には、この規則と前の規則の両方が組み込まれています。"

#: ../../chapter4.rst:720
msgid "Avoid expectations (in the input stream)."
msgstr "（入力ストリーム内で）期待するのを避けてください。"

#: ../../chapter4.rst:722
msgid ""
"Generally try to avoid creating words that presume there will be other "
"words in the input stream."
msgstr "一般に、入力ストリームに他の指定のワードがあると想定するワードを作成しないようにしてください。"

#: ../../chapter4.rst:725
msgid ""
"Suppose your color computer represents blue with the value 1, and light-"
"blue with 9. You want to define two words: ``BLUE`` will return 1; "
"``LIGHT`` may precede ``BLUE`` to produce 9."
msgstr ""
"画面の色が、値1で青を表し、9で水色を表すと仮定します。2つのワードを定義したいとします。 ``BLUE`` は1を返します。 ``LIGHT``"
" 9を生成するために ``BLUE`` の前に置くことができます。"

#: ../../chapter4.rst:729
msgid ""
"In Forth, it would be possible to define ``BLUE`` as a constant, so that "
"when executed it always returns 1."
msgstr "Forthでは、 ``BLUE`` を定数として定義することが可能で、実行されると常に1を返します。"

#: ../../chapter4.rst:736
msgid ""
"And then define ``LIGHT`` such that it looks for the next word in the "
"input stream, executes it, and “ors” it with 8 (the logic of this will "
"become apparent when we visit this example again, later in the book):"
msgstr ""
"そして、``LIGHT`` "
"を、入力ストリームの次のワードを探し、それを実行し、それを8でORするように定義します(このロジックは、この本の後半でこの例をもう一度見れば明らかになります)。"

#: ../../chapter4.rst:745
msgid "in fig-Forth:"
msgstr "fig-Forthでは、"

#: ../../chapter4.rst:751
msgid ""
"(For novices: The apostrophe in the definition of ``LIGHT`` is a Forth "
"word called \"tick.\" Tick is a dictionary-search word; it takes a name "
"and looks it up in the dictionary, returning the address where the "
"definition resides. Used in this definition, it will find the address of "
"the word following ``LIGHT`` —for instance, ``BLUE`` —and pass this "
"address to the word ``EXECUTE``, which will execute ``BLUE``, pushing a "
"one onto the stack. Having “sucked up” the operation of ``BLUE``, "
"``LIGHT`` now “or”s an 8 into the 1, producing a 9.)"
msgstr ""
"（初心者のために： ``LIGHT`` "
"の定義におけるアポストロフィはティック(tick)と呼ばれるForthのワードです。ティックはディクショナリ検索ワードで、名前を取ってディクショナリの中でそれを調べ、定義のアドレスを返します。この定義では、"
" ``LIGHT`` に続くワードのアドレス(たとえば ``BLUE`` )を探し、このアドレスを ``EXECUTE`` というワードに渡して、"
" ``BLUE`` を実行し、1をスタックにプッシュします。  ``BLUE`` を「取り込んだまま」、 ``LIGHT`` "
"は1に8をORして9を生成します。)"

#: ../../chapter4.rst:760
msgid ""
"This definition will work when invoked in the input stream, but special "
"handling is required if we want to let ``LIGHT`` be invoked within a "
"colon definition, as in:"
msgstr ""
"この定義は入力ストリームで呼び出されたときにはうまくいきますが、コロン定義の中で ``LIGHT`` "
"が呼び出されるようにしたいのであれば、特別な処理が必要です。"

#: ../../chapter4.rst:768
msgid ""
"Even in the input stream, the use of ``EXECUTE`` here will cause a crash "
"if ``LIGHT`` is accidentally followed by something other than a defined "
"word."
msgstr ""
"入力テキストの中でさえ、ここでの ``EXECUTE`` の使用は、 ``LIGHT`` "
"の後に定義されたワード以外の何かが誤って続いた場合にクラッシュを引き起こします。"

#: ../../chapter4.rst:771
msgid ""
"The preferred technique, if you’re forced to use this particular syntax, "
"is to have ``LIGHT`` set a flag, and have ``BLUE`` determine whether that"
" flag was set, as we’ll see later on."
msgstr ""
"この特定の構文を使わざるを得ない場合には、後述のように、 ``LIGHT`` でフラグを設定し、そのフラグが設定されているかどうかを "
"``BLUE`` で判断することをお勧めします。"

#: ../../chapter4.rst:775
msgid ""
"There will be times when looking ahead in the input stream is desirable, "
"even necessary. (The proposed ``TO`` solution is often implemented this "
"way [rosen82]_.)"
msgstr ""
"入力ストリームを先読みすることが望ましい、時には必要な場合もあります。 （提案された ``TO`` 解決策はしばしばこのように実装されています "
"[rosen82]_ ）。"

#: ../../chapter4.rst:779
msgid ""
"But generally, avoid expectations. You’re setting yourself up for "
"disappointment."
msgstr "しかし、一般的には期待するのを避けてください。 それはあなた自身の失望を準備することです。"

#: ../../chapter4.rst:784
msgid "Let commands perform themselves."
msgstr "コマンドそれ自身に実行させなさい。"

#: ../../chapter4.rst:786
msgid ""
"This rule is a corollary to “Avoid expectations.” It’s one of Forth’s "
"philosophical quirks to let words do their own work. Witness the Forth "
"compiler (the function that compiles colon definitions), caricatured in  "
":numref:`fig4-7` . It has very few rules:"
msgstr ""
"この規則は「期待を避ける」の必然的な結果です。ワードに独自の働きをさせることは、Forth哲学の奇妙なことの1つです。　"
":numref:`fig4-7` の「FORTH COMPILER」(Forthコンパイラ、コロン定義をコンパイルする関数)を見てください。 "
"規則はほとんどありません。"

#: ../../chapter4.rst:796
msgid "The traditional compiler vs. the Forth compiler."
msgstr "伝統的なコンパイラ 対 Forthコンパイラ"

#: ../../chapter4.rst:798
msgid ""
"Scan for the next word in the input stream and look it up in the "
"dictionary."
msgstr "入力ストリームの次のワードをスキャンしてディクショナリで調べます。"

#: ../../chapter4.rst:801
msgid "If it’s an ordinary word, *compile* its address."
msgstr "普通のワードであれば、そのアドレスを「コンパイル」します。"

#: ../../chapter4.rst:803
msgid "If it’s an “immediate” word, *execute* it."
msgstr "「immediate」(即実行)のワードの場合は、「実行」します。"

#: ../../chapter4.rst:805
msgid ""
"If it’s not a defined word, try to convert it to a number and compile it "
"as a literal."
msgstr "定義されていないワードであれば、それを数字に変換してリテラルとしてコンパイルを試みます。"

#: ../../chapter4.rst:808
msgid "If it’s not a number, abort with an error message."
msgstr "それが数値ではない場合は、エラーメッセージを出力して中止(アボート)します。"

#: ../../chapter4.rst:810
msgid ""
"Nothing is mentioned about compiling-words such as ``IF``, ``ELSE``, "
"``THEN``, etc. The colon compiler doesn’t know about these words. It "
"merely recognizes certain words as “immediate” and executes them, letting"
" them do their own work. (See *Starting Forth*, Chapter Eleven, “How to "
"Control the Colon Compiler.”)"
msgstr "``IF``, ``ELSE``, ``THEN`` などのコンパイルワードについては何も言及されていません。コロンコンパイラはこれらのワードについて知りません。 それは単に特定のワードを「immediate」(即実行)として認識し、それらを実行して、それら自身に仕事をさせるだけです(FORTH入門 第11章 の コロンコンパイラの制御方法 P.358 s参照; *Starting Forth*, Chapter Eleven, “How to Control the Colon Compiler.”)"

#: ../../chapter4.rst:816
msgid ""
"The compiler doesn’t even “look for” semicolon to know when to stop "
"compiling. Instead it *executes* semicolon, allowing it to do the work of"
" ending the definition and shutting off the compiler."
msgstr ""
"コンパイラは、いつコンパイルを停止するかを知るためにセミコロンを「探す」ことすらしません。 "
"代わりに、セミコロンを「実行」して、定義を終了してコンパイラを停止する作業を実行できるようにします。"

#: ../../chapter4.rst:820
msgid ""
"There are two tremendous advantages to this approach. First, the compiler"
" is so simple it can be written in a few lines of code. Second, there’s "
"no limit on the number of compiling words you can add at any time, simply"
" by making them immediate. Thus, even Forth’s colon compiler is "
"extensible!"
msgstr ""
"このアプローチには2つの大きな利点があります。 まず、コンパイラは非常に単純で、数行のコードで記述できます。 "
"第二に、あなたがいつでも追加できる編集可能なワードの数に制限はありません、ただそれらをimmediate(即実行)にすることによって。 "
"これにより、Forthのコロンコンパイラでさえ拡張可能です！"

#: ../../chapter4.rst:826
msgid ""
"Forth’s text interpreter and Forth’s address interpreter also adhere to "
"this same rule."
msgstr "ForthのテキストインタプリタとForthのアドレスインタプリタも同じ規則に従います。"

#: ../../chapter4.rst:829
msgid "The following tip is perhaps the most important in this chapter:"
msgstr "この章で、おそらく最も重要なのが以下のヒントです。"

#: ../../chapter4.rst:833
msgid "Don\\'t write your own interpreter/compiler when you can use Forth\\'s."
msgstr "Forthシステムを使うことができる時は、あなた自身のインタプリタ/コンパイラを書かないでください。"

#: ../../chapter4.rst:835
msgid ""
"One class of applications answers a need for a special purpose language—a"
" self-contained set of commands for doing one particular thing. An "
"example is a machine-code assembler. Here you have a large group of "
"commands, the mnemonics, with which you can describe the instructions you"
" want assembled. Here again, Forth takes a radical departure from "
"mainstream philosophy."
msgstr ""
"あるクラスのアプリケーションは、特別な目的の言語、つまり1つの特定のことを実行するための自己完結型のコマンドのセットに対するニーズに応えます。 "
"例としては、機械語アセンブラがあります。 ここにはたくさんのコマンド群、ニーモニックがあり、それを使って組み立てたい命令を記述することができます。"
" ここでもまた、Forthは主流の哲学と果断に決別します。"

#: ../../chapter4.rst:842
msgid ""
"Traditional assemblers are special-purpose interpreters—that is, they are"
" complicated programs that scan the assembly-language listing looking for"
" recognized mnemonics such as ADD, SUB, JMP, etc., and assemble machine "
"instructions correspondingly. The Forth assembler, however, is merely a "
"lexicon of Forth words that themselves assemble machine instructions."
msgstr ""
"従来のアセンブラは特殊目的のインタプリタです。つまり、ADD、SUB、JMPなどの認識されたニーモニックを探してアセンブリ言語のリストをスキャンし、それに応じて機械語命令をアセンブルする複雑なプログラムです。"
" ただし、Forthアセンブラは、それ自体が機械命令を組み立てるForthのワードの単なる用語集です。"

#: ../../chapter4.rst:849
msgid ""
"There are many more examples of the special purpose language, each "
"specific to individual applications. For instance:"
msgstr "特殊目的言語の例は他にもたくさんあり、それぞれが個々のアプリケーションに固有のものです。 たとえば以下のようなのがあります。"

#: ../../chapter4.rst:852
msgid ""
"If you\\’re building an Adventure-type game, you\\’d want to write a "
"language that lets you create and describe monsters and rooms, etc. You "
"might create a defining word called ``ROOM`` to be used like this:"
msgstr "もしあなたがアドベンチャーゲームを構築しているのであれば、あなたは以下のように、モンスターや部屋などを作成したり記述したりすることができる言語を書きたいと思うでしょう。"

#: ../../chapter4.rst:860
msgid ""
"Then create a set of words to describe the room\\’s attributes by "
"building unseen data structures associated with the room:"
msgstr "次に、部屋に関連付けられている目に見えないデータ構造を構築して、部屋の属性を説明する一連のワードを作成します。"

#: ../../chapter4.rst:870
msgid ""
"The commands of this game-building language can simply be Forth words, "
"with Forth as the interpreter."
msgstr "このゲーム構築言語のコマンドは、Forthをインタプリタとした、単純にForthのワードにすることができます。"

#: ../../chapter4.rst:873
msgid ""
"If you’re working with Programmable Array Logic (PAL) devices, you’d like"
" a form of notation that lets you describe the behavior of the output "
"pins in logical terms, based on the states of the input pins. A PAL "
"programmer was written with wonderful simplicity in Forth by Michael "
"Stolowitz [stolowitz82]_ ."
msgstr ""
"プログラマブルアレイロジック（PAL）デバイスを使用している場合は、入力ピンの状態に基づいて、出力ピンの動作を論理的に表現できる形式の表記法が必要です。"
" PALライターは、Michael Stolowitz [stolowitz82]_ によってForthで非常にシンプルに書かれました。"

#: ../../chapter4.rst:880
msgid ""
"If you must create a series of user menus to drive your application, you "
"might want to first develop a menu-compiling language. The words of this "
"new language allow an application programmer to quickly program the "
"needed menus—while hiding information about how to draw borders, move the"
" cursor, etc."
msgstr ""
"アプリケーションを操作するために一連のユーザメニューを作成する必要がある場合は、まずメニューコンパイル言語を開発することをお勧めします。 "
"この新しい言語の言葉は、アプリケーションプログラマが必要なメニューをすばやくプログラムできるようにしながら、罫線の描画方法、カーソルの移動方法などに関する情報を隠します。"

#: ../../chapter4.rst:886
msgid ""
"All of these examples can be coded in Forth as lexicons, using the normal"
" Forth interpreter, without having to write a special-purpose interpreter"
" or compiler."
msgstr "これらの例はすべて、通常のForthインタプリタを使用して、特殊目的のインタプリタやコンパイラを記述することなく、Forthの用語集としてコーディングできます。"

#: ../../chapter4.rst:906 ../../chapter4.rst:1745
msgid "**Moore**:"
msgstr "ムーアは言います。"

#: ../../chapter4.rst:891
msgid ""
"A simple solution is one that does not obscure the problem with "
"irrelevancies.  It\\'s conceivable that something about the problem "
"requires"
msgstr "シンプルな解決策は、関連性のない問題をあいまいにしないものです。 問題について何かが必要であると考えられます。"

#: ../../chapter4.rst:895
msgid ""
"a unique interpreter. But every time you see a unique interpreter, it "
"implies that there is something particularly awkward about the problem. "
"And that is almost never the case."
msgstr "それは特殊なインタプリタです。しかし、あなたが特殊なインタプリタを見るたびに、それは問題に関して特に厄介な何かがあることを意味します。厄介でない事はまずありません。"

#: ../../chapter4.rst:899
msgid ""
"If you write your own interpreter, the interpreter is almost certainly "
"the most complex, elaborate part of your entire application. You have "
"switched from solving a problem to writing an interpreter."
msgstr "あなたがあなた自身のインタプリタを書くのであれば、インタプリタはほぼ確実にあなたのアプリケーション全体の中で最も複雑で精巧な部分です。 あなたは問題解決よりもインタプリタを書くことへ集中します。"

#: ../../chapter4.rst:903
msgid ""
"I think that programmers like to write interpreters. They like to do "
"these elaborate difficult things. But there comes a time when the world "
"is going to have to quit programming keypads and converting numbers to "
"binary, and start solving problems."
msgstr "プログラマはインタプリタを書くのが好きだと思います。 彼らはこの手の手の込んだ難しいことをやりたいのです。 しかし、早晩、キーパッドのプログラミングや数値の2進数への変換をやめて、問題そのものを解決し始めなければならなくなる時が来ます。"

#: ../../chapter4.rst:909
msgid "Algorithms and Data Structures"
msgstr "アルゴリズムとデータ構造"

#: ../../chapter4.rst:911
msgid ""
"In :doc:`Chapter Two<chapter2>` we learned how to describe a problem\\’s "
"requirements in terms of interfaces and rules. In this section we\\’ll "
"refine the conceptual model for each component into clearly defined "
"algorithms and data structures."
msgstr ":doc:`第２章<chapter2>` では、インターフェースと規則の観点から問題の要件を記述する方法を学びました。 この節では、各コンポーネントの概念モデルを、明確に定義されたアルゴリズムとデータ構造に改良します。"

# wikipediaより
# al-Khowarizmi アル＝フワーリズミー
# 9世紀前半にアッバース朝時代のバグダードで活躍したイスラム科学の学者
#: ../../chapter4.rst:917
msgid ""
"An algorithm is a procedure, described as a finite number of rules, for "
"accomplishing a certain task. The rules must be unambiguous and "
"guaranteed to terminate after a finite number of applications. (The word "
"is named for the ninth century Persian mathematician al-Khowarizmi.)"
msgstr ""
"アルゴリズムは、特定のタスクを実行するための、有限数の規則として記述された手順です。 "
"規則は明確で、有限数の適用後に終了することが保証されている必要があります（アルゴリズムという言葉は、9世紀のペルシャの数学者アル・フワーリズミーに由来します）。"

#: ../../chapter4.rst:922
msgid ""
"An algorithm lies halfway between the imprecise directives of human "
"speech, such as “Please sort these letters chronologically,” and the "
"precise directives of computer language, such as ``BEGIN 2DUP < IF …`` "
"etc. The algorithm for sorting letters chronologically might be this:"
msgstr "「これらの文字を年代順に並べ替えてください」など、人間が言う不正確な指令と、 ``BEGIN 2DUP < IF …`` などのコンピュータ言語の正確な指令との中間に、以下のようにアルゴリズムがあります。 "

#: ../../chapter4.rst:927
msgid "Take an unsorted letter and note its date."
msgstr "ソートされていない手紙を受け取り、その日付を書き留めます。"

#: ../../chapter4.rst:929
msgid "Find the correspondence folder for that month and year."
msgstr "対応する年・月の連絡先フォルダーを見つけます。"

#: ../../chapter4.rst:931
msgid ""
"Flip through the letters in the folder, starting from the front, until "
"you find the first letter dated later than your current letter."
msgstr "あなたの手元の手紙より後の日付の最初の手紙が見つかるまで、フォルダの先頭から手紙をめくっていきます。"

#: ../../chapter4.rst:934
msgid ""
"Insert your current letter just in front of the letter dated later. (If "
"the folder is empty, just insert the letter.)"
msgstr "あなたの手元の手紙をその手紙の直前に挿入します（フォルダが空の場合は、単に手紙をフォルダに入れるだけです。）"

#: ../../chapter4.rst:937
msgid ""
"There may be several possible algorithms for the same job. The algorithm "
"given above would work fine for folders containing ten or fewer letters, "
"but for folders with a hundred letters, you’d probably resort to a more "
"efficient algorithm, such as this:"
msgstr "同じ仕事のためにいくつかの可能なアルゴリズムがあるかもしれません。 上記のアルゴリズムは、10通入りのフォルダではうまく機能しますが、100通入りのフォルダでは、おそらく次のようなより効率的なアルゴリズムに頼ることになるでしょう。"

#: ../../chapter4.rst:942 ../../chapter4.rst:944
msgid "(same)"
msgstr "同上"

#: ../../chapter4.rst:946
msgid ""
"If the date falls within the first half of the month, open the folder a "
"third of the way in. If the letter you find there is dated later than "
"your current letter, search forward until you find a letter dated the "
"same or before your current letter. Insert your letter at that point. If "
"the letter you find is dated earlier than your current letter, search "
"backward…"
msgstr ""
"日付がその月の前半にあたる場合は、そのフォルダの手前3分の1以内を開きます。その時見つかった手紙が手元の手紙より後の日付である場合は、同じ日付または手元の日付より前の日付の手紙を探し、その時点で手元の手紙を挿入します。"
" 見つかった手紙が現在の手紙より前の日付である場合は、後方検索…"

#: ../../chapter4.rst:953
msgid ""
"… You get the point. This second algorithm is more complicated than the "
"first. But in execution it will require fewer steps on the average "
"(because you don’t have to search clear from the beginning of the folder "
"every time) and therefore can be performed faster."
msgstr ""
"…あなたは手紙を挿入する場所を見つけます。この2番目のアルゴリズムは最初のものよりも複雑です。 "
"ただし、実行時には、平均して必要な手順が少なくなり（毎回フォルダの先頭から検索開始する必要がないため）、実行時間が短縮されます。"

#: ../../chapter4.rst:958
msgid ""
"A data structure is an arrangement of data or locations for data, "
"organized especially to match the problem. In the last example, the file "
"cabinet containing folders and the folders containing individual letters "
"can be thought of as data structures.  The new conceptual model includes "
"the filing cabinets and folders (data structures) plus the steps for "
"doing the filing (algorithms)."
msgstr ""
"データ構造とは、特に問題に合わせて編成された、データの配置またはデータの場所です。 "
"最後の例では、フォルダを含むファイルキャビネットと個々の手紙を含むフォルダはデータ構造として考えることができます。 "
"新しい概念モデルには、ファイリングキャビネットとファイリングフォルダ（データ構造）、およびファイリングを実行するための手順（アルゴリズム）が含まれています。"

#: ../../chapter4.rst:967
msgid "Calculations vs. Data Structures vs. Logic"
msgstr "計算 対 データ構造 対 ロジック"

#: ../../chapter4.rst:969
msgid ""
"We’ve stated before that the best solution to a problem is the simplest "
"adequate one; for any problem we should strive for the simplest approach."
msgstr "前に述べたように、問題に対する最善の解決策は最もシンプルで適切なものです。 どんな問題でも、私たちは最もシンプルなアプローチのために努力すべきです。"

#: ../../chapter4.rst:973
msgid "Suppose we must write code to fulfill this specification:"
msgstr "次の仕様を満たすコードを書かなければならないとします。"

#: ../../chapter4.rst:981
msgid "There are three approaches we could take:"
msgstr "私たちはがとることのできる3つのアプローチがあります。"

#: ../../chapter4.rst:986
msgid "Calculation"
msgstr "計算"

#: ../../chapter4.rst:992 ../../chapter4.rst:1225
msgid "Data Structure"
msgstr "データ構造"

#: ../../chapter4.rst:1000
msgid "Logic"
msgstr "ロジック"

#: ../../chapter4.rst:1002
msgid ""
"In this problem, calculation is simplest. Assuming it is also adequate "
"(speed is not critical), calculation is best."
msgstr "この問題では、計算が最もシンプルです。 十分仕様を満たしていると仮定すると（速度は重要ではありません）、計算が最適です。"

#: ../../chapter4.rst:1005
msgid ""
"The problem of converting angles to sines and cosines can be implemented "
"more simply (at least in terms of lines of code and object size) by "
"calculating the answers than by using a data structure. But for many "
"applications requiring trig, it’s faster to look up the answer in a table"
" stored in memory. In this case, the simplest *adequate* solution is "
"using the data structure."
msgstr ""
"角度をサインとコサインに変換する問題は、データ構造を使用するよりも答えを計算することによって（少なくともコード行とオブジェクトサイズに関して）より簡単に実装できます。"
" しかし、しょっちゅう変換が必要な多くのアプリケーションでは、メモリに格納された表で答えを調べる方が速いです。 "
"この場合、最もシンプルな「適切な」解決策はデータ構造を使用することです。"

#: ../../chapter4.rst:1012
msgid ""
"In :doc:`Chapter Two<chapter2>` we introduced the telephone rate problem."
" In that problem the rates appeared to be arbitrary, so we designed a "
"data structure:"
msgstr ""
":doc:`第２章<chapter2>` では電話料金の問題を紹介しました。 "
"その問題では、料金レートは任意であるように見えたので、データ構造を設計しました。"

#: ../../chapter4.rst:1017
msgid "Full Rate"
msgstr "Full Rate"

#: ../../chapter4.rst:1017
msgid "Lower Rate"
msgstr "Lower Rate"

#: ../../chapter4.rst:1017
msgid "Lowest Rate"
msgstr "Lowest Rate"

#: ../../chapter4.rst:1019
msgid "First Min."
msgstr "First Min."

#: ../../chapter4.rst:1019
msgid ".30"
msgstr ".30"

#: ../../chapter4.rst:1019
msgid ".22"
msgstr ".22"

#: ../../chapter4.rst:1019 ../../chapter4.rst:1021
msgid ".12"
msgstr ".12"

#: ../../chapter4.rst:1021
msgid "Add’1 Mins."
msgstr "Add’1 Mins."

#: ../../chapter4.rst:1021
msgid ".10"
msgstr ".10"

#: ../../chapter4.rst:1021
msgid ".06"
msgstr ".06"

#: ../../chapter4.rst:1024
msgid ""
"Using a data structure was simpler than trying to invent a formula by "
"which these values could be calculated. And the formula might prove wrong"
" later. In this case, table-driven code is easier to maintain."
msgstr ""
"データ構造を使用することは、これらの値を計算することができる式を発明することを試みるよりも簡単でした。 "
"そして式は後で不可である事が判明するかもしれません。 この場合、表駆動型コードの方が保守が簡単です。"

#: ../../chapter4.rst:1029
msgid ""
"In :doc:`Chapter Three<chapter3>` we designed a keystroke interpreter for"
" our Tiny Editor using a decision table:"
msgstr ":doc:`第3章<chapter3>` では、決定表を使ってタイニー・エディタ用のキーストロークインタプリタを設計しました。"

#: ../../chapter4.rst:1036
msgid "Key"
msgstr "Key"

#: ../../chapter4.rst:1037
msgid "Not-Inserting"
msgstr "Not-Inserting"

#: ../../chapter4.rst:1038
msgid "Inserting"
msgstr "Inserting"

#: ../../chapter4.rst:1039
msgid "Ctrl-D"
msgstr "Ctrl-D"

#: ../../chapter4.rst:1040
msgid "DELETE"
msgstr "DELETE"

#: ../../chapter4.rst:1041 ../../chapter4.rst:1044
msgid "INSERT-OFF"
msgstr "INSERT-OFF"

#: ../../chapter4.rst:1042
msgid "Ctrl-I"
msgstr "Ctrl-I"

#: ../../chapter4.rst:1043
msgid "INSERT-ON"
msgstr "INSERT-ON"

#: ../../chapter4.rst:1045
msgid "backspace"
msgstr "backspace"

#: ../../chapter4.rst:1046
msgid "BACKWARD"
msgstr "BACKWARD"

#: ../../chapter4.rst:1047
msgid "INSERT<"
msgstr "INSERT<"

#: ../../chapter4.rst:1048
msgid "etc."
msgstr "etc."

#: ../../chapter4.rst:1052
msgid "We could have achieved this same result with logic:"
msgstr "ロジックでも同じ結果が得られたはずです。"

#: ../../chapter4.rst:1066
msgid ""
"but the logic is more confusing. And the use of logic to express such a "
"multi-condition algorithm gets even more convoluted when a table was not "
"used in the original design."
msgstr ""
"しかしロジックはもっと混乱しています。 "
"また、元の設計で表が使用されていなかった場合、このような複数条件アルゴリズムを表現するためのロジックの使用はさらに複雑になります。"

#: ../../chapter4.rst:1070
msgid ""
"The use of logic becomes advisable when the result is not calculable, or "
"when the decision is not complicated enough to warrant a decision table. "
":doc:`Chapter Eight<chapter8>` is devoted to the issue of minimizing the "
"use of logic in your programs."
msgstr ""
"結果が計算できない場合、または決定が決定表を正当化するほど複雑でない場合は、ロジックの使用が推奨されます。:doc:`第８章<chapter8>`"
" ではあなたのプログラムでのロジックの使用を最小限にするという問題に専念しています。"

#: ../../chapter4.rst:1077
msgid ""
"In choosing which approach to apply towards solving a problem, give "
"preference in the following order:"
msgstr "問題解決にどのアプローチを適用するかを選択する際には、次の順序で優先順位を付けてください。"

#: ../../chapter4.rst:1080
msgid "calculation (except when speed counts)"
msgstr "計算(スピードカウント時を除く)"

#: ../../chapter4.rst:1081
msgid "data structures"
msgstr "データ構造"

#: ../../chapter4.rst:1082
msgid "logic"
msgstr "ロジック"

#: ../../chapter4.rst:1084
msgid ""
"Of course, one nice feature of modular languages such as Forth is that "
"the actual implementation of a component—whether it uses calculation, "
"data structures, or logic—doesn’t have to be visible to the rest of the "
"application."
msgstr "もちろん、Forthなどのモジュール式言語の優れた機能の1つは、コンポーネントの実際の実装（計算、データ構造、ロジックのいずれを使用する場合でも）が、アプリケーションの他の部分から見えなくてもよいことです。"

#: ../../chapter4.rst:1090
msgid "Solving a Problem: Computing Roman Numerals"
msgstr "ローマ数字の問題とその解決"

#: ../../chapter4.rst:1092
msgid ""
"In this section we’ll attempt to demonstrate the process of designing a "
"lexicon. Rather than merely present the problem and its solution, I’m "
"hoping we can crack this problem together. (I kept a record of my thought"
" processes as I solved this problem originally.) You’ll see elements of "
"the problem-solving guidelines previously given, but you’ll also see them"
" being applied in a seemingly haphazard order—just as they would be in "
"reality."
msgstr ""
"この節では、用語集を設計するプロセスを説明します。 "
"単に問題とその解決策を提示するのではなく、私は一緒になってこの問題を解決できることを願っています(この問題を最初に解決したときは、自分の思考プロセスを記録していました)。あなたは前述の問題解決ガイドラインの要素をここでも見ることになりますが、それらが一見不自然な順序で適用されるを見ることになるでしょう。でも現実はこの順序なのです。"

#: ../../chapter4.rst:1100
msgid ""
"Here goes: The problem is to write a definition that consumes a number on"
" the stack and displays it as a Roman numeral."
msgstr "さあ初めましょう。問題は、スタック上の数を消費し、それをローマ数字として出力する定義を書くことです。"

#: ../../chapter4.rst:1103
msgid ""
"This problem most likely represents a component of a larger system. We’ll"
" probably end up defining several words in the course of solving this "
"problem, including data structures. But this particular lexicon will "
"include only one name, ``ROMAN``, and it will take its argument from the "
"stack. (Other words will be internal to the component.)"
msgstr ""
"この問題は、大規模システムのコンポーネントの一つである可能性が最も高いです。 "
"この問題を解決する過程で、データ構造を含むいくつかのワードを定義することになるでしょう。 しかし、この特定の用語集には ``ROMAN`` "
"という名前が1つだけ含まれており、スタックから引数を取ります(他のワードはコンポーネントの内部にあります)。"

#: ../../chapter4.rst:1109
msgid ""
"Having thus decided on the external syntax, we can now proceed to devise "
"the algorithms and data structures."
msgstr "このように外部構文を決定したので、次にアルゴリズムとデータ構造を考え出すことに進むことができます。"

#: ../../chapter4.rst:1112
msgid ""
"We’ll follow the scientific method—we’ll observe reality, model a "
"solution, test it against reality, modify the solution, and so on. We’ll "
"begin by recalling what we know about Roman numerals."
msgstr ""
"私たちは科学的な方法に従います。現実を観察し、解決策をモデル化し、現実に照らし合わせて検証し、解決策を修正します。 "
"ローマ数字について私たちが知っていることを思い出すことから始めましょう。"

#: ../../chapter4.rst:1116
msgid ""
"Actually, we don’t remember any formal rules about Roman numerals. But if"
" you give us a number, we can make a Roman numeral out of it. We know how"
" to do it—but we can’t yet state the procedure as an algorithm."
msgstr ""
"実際、私たちはローマ数字に関する正式な規則は覚えていません。 しかし、あなたが私たちに数字を与えれば、私たちはそれからローマ数字を作ることができます。\n"
"私たちその方法を知っていますが、まだその手順をアルゴリズムとして述べることができません。"

#: ../../chapter4.rst:1120
msgid "So, let’s look at the first ten Roman numerals:"
msgstr "それでは、最初の10個のローマ数字を見てみましょう。"

#: ../../chapter4.rst:1135
msgid ""
"We make a few observations. First, there’s the idea of a tally, where we "
"represent a number by making that many marks (3 = III). On the other "
"hand, special symbols are used to represent groups (5 = V). In fact, it "
"seems we can’t have more than three I’s in a row before we use a larger "
"symbol."
msgstr "少々観察してみます。まず、tally(訳注:数え方の一つ。日本でいう正の字)というアイデアがあります。ここでは、その数を多くすることで数字を表します（3 = III）。 一方、特殊記号はグループを表すために使用されます（5 = V）。 実際、特殊シンボルを使用する前に、3つ以上の「I」が連続していることはできないようです。"

#: ../../chapter4.rst:1141
msgid ""
"Second, there’s a symmetry around five. There’s a symbol for five (V), "
"and a symbol for ten (X). The pattern I, II, III repeats in the second "
"half, but with a preceding V."
msgstr ""
"第二に、「5」の前後に対称性があります。 「5」の記号「V」と「10」の記号「X」があります。 "
"パターンI、II、IIIは後半に繰り返されますが、先行するVが付きます。"

#: ../../chapter4.rst:1145
msgid ""
"One-less-than-five is written IV, and one-less-than-ten is written IX. It"
" seems that putting an “I” in front of a larger-value symbol is like "
"saying “one-less-than…”"
msgstr "「5より1つ小さい」は「IV」と書かれ、「10より1つ小さい」は「IX」と書かれます。 大きな値のシンボルの前に「I」を置くことは、「…より1つ小さい」と言っているようです。"

#: ../../chapter4.rst:1149
msgid ""
"These are vague, hazy observations. But that’s alright. We don’t have the"
" whole picture yet."
msgstr "これらは曖昧でぼんやりとした観察です。 しかし、それで大丈夫です。 私たちにはまだ全体像はわかりません。"

#: ../../chapter4.rst:1152
msgid "Let’s study what happens above ten:"
msgstr "10以上で何が起こるのか調べてみましょう。"

#: ../../chapter4.rst:1167
msgid ""
"This is exactly the pattern as before, with an extra “X” in front. So "
"there’s a repeating cycle of ten, as well."
msgstr "これは前とまったく同じパターンで、前に余分な「X」が付きます。 そう、それは全くもって10のサイクルの繰り返しです。"

#: ../../chapter4.rst:1171
msgid ""
"If we look at the twenties, they’re the same, with two “X”s; the thirties"
" with three “X”s. In fact, the number of “X” is the same as the number in"
" the tens column of the original decimal number."
msgstr ""
"「20」代を見ると、2つの「X」が付いていて同じです。 "
"「30」代は「X」が3個付いています。実際、「X」の数は、元の10進数の10桁目の数と同じです。"

#: ../../chapter4.rst:1175
msgid ""
"This seems like an important observation: we can decompose our decimal "
"number into decimal digits, and treat each digit separately. For "
"instance, 37 can be written as"
msgstr ""
"これは重要な観察のように思えます。つまり私たちは10進数値を10進数字に分解し、それぞれの数字を別々に扱うことができます。 "
"例えば、37(三十七)は以下のように書くことができます。"

#: ../../chapter4.rst:1179
msgid "XXX (thirty)"
msgstr "XXX (三十)"

#: ../../chapter4.rst:1181
msgid "followed by"
msgstr "に続いて"

#: ../../chapter4.rst:1183
msgid "VII (seven)"
msgstr "VII (七)"

#: ../../chapter4.rst:1185
msgid ""
"It may be premature, but we can already see a method by which Forth will "
"let us decompose a number into decimal digits—with modulo division by "
"ten. For instance, if we say"
msgstr "時期尚早かもしれませんが、私たちはすでにForthが数値を10進数に分解する方法を見る事ができます。たとえば、Forthでは以下のようにして数値を数字に分解します(10で割った剰余)。"

#: ../../chapter4.rst:1193
msgid ""
"we’ll get a 7 and a 3 on the stack (the three—being the quotient—is on "
"top.)"
msgstr "スタックに7と3が得られます（商である3が一番上になります）。"

#: ../../chapter4.rst:1196
msgid ""
"But these observations raise a question: What about below ten, where "
"there is no ten’s place? Is this a special case? Well, if we consider "
"that each “X” represents ten, then the absence of “X” represents zero. So"
" it’s *not* a special case. Our algorithm works, even for numbers less "
"than ten."
msgstr ""
"しかし、これらの観察には疑問を投げかけます。「10」以下では「10」の位の場所がありません。これは特別な場合でしょうか？各「X」が10を表すと考えるならば、「X」の不在はゼロを表します。"
" だから特別なケースではありません。 私たちのアルゴリズムは、10未満の数でも動作します。"

#: ../../chapter4.rst:1202
msgid ""
"Let’s continue our observations, paying special attention to the cycles "
"of ten. We notice that forty is “XL.” This is analogous to 4 being “IV,” "
"only shifted by the value of ten. The “X” before the “L” says “ten-less-"
"than-fifty.” Similarly,"
msgstr "「10」のサイクルに特に注意を払いながら、観察を続けましょう。 40が「XL」であることがわかります。これは、4が「IV」であるのに似ていますが、10の値だけシフトされています。 「L」の前の「X」は、「50より10小さい」を意味します。"

#: ../../chapter4.rst:1216
msgid ""
"Apparently the same patterns apply for any decimal digit—only the symbols"
" themselves change. Anyway, it’s clear now that we’re dealing with an "
"essentially decimal system."
msgstr "どうやら同じパターンがどんな10進数にもあてはまる。但し、シンボルだけが変わる。 とにかく、今では基本的に10進法を扱っていることは明らかです。"

#: ../../chapter4.rst:1220
msgid ""
"If pressed to do so, we could even build a model for a system to display "
"Roman numerals from 1 to 99, using a combination of algorithm and data "
"structure."
msgstr "これを押し進めれば、アルゴリズムとデータ構造の組み合わせを使用して、1から99までのローマ数字を出力するためのシステムのモデルを構築することさえ可能です。"

#: ../../chapter4.rst:1228
msgid "One`s Table"
msgstr "One`s Table"

#: ../../chapter4.rst:1228
msgid "Ten`s Table"
msgstr "Ten`s Table"

#: ../../chapter4.rst:1232
msgid "1"
msgstr "1"

#: ../../chapter4.rst:1232 ../../chapter4.rst:1287 ../../chapter4.rst:1554
msgid "I"
msgstr "I"

#: ../../chapter4.rst:1232 ../../chapter4.rst:1290 ../../chapter4.rst:1555
msgid "X"
msgstr "X"

#: ../../chapter4.rst:1234
msgid "2"
msgstr "2"

#: ../../chapter4.rst:1234
msgid "II"
msgstr "II"

#: ../../chapter4.rst:1234
msgid "XX"
msgstr "XX"

#: ../../chapter4.rst:1236
msgid "3"
msgstr "3"

#: ../../chapter4.rst:1236
msgid "III"
msgstr "III"

#: ../../chapter4.rst:1236
msgid "XXX"
msgstr "XXX"

#: ../../chapter4.rst:1238
msgid "4"
msgstr "4"

#: ../../chapter4.rst:1238
msgid "IV"
msgstr "IV"

#: ../../chapter4.rst:1238
msgid "XL"
msgstr "XL"

#: ../../chapter4.rst:1240
msgid "5"
msgstr "5"

#: ../../chapter4.rst:1240 ../../chapter4.rst:1289 ../../chapter4.rst:1554
msgid "V"
msgstr "V"

#: ../../chapter4.rst:1240 ../../chapter4.rst:1292 ../../chapter4.rst:1555
msgid "L"
msgstr "L"

#: ../../chapter4.rst:1242
msgid "6"
msgstr "6"

#: ../../chapter4.rst:1242
msgid "VI"
msgstr "VI"

#: ../../chapter4.rst:1242
msgid "LX"
msgstr "LX"

#: ../../chapter4.rst:1244
msgid "7"
msgstr "7"

#: ../../chapter4.rst:1244
msgid "VII"
msgstr "VII"

#: ../../chapter4.rst:1244
msgid "LXX"
msgstr "LXX"

#: ../../chapter4.rst:1246
msgid "VIII"
msgstr "VIII"

#: ../../chapter4.rst:1246
msgid "LXXX"
msgstr "LXXX"

#: ../../chapter4.rst:1248
msgid "9"
msgstr "9"

#: ../../chapter4.rst:1248
msgid "IX"
msgstr "IX"

#: ../../chapter4.rst:1248
msgid "XC"
msgstr "XC"

#: ../../chapter4.rst:1252
msgid "Algorithm"
msgstr "アルゴリズム"

#: ../../chapter4.rst:1254
msgid ""
"Divide ``n`` by 10. The quotient is the tens’ column digit; the remainder"
" is the ones’ column digit. Look up the ten’s digit in the tens’ table "
"and print the corresponding symbol pattern. Look up the ones’ digit in "
"the one’s table and print that corresponding symbol pattern."
msgstr "nを10で割ります。商は10の桁です。 余りは1の桁です。 10の位の表で10の位の数字を検索し、対応する記号パターンを出力します。 1の位の表で1の位の数字を調べて、対応する記号パターンを出力します。"

#: ../../chapter4.rst:1260
msgid ""
"For example, if the number is 72, the quotient is 7, the remainder is 2. "
"7 in the tens’ table corresponds to “LXX,” so print that. 2 in the ones’ "
"column corresponds to “II,” so print that. The result:"
msgstr ""
"例えば、数が72であれば、商は7で、余りは2です。10の位表の7は「LXX」に対応するので、それを出力します。 "
"1の位の表の2が「II」に対応するので、それを出力してください。 その結果は以下です。"

#: ../../chapter4.rst:1268
msgid ""
"We’ve just constructed a model that works for numbers from one to 99. Any"
" higher number would require a hundreds’ table as well, along with an "
"initial division by 100."
msgstr "私たちは、1から99までの数字で機能するモデルを作成しました。それより大きい数字でも、100での最初の除算とともに、百の位の表も必要になります。"

#: ../../chapter4.rst:1272
msgid ""
"The logical model just described might be satisfactory, as long as it "
"does the job. But somehow it doesn’t seem we’ve fully solved the problem."
" We avoided figuring out how to produce the basic pattern by storing all "
"possible combinations in a series of tables. Earlier in this chapter we "
"observed that calculating an answer, if it’s possible, can be easier than"
" using a data structure."
msgstr ""
"ここで説明した論理モデルは、それが仕事をしている限りは問題ないかもしれません。 しかし、なぜか私たちが問題を完全に解決したようには思えません。 "
"一連の表にすべての可能な組み合わせを格納することによって基本的なパターンを作成する方法を考え出すのを避けました。 "
"この章の前半では、可能であれば、データ構造を使用するよりも答えを計算する方が簡単であることを確認しました。"

#: ../../chapter4.rst:1279
msgid ""
"Since this section deals with devising algorithms, let’s go all the way. "
"Let’s look for a general algorithm for producing any digit, using only "
"the elementary set of symbols. Our data structure should contain only "
"this much information:"
msgstr ""
"この節ではアルゴリズムの考案について説明しますので、最後までやりましょう。 "
"基本的な記号セットだけを使用して、任意の数字を生成するための一般的なアルゴリズムを探してみましょう。 "
"私たちのデータ構造には、以下の情報が含まれているはずです。"

#: ../../chapter4.rst:1293 ../../chapter4.rst:1556
msgid "C"
msgstr "C"

#: ../../chapter4.rst:1295 ../../chapter4.rst:1556
msgid "D"
msgstr "D"

#: ../../chapter4.rst:1296 ../../chapter4.rst:1557 ../../chapter4.rst:1578
msgid "M"
msgstr "M"

#: ../../chapter4.rst:1300
msgid ""
"In listing the symbols, we’ve also *organized* them in a way that seems "
"right. The symbols in the left column are all multiples of ten; the "
"symbols in the right column are multiples of five. Furthermore, the "
"symbols in each row have ten times the value of the symbols directly "
"above them."
msgstr ""
"正しいと思われる方法でシンボルの配列を「整理」してみました。左の列の記号はすべて10の倍数です。 右側の列の記号は5の倍数です。 "
"さらに、各行のシンボルは、そのすぐ上のシンボルの10倍の値を持ちます。"

#: ../../chapter4.rst:1306
msgid ""
"Another difference, the symbols in the first column can all be combined "
"in multiples, as “XXXIII.” But you can’t have multiples of any of the "
"right-column symbols, such as VVV. Is this observation useful? Who knows?"
msgstr ""
"もう1つの違いは、最初の列の記号をすべて「XXXIII」のように倍数で組み合わせることができるということです。ただし、VVVのように、右の列の記号の倍数を指定することはできません。"
" この観察は使えますか？ みんな分かってる？"

# ONERS maybe one-roman s, FIVERS maybe five-roman s.
#: ../../chapter4.rst:1311
msgid ""
"Let’s call the symbols in the left column ``ONERS`` and in the right "
"column ``FIVERS``. The ``ONERS`` represent the values 1, 10, 100, and "
"1,000; that is, the value of one in every possible decimal place. The "
"``FIVERS`` represent 5, 50, and 500; that is, the value of five in every "
"possible decimal place."
msgstr ""
"左の列のシンボルを ``ONERS`` と呼び、右の列のシンボルを ``FIVERS`` と呼ぶことにしましょう。 ``ONERS`` "
"は値1、10、100、1000を表します。つまり10進数で配置可能な「1」のいずれかです。 ``FIVERS`` "
"は5、50、500を表します。つまり10進数で配置可能な「５」のいずれかです。"

#: ../../chapter4.rst:1317
msgid ""
"Using these terms, instead of the symbols themselves, we should be able "
"to express the algorithm for producing any digit. (We’ve factored out the"
" actual symbols from the *kind* of symbols.) For instance, we can state "
"the following preliminary algorithm:"
msgstr "シンボル自体の代わりにこれらの語を使用して、任意の数字を生成するためのアルゴリズムを表現できるはずです（なお、「種類」のシンボルから実際のシンボルを除外しています）。たとえば、次の予備的なアルゴリズムを述べることができます。"

#: ../../chapter4.rst:1323
msgid ""
"For any digit, print as many ``ONERS`` as necessary to add up to the "
"value."
msgstr "どの桁でも、値を合計するのに必要なだけの数の ``ONERS`` を出力します。"

#: ../../chapter4.rst:1326
msgid ""
"Thus, for 300 we get “CCC,” for 20 we get “XX” for one we get “I.” And "
"for 321 we get “CCCXXI.”"
msgstr "したがって、300の場合は「CCC」、20の場合は「XX」、1の場合は「I」になります。ゆえに、321の場合は「CCCXXI」になります。"

#: ../../chapter4.rst:1329
msgid ""
"This algorithm works until the digit is 4. Now we’ll have to expand our "
"algorithm to cover this exception\\:"
msgstr "このアルゴリズムは、数字が4になるまで機能します。そして今や、以下の例外をカバーするようにアルゴリズムを拡張する必要があります。"

#: ../../chapter4.rst:1332
msgid ""
"Print as many ``ONERS`` as necessary to add up to the value, but if the "
"digit is 4, print a ``ONER`` then a ``FIVER``. Hence, 40 is XL; 4 is IV."
msgstr ""
"値を足すために必要なだけ ``ONERS`` を出力しますが、数字が4の場合は ``ONER`` を出力してから ``FIVER`` "
"を出力します。 したがって、40は「XL」です。 4は「IV」です。"

# FIVER is five-roman
#: ../../chapter4.rst:1336
msgid ""
"This new rule works until the digit is 5. As we noticed before, digits of"
" five and above begin with a ``FIVER`` symbol. So we expand our rule "
"again:"
msgstr ""
"この新しい規則は、数字が5になるまで機能します。前に気づいたように、5以上の数字は ``FIVER`` 記号で始まります。 "
"それでは、再び規則を拡張します。"

#: ../../chapter4.rst:1340
msgid ""
"If the digit is 5 or more, begin with a ``FIVER`` and subtract five from "
"the value; otherwise do nothing. Then print as many ``ONERS`` as "
"necessary to add up to the value. But if the digit is 4, print only a "
"``ONER`` and a ``FIVER``."
msgstr "数字が5以上の場合、 ``FIVER`` で始めて値から5を引いてください。 それ以外の場合は何もしません。 それから値を合計するのに必要なだけ多くの ``ONERS`` を出力します。 しかし、数字が4の場合、 ``ONER`` と ``FIVER`` だけを出力します。"

#: ../../chapter4.rst:1345
msgid ""
"This rule works until the digit is 9. In this case, we must print a "
"``ONER`` preceding a—what? A ``ONER`` from the next higher decimal place "
"(the next row below). Let’s call this a ``TENER``. Our complete model, "
"then is:"
msgstr ""
"この規則は、数字が9になるまで機能します。この場合、私たちは、より高い位(表の次の行)の ``ONER`` の前に ``ONER`` "
"を出力しなければなりません。これを ``TENER`` と呼ぶことにしましょう。この規則の完全なモデルは以下です。"

#: ../../chapter4.rst:1349
msgid ""
"If the digit is 5 or more, begin with a ``FIVER`` and subtract five from "
"the value; otherwise do nothing. Then, print as many ``ONERS`` as "
"necessary to add up to the value. But if the digit is 4, print only a "
"``ONER`` and a ``FIVER``, or if it's 9, print only a ``ONER`` and a "
"``TENER``."
msgstr ""
"数字が5以上の場合、 ``FIVER`` で始めて値から5を引いてください。 それ以外の場合は何もしません。 "
"それから、値を合計するのに必要なだけ多くの ``ONERS`` を出力します。 しかし、数字が4の場合は ``ONER`` と ``FIVER``"
" だけを出力し、9の場合は ``ONER`` と ``TENER`` だけを出力します。"

#: ../../chapter4.rst:1355
msgid ""
"We now have an English-language version of our algorithm. But we still "
"have some steps to go before we can run it on our computer."
msgstr "今や私たちのアルゴリズムの文章版があります。しかし、それをコンピュータ上で実行できるようにするにはまだいくつかの段階があります。"

#: ../../chapter4.rst:1359
msgid ""
"In particular, we have to be more specific about the exceptions. We can’t"
" just say,"
msgstr "特に、例外についてはもっと具体的に説明する必要があります。 私たちはまだ説明することができません。"

#: ../../chapter4.rst:1362
msgid "Do a, b, and c. **But** in such and such a case, do something different."
msgstr "aとbとcをしてください。 **しかし** ある場合と、とある場合には、違うことをしてください。"

# うーん意味分からん。
#: ../../chapter4.rst:1364
msgid "because the computer will do a, b, and c before it knows any better."
msgstr "けれども、コンピュータはそれ以降を調べる前に既にa、b、cを実行してしまっています。"

#: ../../chapter4.rst:1366
msgid ""
"Instead, we have to check whether the exceptions apply *before* we do "
"anything else."
msgstr "代わりに、他のことをする前に例外が「適用されるかどうか」をチェックする必要があります。"

#: ../../chapter4.rst:1371
msgid ""
"In devising an algorithm, consider exceptions last. In writing code, "
"handle exceptions first."
msgstr "アルゴリズムを考案する際は、例外を最後に考慮してください。 一方、コードを書く際には、まず例外を処理します。"

#: ../../chapter4.rst:1374
msgid ""
"This tells us something about the general structure of our digit-"
"producing word. It will have to begin with a test for the 4/9 exceptions."
" In either of those cases, it will respond accordingly. If neither "
"exception applies, it will follow the “normal” algorithm. Using "
"pseudocode, then:"
msgstr ""
"これは、数字を生成するワードの一般的な構造について私たちに何かを伝えています。 4と9例外のためのテストから始めなければならないでしょう。 "
"どちらの場合も、例外のテストに応じて対応します。 どちらの例外も適用されない場合は、「通常の」アルゴリズムに従います。 "
"以下に疑似コードを示します。"

#: ../../chapter4.rst:1385
msgid ""
"An experienced Forth programmer would not actually write out this "
"pseudocode, but would more likely form a mental image of the structure "
"for eliminating the special cases. A less experienced programmer might "
"find it helpful to capture the structure in a diagram, or in code as "
"we’ve done here."
msgstr ""
"経験豊富なForthプログラマは、実際にはこの疑似コードを書き出しませんでしたが、特別な場合を排除するため頭の中で構造を思い浮かべる可能性があります。"
" 経験の浅いプログラマーであれば、ここで行ったように、ダイアグラムまたはコードで構造を捉えると便利な場合があります。"

#: ../../chapter4.rst:1391
msgid ""
"In Forth we try to minimize our dependence on logic. But in this case we "
"need the conditional ``IF`` because we have an exception we need to "
"eliminate. Still, we’ve minimized the complexity of the control structure"
" by limiting the number of ``IF``  ``THEN`` s in this definition to one."
msgstr "Forthでは、ロジックへの依存を最小限に抑えるよう試みます。しかし、この場合、除外する必要がある例外があるため、条件付きの ``IF`` が必要です。 それでも、この定義の ``IF``  ``THEN`` の数を1つに制限することで、制御構造の複雑さを最小限に抑えました。"

#: ../../chapter4.rst:1397
msgid ""
"Yes, we still have to distinguish between the 4-case and the 9-case, but "
"we’ve deferred that structural dimension to lower-level definitions—the "
"test for 4-or-9 and the “special case” code."
msgstr "ええ、私たちはまだ4の場合と9の場合をを区別する必要がありますが、その構造上の次元は下位レベルの定義（4または9のテストおよび「特殊ケース」コード）に延期しました。"

#: ../../chapter4.rst:1401
msgid ""
"What our structure really says is that either the 4-exception or the "
"9-exception must prohibit execution of the normal case. It’s not enough "
"merely to test for each exception, as in this version:"
msgstr ""
"私たちの構造が本当に言っているのは、4の例外または9の例外が通常の場合の実行を禁止しなければならないということです。 "
"以下のバージョンのように、単に各例外をテストするだけでは不十分です。"

#: ../../chapter4.rst:1411
msgid ""
"because the normal case is never excluded. (There’s no way to put an "
"``ELSE`` just before the normal case, because ``ELSE`` must appear "
"between ``IF`` and ``THEN``.)"
msgstr ""
"なぜなら通常の場合が除外されることは決してないからです。（ ``ELSE`` は ``IF`` と ``THEN`` "
"の間に現れなければならないので、通常の直前に ``ELSE`` を置く方法はありません。）"

#: ../../chapter4.rst:1415
msgid ""
"If we insist on handling the 4-exception and the 9-exception separately, "
"we could arrange for each exception to pass an additional flag, "
"indicating that the exception occurred. If either of these flags is true,"
" then we can exclude the normal case:"
msgstr ""
"4の例外と9の例外を別々に処理することを主張する場合は、例外が発生したことを示す追加のフラグを渡すように各例外に手配することができます。 "
"これらのフラグのどちらかが真であれば、通常の場合を除外することができます。"

#: ../../chapter4.rst:1426
msgid ""
"But this approach needlessly complicates the definition by adding new "
"control structures. We’ll leave it like it was."
msgstr "しかし、このアプローチは不必要に新しい制御構造を追加することになり、定義を複雑にします。 そのままにしておきます。"

#: ../../chapter4.rst:1429
msgid "Now we have a general idea of the structure of our main definition."
msgstr "これで、主な定義の構造についての一般的な考え方がわかりました。"

#: ../../chapter4.rst:1431
msgid ""
"We stated, “If the digit is 5 or more, begin with a ``FIVER`` and "
"subtract five from the value; otherwise do nothing. Then, print as many "
"``ONERS`` as necessary to add up to the value.”"
msgstr ""
"私たちは言いました。「数字が5以上の場合は、 ``FIVER`` で始め、値から5を引いてください。 それ以外の場合は何もしません。 "
"それから、値を合計するのに必要なだけ多くの ``ONERS`` を出力してださい。」"

#: ../../chapter4.rst:1435
msgid "A direct translation of these rules into Forth would look like this:"
msgstr "これらの規則をForthに直接変換すると、次のようになります。"

#: ../../chapter4.rst:1441
msgid ""
"This is technically correct, but if we’re familiar with the technique of "
"modulo division, we’ll see this as a natural situation for modulo "
"division by 5. If we divide the number by five, the quotient will be zero"
" (false) when the number is less than five, and one (true) when it’s "
"between 5 and 9. We can use it as the boolean flag to tell whether we "
"want the leading ``FIVER`` :"
msgstr ""
"これは技法的には正しいですが、剰余除算の手法に精通している場合、これを剰余除算の5での自然な状況と見なすことができます。数値を5で除算すると、商は0（偽）になります。"
" 数字は5未満で、5から9の間は1（真）です。これを先頭の ``FIVER`` が必要かどうかを示すためにブールフラグとして使用できます。"

#: ../../chapter4.rst:1452
msgid "The quotient/flag becomes the argument to ``IF``."
msgstr "商(フラグ)は ``IF`` の引数になります。."

#: ../../chapter4.rst:1454
msgid ""
"Furthermore, the remainder of modulo 5 division is always a number "
"between 0 and 4, which means that (except for our exception) we can use "
"the remainder directly as the argument to ``ONERS``. We revise our phrase"
" to"
msgstr ""
"さらに、5を除数とする除算の剰余は常に0から4の間の数です。つまり、（例外を除くと） ``ONERS`` への引数として剰余を直接使用できます。 "
"私達はフレーズを以下のように修正します。"

#: ../../chapter4.rst:1462
msgid ""
"Getting back to that exception, we now see that we can test for both 4 "
"and 9 with a single test—namely, if the remainder is 4. This suggests "
"that we can do our 5 ``/MOD`` first, then test for the exception. "
"Something like this:"
msgstr ""
"その例外にもどると、 ``4-OR-9?`` "
"の名前の通り、4と9の両方を1回でテストできることが分かりました。以下のように、残りが4の場合、最初に5の ``/MOD`` "
"を実行してから例外をテストすることができることを示唆しています。"

#: ../../chapter4.rst:1473
msgid ""
"(Notice that we ``OVER`` ed the remainder so that we could compare it "
"with 4 without consuming it.)"
msgstr "(消費せずに4と比較できるように、剰余を ``OVER`` (訳注: 剰余 商 -- 剰余 商 剰余)しました。)"

#: ../../chapter4.rst:1476
msgid ""
"So it turns out we *do* have a doubly-nested ``IF THEN`` construct after "
"all. But it seems justified because the ``IF THEN`` is handling the "
"special case. The other is such a short phrase, ``IF FIVER THEN``, it’s "
"hardly worth making into a separate definition. You could though. (But we"
" won’t.)"
msgstr ""
"結局、二重にネストされた ``IF THEN`` にしました。しかし、 ``IF THEN`` "
"が特別な場合を扱っているので、それはもっともなことです。 もう1つ、短いフレーズ ``IF FIVER THEN`` "
"は別の定義にする価値はほとんどありません。この辺りは好みです。分けても構いません。"

#: ../../chapter4.rst:1483
msgid ""
"Let’s focus on the code for the special case. To state its algorithm: “If"
" the digit is four, print a ``ONER`` and a ``FIVER``. If the digit is "
"nine, print a ``ONER`` and a ``TENER``.”"
msgstr ""
"特別な場合のコードに注目しましょう。 そのアルゴリズムは、「数字が4の場合は ``ONER`` と ``FIVER`` "
"を出力します。数字が9の場合は ``ONER`` と ``TENER`` を出力します。"

#: ../../chapter4.rst:1487
msgid ""
"We can assume that the digit will be one or the other, or else we’d never"
" be executing this definition. The question is, how do we tell which one?"
msgstr ""
"数字はどちらか一方になると仮定することができます。そうでなければ、この定義を実行することは決してありません。 "
"問題は、それをどうやって見分けるのかということです。"

#: ../../chapter4.rst:1491
msgid ""
"Again, we can use the quotient of division by five. If the quotient is "
"zero, the digit must have been four; otherwise it was nine. So we’ll play"
" the same trick and use the quotient as a boolean flag. We’ll write:"
msgstr ""
"繰り返しになりますが、5の除算の商を使用できます。 "
"商がゼロの場合、数字は4以下でなければなりません。商がゼロでなければ数字は9以下です。だから私たちは同じトリックを弄して、ブーリアンフラグとして商を使用します。"
" 私たちは以下のように書きました。"

#: ../../chapter4.rst:1500
msgid ""
"In retrospect, we notice that we’re printing a ``ONER`` either way. We "
"can simplify the definition to:"
msgstr "振り返ってみると、我々はどちらかの方法で ``ONER`` を出力していることに気づきます。 定義を次のように単純化することができます。"

#: ../../chapter4.rst:1508
msgid ""
"We’ve assumed that we have a quotient on the stack to use. Let’s go back "
"to our definition of ``DIGIT`` and make sure that we do, in fact:"
msgstr "スタックには使用する商があると仮定しました。 ``DIGIT`` の定義に戻り、実際に行ったことを確認しましょう。"

#: ../../chapter4.rst:1517
msgid ""
"It turns out that we have not only a quotient, but a remainder underneath"
" as well. We’re keeping both on the stack in the event we execute the "
"``ELSE`` clause. The word ``ALMOST``, however, only needs the quotient. "
"So, for symmetry, we must ``DROP`` the remainder like this:"
msgstr ""
"商だけでなく、その下にも余りがあることがわかります。 ``ELSE`` 句を実行した場合でも、両方をスタックに保持しています。 しかし、 "
"``ALMOST`` というワードは商を必要とするだけです。 それで、対称性のために、剰余の部分を以下のように ``DROP`` (訳注: n "
"-- ;スタックトップを単に捨てる)しなければなりません。"

#: ../../chapter4.rst:1529
msgid ""
"There we have the complete, coded definition for producing a single digit"
" of a Roman numeral. If we were desperate to try it out before writing "
"the needed auxiliary definitions, we could very quickly define a lexicon "
"of words to print one group of symbols, say the ``ONES`` row:"
msgstr ""
"ここに、ローマ数字の1桁の数字を生成するための完全なコード化定義があります。 "
"必要な補助定義を書く前に試してみたかったら、1つのシンボルのグループを出力するためにワードの用語集をすぐに定義することができます。以下の "
"``ONES`` の行をご覧下さい。"

#: ../../chapter4.rst:1543
msgid "before loading our definitions of ``ALMOST`` and ``DIGIT``."
msgstr "これを ``ALMOST`` と ``DIGIT`` の定義を読み込む前に定義しておきます。"

#: ../../chapter4.rst:1545
msgid ""
"But we’re not that desperate. No, we’re anxious to move on to the problem"
" of defining the words ``ONER``, ``FIVER``, and ``TENER`` so that their "
"symbols depend on which decimal digit we’re formatting."
msgstr ""
"しかし、私たちはそれほどやけくそではありません。 いいえ、 ``ONER`` 、 ``FIVER`` 、 ``TENER`` "
"というワードを定義するという問題に移ることを切望しているので、それらの記号はフォーマットしている10進数の数字に依存します。"

#: ../../chapter4.rst:1549
msgid "Let’s go back to the symbol table we drew earlier:"
msgstr "先ほど作成したシンボル表に戻りましょう。"

#: ../../chapter4.rst:1554 ../../chapter4.rst:1572
msgid "ones"
msgstr "ones"

#: ../../chapter4.rst:1555 ../../chapter4.rst:1574
msgid "tens"
msgstr "tens"

#: ../../chapter4.rst:1556 ../../chapter4.rst:1576
msgid "hundreds"
msgstr "hundreds"

#: ../../chapter4.rst:1557 ../../chapter4.rst:1578
msgid "thousands"
msgstr "thousands"

#: ../../chapter4.rst:1561
msgid ""
"We’ve observed that we also need a ``TENER`` —which is the ``ONER`` in "
"the next row below. It’s as if the table should really be written:"
msgstr ""
"下の行の ``OWNER`` である ``TENER`` も必要であることを私たちは観察しました。 "
"表として実際に書かれるべきであるように思われます。"

#: ../../chapter4.rst:1568
msgid ""
"But that seems redundant. Can we avoid it? Perhaps if we try a different "
"model, perhaps a linear table, like this:"
msgstr "しかし、それは冗長に思えます。 それを避けることができますか？ おそらく、次のように別のモデル、おそらく線形表を試すとします。"

#: ../../chapter4.rst:1572
msgid "I V"
msgstr "I V"

#: ../../chapter4.rst:1574
msgid "X L"
msgstr "X L"

#: ../../chapter4.rst:1576
msgid "C D"
msgstr "C D"

#: ../../chapter4.rst:1581
msgid ""
"Now we can imagine that each column name (“ones,” “tens,” etc.) points to"
" the ONER of that column. From there we can also get each column’s "
"``FIVER`` by reaching down one slot below the current ``ONER``, and the "
"``TENER`` by reaching down two slots."
msgstr ""
"これで、各列の名前（“ones” “tens” など）がその列の1つを指すことを想像できます。 そこから、現在の ``ONER`` "
"の1つ下のスロットに到達することで各列の ``FIVER`` を、2つの下のスロットに到達することで ``TENER`` "
"を取得することもできます。"

#: ../../chapter4.rst:1586
msgid ""
"It’s like building an arm with three hands. We can attach it to the "
"``ONES`` column, as in  :numref:`fig4-8` a, or we can attach it to the "
"tens’ column, as in  :numref:`fig4-8` b, or to any power of ten."
msgstr ""
"3本の手で腕を組むようなものです。:numref:`fig4-8` (a)のようにそれを ``ONES`` "
"列に取り付けることもできますし、:numref:`fig4-8` "
"(b)のようにそれをtens列に取り付けることもできます。またはそれを任意の10のべき乗で取り付けられます。"

#: ../../chapter4.rst:1594
msgid "A mechanical representation: accessing the data structure."
msgstr "データ構造へのアクセスの機械的表現(3本の腕、可動腕)"

#: ../../chapter4.rst:1596
msgid ""
"An experienced Forth programmer is not likely to imagine arms, hands, or "
"things like that. But there must be a strong mental image—the stuff of "
"right-brain thinking—before there’s any attempt to construct the model "
"with code."
msgstr ""
"熟練したForthプログラマーは、腕、手、またはそのようなものを想像することはほとんどありません。 "
"しかし、コードでモデルを構築しようとする前に、強い精神的イメージ―右脳思考のもの―がなければなりません。"

#: ../../chapter4.rst:1601
msgid ""
"Beginners who are learning to think in this right-brain way might find "
"the following tip helpful:"
msgstr "この右脳思考を学んでいる初心者は、以下の助言が役に立つと思うかもしれません。"

#: ../../chapter4.rst:1606
msgid ""
"If you have trouble thinking about a conceptual model, visualize it---or "
"draw it---as a mechanical device."
msgstr "概念モデルについて考えるのが難しい場合は、それを機械的な装置として視覚化する（または描画する）。"

#: ../../chapter4.rst:1609
msgid ""
"Our table is simply an array of characters. Since a character requires "
"only a byte, let’s make each “slot” one byte. We’ll call the table "
"``ROMANS``:"
msgstr ""
"私たちの表は単に文字の配列です。 文字は1バイトしか必要としないので、それぞれの「スロット」を1バイトにしましょう。 表を ``ROMANS`` "
"と呼びます。"

#: ../../chapter4.rst:1620
msgid ""
"Note: This use of ``ASCII`` requires that ``ASCII`` be “ ``STATE`` "
"-dependent” (see :doc:`Appendix C<appendixc>`). If the word ``ASCII`` is "
"not defined in your system, or if it is not state-dependent, use:"
msgstr ""
"注意：この ``ASCII`` は ``STATE`` (訳注: -- f;コンパイル時なら0以外の値を返す)の状態にに依存します( "
":doc:`付録C<appendixc>` 参照)。 またはそれが ``STATE`` の状態に依存しないようにするには、次のようにします。"

#: ../../chapter4.rst:1630
msgid ""
"We can select a particular symbol from the table by applying two "
"different offsets at the same time. One dimension represents the decimal "
"place: ones, tens, hundreds, etc. This dimension is made “current,” that "
"is, its state stays the same until we change it."
msgstr "2つの異なるオフセットを同時に適用することで表から特定のシンボルを選択できます。 1つの次元は位取りを表します。1(ones)、10(tens)、100(hundreds)などです。この次元は「現在(current)」になります。つまり、変更するまでその状態は変わりません。"

#: ../../chapter4.rst:1635
msgid ""
"The other dimension represents the kind of symbol we want— ``ONER``, "
"``FIVER``, ``TENER`` —within the current decimal column. This dimension "
"is incidental, that is, we’ll specify which symbol we want each time."
msgstr ""
"もう1つの次元は、現在の位取りの中で、欲しいシンボルの種類( ``ONER`` 、 ``FIVER`` 、``TENER`` )を表します。 "
"この次元は付随的なものです。つまり、毎回どのシンボルが必要かを指定します。"

#: ../../chapter4.rst:1639
msgid ""
"Let’s start by implementing the “current” dimension. We need some way to "
"point to the current decimal column. Let’s create a variable called "
"``COLUMN#`` (pronounced “column-number”) and have it contain an offset "
"into the table:"
msgstr ""
"「現在(current)」の次元を実装することから始めましょう。 現在の10進数桁位置を指すための何らかの方法が必要です。 `` "
"COLUMN#`` (カラム・ナンバー(column-number)と発音する)という名前の変数を作成し、それに表へのオフセットを含めます。"

#: ../../chapter4.rst:1652
msgid ""
"Now we can find our way to any “arm position” by adding the contents of "
"``COLUMN#`` to the beginning address of the table, given by ``ROMANS``:"
msgstr ""
"これで、 ``ROMANS`` で与えられる ``COLUMN#`` "
"の内容を表の先頭アドレスに追加することで、任意の「腕の位置」に進むことができます。"

#: ../../chapter4.rst:1659
msgid ""
"Let’s see if we can implement one of the words to display a symbol. We’ll"
" start with ``ONER``."
msgstr "シンボルを表示するためのワードの1つを実装できるかどうか見てみましょう。 ``ONER`` から始めましょう。"

#: ../../chapter4.rst:1662
msgid "The thing we want to do in ONER is ``EMIT`` a character."
msgstr "私たちがONERでやりたいことは文字を出す( ``EMIT``)ことです。"

#: ../../chapter4.rst:1668
msgid ""
"Working backward, ``EMIT`` requires the ASCII character on the stack. How"
" do we get it there? With ``C@``."
msgstr ""
"逆からたどって、 ``EMIT`` はスタック上にASCII文字コードを必要とします。 どうやってそれを得るのですか？ それには ``C@`` "
"を使います。"

#: ../../chapter4.rst:1676
msgid ""
"``C@`` requires the *address* of the slot that contains the symbol we "
"want. How do we get that address?"
msgstr "その ``C@`` は、欲しい文字コードを含むスロットの「アドレス」を必要とします。 そのアドレスはどうやって取得するのですか？"

#: ../../chapter4.rst:1679
msgid ""
"The ``ONER`` is the first \"hand\" on the movable arm—the position that "
"``COLUMN`` is already pointing to. So, the address we want is simply the "
"address returned by ``COLUMN``:"
msgstr ""
"``ONER`` は可動腕の最初の「手」、つまり ``COLUMN`` がすでに指している位置です。だから、私たちが欲しいアドレスは単に "
"``COLUMN`` によって返されるアドレスです。"

#: ../../chapter4.rst:1687
msgid ""
"Now let’s write ``FIVER``. It computes the same slot address, then adds "
"one to get the next slot, before fetching the symbol and emitting it:"
msgstr ""
"それでは ``FIVER`` を書きましょう。 "
"それは同じスロットアドレスを計算し、それからシンボルを取得してそれを出力する前に、次のスロットを取得するために1を追加します。"

#: ../../chapter4.rst:1694
msgid "And ``TENER`` is:"
msgstr "そして ``TENER`` は、"

#: ../../chapter4.rst:1700
msgid ""
"These three definitions are redundant. Since the only difference between "
"them is the incidental offset, we can factor the incidental offset out "
"from the rest of the definitions:"
msgstr ""
"これら3つの定義は重複しています。 "
"それらの間の唯一の違いは付随的なオフセットであるので、我々は残りの定義から付随的なオフセットを除外することができます。"

#: ../../chapter4.rst:1708
msgid "Now we can define:"
msgstr "いまや、私たちは以下のように定義できます。"

#: ../../chapter4.rst:1716
msgid ""
"All that remains for us to do now is to decompose our complete decimal "
"number into a series of decimal digits. Based on the observations we’ve "
"already made, this should be easy.  :numref:`fig4-9`  shows our completed"
" listing."
msgstr ""
"私たちが今やるべきことは、完全な10進数値を一連の10進数数字に分解することだけです。 私たちがすでに行った観察に基づいて、これは簡単なはずです。"
" :numref:`fig4-9` は完成したリストを示しています。"

#: ../../chapter4.rst:1721
msgid "Voila! From problem, to conceptual model, to code."
msgstr "じゃーん！ 問題から概念モデル、そしてコーディングまでできました。"

#: ../../chapter4.rst:1723
msgid ""
"Note: this solution is not optimal. The present volume does not address "
"the optimization phase."
msgstr "注意：この解決策は最適ではありません。 この章では最適化フェイズは取り扱いません。"

#: ../../chapter4.rst:1726
msgid ""
"One more thought: Depending on who uses this application, we may want to "
"add error-checking. Fact is, the highest symbol we know is M; the highest"
" value we can represent is 3,999, or MMMCMXCIX."
msgstr ""
"もう1つ考えるべきこととして、このアプリケーションを使用している人によっては、エラーチェックを追加することをお勧めします。 "
"実際、私たちが知っている最高のシンボルはMです。 ここで表現できる最高値は3,999、つまりMMMCMXCIXです。"

#: ../../chapter4.rst:1732
msgid "We might redefine ROMAN as follows:"
msgstr "私たちはROMANを次のように再定義するかもしれません。"

# Aha(なるほど) by ウィキペディア「感動詞」
#: ../../chapter4.rst:1740
msgid ""
"There's a definite sense of rightness when you've done it right. It may "
"be that feeling that distinguishes Forth from other languages, where you "
"never feel you've really done well. In Forth, it's the \"Aha!\" reaction."
" You want to run off and tell somebody."
msgstr ""
"あなたが正しく行ったときには、正義の感覚があります。 Forthを他の言語と区別するのはそのような感覚かもしれません。 "
"Forthでは、それは「なるほど！(Aha!)」反応です。 あなたは走り出して誰かに伝えたくなります。"

#: ../../chapter4.rst:1745
msgid "Of course, nobody will appreciate it like you do."
msgstr "もちろん、その感覚は正しく行ったあなただけが味わえるものです。"

#: ../../chapter4.rst:1747
msgid "Screen #20"
msgstr "Screen #20"

#: ../../chapter4.rst:1766
msgid "Screen #21"
msgstr "Screen #21"

#: ../../chapter4.rst:1784
msgid "Screen #22"
msgstr "Screen #22"

#: ../../chapter4.rst:1795
msgid "Summary"
msgstr "要約"

#: ../../chapter4.rst:1797
msgid ""
"In this chapter we’ve learned to develop a single component, starting "
"first with deciding on its syntax, then proceeding with determining its "
"algorithm(s) and data structure(s), and concluding with an implementation"
" in Forth."
msgstr "この章では、単一のコンポーネントを開発するために、まずその構文を決定し、それからにそのアルゴリズムとデータ構造を決定を進め、そしてForthでの実装を完結させました。"

#: ../../chapter4.rst:1802
msgid ""
"With this chapter we complete our discussion of design. The remainder of "
"the book will discuss style and programming techniques."
msgstr "この章で私たちは設計の議論を終えました。 本の残りの部分では、スタイルとプログラミング手法について説明します。"

#: ../../chapter4.rst:1806
msgid "For Further Thinking"
msgstr "更なる思考のために"

#: ../../chapter4.rst:1808
msgid ""
"Design the components and describe the algorithm(s) necessary to simulate"
" shuffling a deck of cards. Your algorithm will produce an array of "
"numbers, 0–51, arranged in random order."
msgstr ""
"コンポーネントを設計し、カードのシャッフルをシミュレートするのに必要なアルゴリズムを記述します。 "
"あなたのアルゴリズムは、ランダムな順序で配置された0から51の数字の配列を生成します。"

#: ../../chapter4.rst:1812
msgid ""
"The special constraint of this problem, of course, is that no one card "
"may appear twice in the array."
msgstr "この問題の特別な制約は、もちろん、同じカードが配列内に2回現れることはないということです。"

#: ../../chapter4.rst:1815
msgid ""
"You may assume you have a random-number generator called CHOOSE. It’s "
"stack argument is ``n``; it produces a random number between zero and "
"``n-1`` inclusive. (See the Handy Hint, Chapter Ten, *Starting Forth*.)"
msgstr "あなたはCHOOSEと呼ばれる乱数発生器を持ってるとしましょう。 スタック引数は ``n`` です。 0から ``n-1`` までの乱数を生成します(邦訳:Forth入門の第10章の「知っていると便利です  乱数発生器」P.314 を参照(See the Handy Hint, Chapter Ten, *Starting Forth* ))。"

#: ../../chapter4.rst:1820
msgid ""
"Can you design the card-shuffling algorithm so that it avoids the time-"
"consuming burden of checking some undetermined number of slots on each "
"pass of the loop? Can you do so using only the one array?"
msgstr ""
"あなたはそれがループの各回で不定数のスロットをチェックするという時間のかかる負担を避けるようにカードシャッフリングアルゴリズムを設計することができますか？"
" 1つの配列だけを使ってそうすることができますか？"

#: ../../chapter4.rst:1825
msgid "REFERNCES"
msgstr "参考文献"

#: ../../chapter4.rst:1827
msgid ""
"Polya, **How To Solve It: A New Aspect of Mathematical Method** "
",(Princeton, New Jersey, Princeton University Press)."
msgstr ""
"Polya,  **How To Solve It: A New Aspect of Mathematical Method** , "
"(Princeton, New Jersey, Princeton University   "
"Press).(邦題「いかにして問題をとくか」,ジョージ・ポリア 著,柿内 賢信 訳,丸善出版,1975年04月,ISBN "
"978-4-621-04593-0)"

#: ../../chapter4.rst:1828
msgid ""
"Leslie A. Hart, **How the Brain Works** , (C) 1975 by Leslie A. Hart, "
"(New York, Basic Books, Inc., 1975)."
msgstr ""
"Leslie A. Hart, **How the Brain Works** , (C) 1975 by Leslie A. Hart, "
"(New York, Basic Books, Inc., 1975)."

#: ../../chapter4.rst:1829
msgid ""
"Evan Rosen, \"High Speed, Low Memory Consumption Structures,\" 1982  "
"**FORML Conference Proceedings** , p.191."
msgstr ""
"Evan Rosen, \"High Speed, Low Memory Consumption Structures,\" 1982  "
"**FORML Conference Proceedings** , p.191."

#: ../../chapter4.rst:1830
msgid ""
"Michael Stolowitz, \"A Compiler for Programmable Logic in FORTH,\" 1982 "
"**FORML Conference Proceedings** , p.257."
msgstr ""
"Michael Stolowitz, \"A Compiler for Programmable Logic in FORTH,\" 1982 "
"**FORML Conference Proceedings** , p.257."

