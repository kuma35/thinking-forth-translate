# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Leo Brodie
# This file is distributed under the same license as the Thinking Forth
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Thinking Forth 0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-27 04:49+0900\n"
"PO-Revision-Date: 2019-07-27 04:50+0900\n"
"Last-Translator: kuma35\n"
"Language: ja_JP\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../chapter5.rst:4
msgid "5. Implementation: Elements of Forth Style"
msgstr "第５章 実装(Forthスタイルの要素)"

#: ../../chapter5.rst:6
msgid ""
"Badly written Forth has been accused of looking like “code that went "
"through a trash compactor.” It’s true, Forth affords more freedom in the "
"way we write applications. But that freedom also gives us a chance to "
"write exquisitely readable and easily maintainable code, provided we "
"consciously employ the elements of good Forth style."
msgstr "正しく書かれていないForthは、「ゴミ圧縮機を通過したコード」のように見えると非難されてきました。事実、Forthは、アプリケーションをより自由に書くことができます。しかし、一方でその自由度は、私たちが良きForthスタイルの要素を意識的に採用するなら、私たちに絶妙に読解可能で容易に保守可能なコードを書く機会も与えます。"

#: ../../chapter5.rst:13
msgid "In this chapter we’ll delve into Forth coding convention including:"
msgstr "この章では、Forthのコーディング規約について詳しく説明します。"

#: ../../chapter5.rst:15
msgid "listing organization"
msgstr "リストの整理"

#: ../../chapter5.rst:17
msgid "screen layout, spacing and indentation"
msgstr "画面レイアウト、間隔、字下げ"

#: ../../chapter5.rst:19
msgid "commenting"
msgstr "コメント"

#: ../../chapter5.rst:21
msgid "choosing names"
msgstr "名前の選び方"

#: ../../chapter5.rst:23
msgid ""
"I wish I could recommend a list of hard-and-fast conventions for "
"everyone. Unfortunately, such a list may be inappropriate in many "
"situations. This chapter merges many widely-adopted conventions with "
"personal preferences, commented with alternate ideas and the reasons for "
"the preferences. In other words:"
msgstr ""
"私は、誰のためにもなる、最も速くて速い規約のリストを推薦することができれば、と思います。 "
"残念ながら、そのようなリストは多くの状況で不適切な場合があります。 "
"この章では、広く採用されている多くの規則と個人的な好みを組み合わせ、別のアイデアや好みの理由についてコメントしています。 言い換えると、"

#: ../../chapter5.rst:33
msgid ""
"I’d especially like to thank Kim Harris, who proposed many of the "
"conventions described in this chapter, for his continuing efforts at "
"unifying divergent views on good Forth style."
msgstr "私は特に、この章で説明されている規約の多くを提案してくれたキム・ハリスに、素晴らしいForthスタイルについて、意見の相違を統一する努力を続けてくれたことに感謝します。"

#: ../../chapter5.rst:39
msgid "Listing Organization"
msgstr "リストの整理"

#: ../../chapter5.rst:41
msgid ""
"A well-organized book has clearly defined chapters, with clearly defined "
"sections, and a table of contents to help you see the organization at a "
"glance. A well-organized book is easy to read. A badly organized book "
"makes comprehension more difficult, and makes finding information later "
"on nearly impossible."
msgstr ""
"よく整理されている本には、明確に定義された章、明確に定義された節、および一目で構成を見るのに役立つ目次があります。 "
"よく整理されている本は読みやすいです。 本がよく組織化されていないと、理解が難しくなり、後で情報を見つけることがほぼ不可能になります。"

#: ../../chapter5.rst:52
msgid "I still don't see how these programming conventions enhance readability."
msgstr "私はまだこれらのプログラミング規約がどのように読みやすさを向上させるか分かりません。"

#: ../../chapter5.rst:54
msgid ""
"The necessity for good organization applies to an application listing as "
"well. Good organization has three aspects:"
msgstr "優れた整理の必要性は、アプリケーションリストにも当てはまります。 良い整理には3つの側面があります。"

#: ../../chapter5.rst:57 ../../chapter5.rst:64
msgid "Decomposition"
msgstr "分解"

#: ../../chapter5.rst:59 ../../chapter5.rst:81
msgid "Composition"
msgstr "構成"

#: ../../chapter5.rst:61
msgid "Disk partitioning"
msgstr "ディスク割当て"

#: ../../chapter5.rst:66
msgid ""
"As we’ve already seen, the organization of a listing should follow the "
"decomposition of the application into lexicons. Generally these lexicons "
"should be sequenced in “uses” order. Lexicons being *used* should precede"
" the lexicons which *use* them."
msgstr ""
"すでに見たように、リストの整理はアプリケーションの用語集への分解に従うべきです。 一般に、これらの用語集は「使用」順に並べられるべきです。 "
"使用されている用語集は、それらを使用している用語集の前に置くべきです。"

#: ../../chapter5.rst:71
msgid ""
"On a larger scale, elements in a listing should be organized by degree of"
" complexity, with the most complex variations appearing towards the end. "
"It’s best to arrange things so that you can leave off the lattermost "
"screens (i.e., not load them) and still have a self-sufficient, running "
"application, working properly except for the lack of the more advanced "
"features."
msgstr "大規模では、リスト内の要素は複雑さの度合いによって整理されるべきであり、最も複雑なバリエーションはその終わりに現れます。最後の画面を表示せず（つまりロードしないで）、より高度な機能がないことを除けば適切に動作する自給自足のアプリケーションを使用できるようにすることをお勧めします。"

#: ../../chapter5.rst:78
msgid ""
"We discussed the art of decomposition extensively in :doc:`Chapter "
"Three<chapter3>`."
msgstr "分解の技術については、 :doc:`第３章<chapter3>` で詳しく説明しました。"

#: ../../chapter5.rst:83
msgid ""
"Composition is the putting together of pieces to create a whole. Good "
"composition requires as much artistry as good decomposition."
msgstr "構成は全体を作成するための部分の組み合わせです。 良い構成は、良い分解と同じくらいの腕前が必要です。"

#: ../../chapter5.rst:86
msgid ""
"One of Forth’s present conventions is that source code resides in "
"“screens,” which are 1K units of mass storage. (The term “screen” refers "
"to a block used specifically for source code.) It’s possible in Forth to "
"chain every screen of code to the next, linking the entire listing "
"together linearly like a lengthy parchment scroll. This is not a useful "
"approach. Instead:"
msgstr ""
"Forthの現在の慣習の1つは、ソースコードが1Kの大容量記憶装置の「スクリーン(screen)」上にあるということです(「スクリーン」という用語は、ソースコード専用に使用されるブロック(block)を指します)。(。"
" Forthでは、長い羊皮紙スクロールのようにリスト全体を線形にリンクすることで、コードのすべての画面を次の画面にチェインすることができます。 "
"これは便利なアプローチではありません。 代わりに、"

#: ../../chapter5.rst:95
msgid "Structure your application listing like a book: hierarchically."
msgstr "アプリケーションのリストの構造を本のようにします。つまり階層化です。"

#: ../../chapter5.rst:97
msgid "An application may consist of:"
msgstr "1つのアプリケーションは以下で構成されます。"

#: ../../chapter5.rst:100
msgid "Screens:"
msgstr "(複数の)スクリーン"

#: ../../chapter5.rst:100
msgid "the smallest unit of Forth source"
msgstr "Forthのソースの最小単位です。"

#: ../../chapter5.rst:103
msgid "Lexicons:"
msgstr "(複数の)用語集"

#: ../../chapter5.rst:103
msgid "one to three screens, enough to implement a component"
msgstr "1から3スクリーンは、1つのコンポーネントを実装するのに充分な大きさです。"

#: ../../chapter5.rst:106
msgid "Chapters:"
msgstr "(複数の)章"

#: ../../chapter5.rst:106
msgid "a series of related lexicons, and"
msgstr "一連の関連する用語集。そして、"

#: ../../chapter5.rst:110
msgid "Load screens:"
msgstr "(複数の)一括ロード用スクリーン"

#: ../../chapter5.rst:109
msgid ""
"analogous to a table of contents, a screen that loads the chapters in the"
" proper sequence."
msgstr "目次と同じように、章を適切な順序でロードするスクリーンです。"

#: ../../chapter5.rst:112
msgid "Example of an application-load screen"
msgstr "アプリケーション・ロード・スクリーンの例"

#: ../../chapter5.rst:114
msgid "Screen #1"
msgstr "Screen #1"

#: ../../chapter5.rst:133
msgid "Application-load Screen"
msgstr "アプリケーション・ロード・スクリーン"

#: ../../chapter5.rst:135
msgid ""
":numref:`fig5-1`  is an example of an application-load screen. Since it "
"resides in Screen 1, you can load this entire application by entering"
msgstr ""
":numref:`fig5-1` アプリケーション・ロード・スクリーンの例です。 "
"スクリーン1にあるので、以下のとおり入力してこのアプリケーション全体をロードできます。"

#: ../../chapter5.rst:143
msgid ""
"The individual load commands within this screen load the chapters of the "
"application. For instance, Screen 12 is the load screen for the video "
"primitives chapter."
msgstr ""
"このスクリーン内の個々のロードコマンドはアプリケーションの章をロードします。 "
"たとえば、スクリーン12は、ビデオプリミティブの章のロード・スクリーンです。"

#: ../../chapter5.rst:147
msgid ""
"As a reference tool, the application-load screen tells you where to find "
"all of the chapters. For instance, if you want to look at the routines "
"that do framing, you can see that the section starts at Screen 90."
msgstr ""
"参照ツールとして、アプリケーション・ロード・スクリーンでは、すべての章の場所がわかります。 "
"たとえば、フレーミングを実行するルーチンを見たい場合は、そのセクションがスクリーン90から始まることがわかります。"

#: ../../chapter5.rst:151
msgid ""
"Each chapter-load screen in turn, loads all of the screens comprising the"
" chapter. We’ll study some formats for chapter-load screens shortly."
msgstr "各章のロードスクリーンは、順番に章を構成するすべてのスクリーンをロードします。 章ロード画面のフォーマットについてはすぐ後で検討します。"

#: ../../chapter5.rst:154
msgid ""
"The primary benefit of this hierarchical scheme is that you can load any "
"section, or any screen by itself, without having to load the entire "
"application. Modularity of the source code is one of the reasons for "
"Forth’s quick turnaround time for editing, loading, and testing "
"(necessary for the iterative approach). Like pages of a book, each screen"
" can be accessed individually and quickly. It’s a “random access” "
"approach to source-code maintenance."
msgstr ""
"この階層構造の主な利点は、アプリケーション全体をロードしなくても、任意のセクションまたは任意のスクリーンを単独でロードできることです。 "
"ソースコードのモジュール性は、Forthの編集・ロード・テストのための短いターンアラウンドタイム（反復アプローチのために必要）の理由の1つです。 "
"本のページと同様に、各スクリーンにも個別にすばやくアクセスできます。 これはソースコードのメンテナンスに対する「ランダムアクセス」アプローチです。"

#: ../../chapter5.rst:162
msgid ""
"You can also replace any passage of code with a new, trial version by "
"simply changing the screen numbers in the load screen. You don’t have to "
"move large passages of source code around within a file."
msgstr ""
"ロード・スクリーンでスクリーン番号を変更するだけで、コードの一部を新しい試用版に置き換えることもできます。 "
"ファイル内で大量のソースコードを移動する必要はありません。"

#: ../../chapter5.rst:166
msgid ""
"In small applications, there may not be such things as chapters. The "
"application-load screen will directly load all the lexicons. In larger "
"applications, however, the extra level of hierarchy can improve "
"maintainability. A screen should either be a load-screen or a code-"
"screen, not a mixture. Avoid embedding a ``LOAD`` or ``THRU`` command in "
"the middle of a screen containing definitions just because you “need "
"something” or because you “ran out of room.”"
msgstr ""
"小さなアプリケーションでは、章のようなものがないかもしれません。 アプリケーション・ロード・スクリーンはすべての用語集を直接ロードします。 "
"ただし、大規模なアプリケーションでは、階層を追加することで保守性を向上させることができます。 "
"スクリーンは混合ではなく、ロード・スクリーンまたはコード・スクリーンのどちらかにする必要があります。 定義が表示されているスクリーンの途中に "
"``LOAD`` や ``THRU`` "
"コマンドを埋め込むのは避けてください。それを行うのは「何か必要」または「スクリーンを使い果たした」という理由の時だけにしてください。"

#: ../../chapter5.rst:176
msgid "Skip Commands"
msgstr "スキップ・コマンド"

#: ../../chapter5.rst:178
msgid ""
"Two commands make it easy to control what gets loaded in each screen and "
"what gets ignored. They are:"
msgstr "以下の2つのコマンドを使用すると、各画面に何をロードし、何を無視するかを簡単に制御できます。"

#: ../../chapter5.rst:186
msgid ""
"``\\`` is pronounced “skip-line.” It causes the Forth interpreter to "
"ignore everything to the right of it on the same line. (Since ``\\`` is a"
" Forth word, it must be followed by a space.) It does not require a "
"delimiter."
msgstr ""
"``\\`` は「スキップ・ライン」(skip-"
"line)と発音します。それはForthインタプリタに同じ行のそれの右側にあるすべてを無視させます( ``\\`` "
"はForthのワードであるため、スペースを続ける必要があります)。(訳注: ``(`` … ``)`` と異なり)区切り文字は不要です。"

#: ../../chapter5.rst:191
msgid ""
"In :numref:`fig5-1` , you see ``\\`` used in two ways: to begin the "
"screen-comment line (Line 0), and to begin comments on individual lines "
"which have no more code to the right of the comment."
msgstr ""
":numref:`fig5-1` では、``\\`` "
"が2つの方法で使われているのがわかります。スクリーンコメント行(行0)の始めと、個々の行のコードの後ろのコメントの始まりとしてです。"

#: ../../chapter5.rst:195
msgid ""
"During testing, ``\\`` also serves to temporarily “paren out” lines that "
"already contain a right parenthesis in a name or comment. For instance, "
"these two “skip-line”s keep the definition of ``NUTATE`` from being "
"compiled without causing problems in encountering either right "
"parenthesis:"
msgstr ""
"テスト中に、 ``\\`` は、すでに名前やコメントに右括弧が含まれている行を一時的にコメントアウトするのにも役立ちます。 "
"例えば、以下の2つの「スキップ・ライン」は、右括弧に出くわすことによる問題を引き起こすことなく、 ``NUTATE`` "
"の定義がコンパイルされるのを防ぎます。"

#: ../../chapter5.rst:206
msgid ""
"``\\S`` is pronounced “skip-screen.” It causes the Forth interpreter to "
"stop interpreting the screen entirely, as though there were nothing else "
"in the screen beyond ``\\S``."
msgstr ""
"``\\S`` は「スキップ／スクリーン(skip-screen)」と発音します。これはForthインタプリタに、 ``\\S`` "
"を超えて以降、そのスクリーンに何もなかったかのように、 ``\\S`` 以降のスクリーン内の解釈を完全に停止させます。"

#: ../../chapter5.rst:210
msgid ""
"In many Forth systems, this function is the same as ``EXIT``, which is "
"the run-time routine for semicolon. In these systems the use of ``EXIT`` "
"is acceptable. Some Forth systems, however, require for internal reasons "
"a different routine for the “skip-screen” function."
msgstr ""
"多くのForthシステムでは、この機能はセミコロンのためのランタイムルーチンである ``EXIT`` と同じです。 これらのシステムでは "
"``EXIT`` "
"の使用は受け付けられます。ただし、Forthシステムの中には、内部的な理由から「スクリーンのスキップ」機能に対して別のルーチンを必要とするものがあります。"

#: ../../chapter5.rst:216
msgid ""
"Definitions for ``\\`` and ``\\S`` can be found in :doc:`Appendix "
"C<appendixc>`."
msgstr "``\\`` と ``\\S`` の定義は :doc:`付録C<appendixc>` にあります。"

#: ../../chapter5.rst:219
msgid "Chapter-load Screens"
msgstr "章ロード・スクリーン"

#: ../../chapter5.rst:221
msgid ""
":numref:`fig5-2`  illustrates a typical chapter-load screen. The screens "
"loaded by this screen are referred to relatively, not absolutely as they "
"were in the application-load screen."
msgstr ""
":numref:`fig5-2` は典型的な章ロード・スクリーンを示しています。 "
"ここでロードされるスクリーンは相対番号指定です。アプリケーション・ロード・スクリーンでの絶対番号指定とは異なります。"

#: ../../chapter5.rst:225
msgid ""
"This is because the chapter-load screen is the first screen of the "
"contiguous range of screens in the chapter. You can move an entire "
"chapter forward or backward within the listing; the relative pointers in "
"the chapter-load screen are position-independent. All you have to change "
"is the single number in the application-load screen that points to the "
"beginning of the chapter."
msgstr ""
"これは、章ロード・スクリーンが章内の連続したスクリーン範囲の最初のスクリーンであるためです。 リスト内で章全体を前後に移動できます。 "
"章ロード・スクリーンの相対ポインタは絶対位置に依存しません。 "
"変更する必要があるのは、アプリケーション・ロード・スクリーンの1つの数字だけで、章の先頭を指しています。"

#: ../../chapter5.rst:232
msgid "Example of a chapter-load screen."
msgstr "章ロード・スクリーンの例"

#: ../../chapter5.rst:234
msgid "Screen #100"
msgstr "Screen #100"

#: ../../chapter5.rst:251
msgid ""
"Use absolute screen numbers in the application-load screen.  Use relative"
" screen numbers in the chapter- or section-load screens."
msgstr ""
"アプリケーション・ロード・スクリーンでは絶対スクリーン番号を使用してください。 "
"章ロードまたは節ロード・スクリーンでは、相対的なスクリーン番号を使用してください。"

#: ../../chapter5.rst:254
msgid ""
"There are two ways to implement relative loading. The most common is to "
"define:"
msgstr "相対ロードを実装する方法は2つあります。 最も一般的なのは以下です。"

#: ../../chapter5.rst:261
msgid "and"
msgstr "そして"

#: ../../chapter5.rst:268
msgid ""
"My own way, which I submit as a more useful factoring, requires a single "
"word, ``FH`` (see :doc:`Appendix C<appendixc>` for its definition)."
msgstr ""
"私流の、より有用なファクタリング(要素分解)として提示する方法は、単一のワード ``FH`` を必要とします(その定義については "
":doc:`付録C<appendixc>` 参照)。"

#: ../../chapter5.rst:271
msgid "The phrase"
msgstr "それはこんなフレーズです。"

#: ../../chapter5.rst:277
msgid "is read “1 from here ``LOAD``,” and is equivalent to 1 ``+LOAD``."
msgstr "「1 From Here load」(ここから1へだたったスクリーンをロード)と読みます。これは「1 ``+LOAD`` 」と同じです。"

#: ../../chapter5.rst:279
msgid "Similarly,"
msgstr "同様に、"

#: ../../chapter5.rst:285
msgid "is read “2 from here, 5 from here ``THRU``.”"
msgstr ""
"「2 from here, 5 from here ``THRU`` "
"」(ここから1へだったったところから、ここから5へだたったところまで、通しで)と読みます。"

#: ../../chapter5.rst:287
msgid "Some programmers begin each chapter with a dummy word; e.g.,"
msgstr "プログラマの中には各章をダミーのワードで始める人もいます。"

#: ../../chapter5.rst:293
msgid ""
"and list its name in the comment on the line where the chapter is loaded "
"in the application-load screen. This permits selectively ``FORGET`` ting "
"any chapter and reloading from that point on without having to look at "
"the chapter itself."
msgstr ""
"アプリケーション・ロード・スクリーンで章がロードされている行のコメントにその名前をリストします。 "
"これにより、章自体を見なくても、任意の章を選択して、 ``FORGET`` してその場所からリロードできます。"

#: ../../chapter5.rst:298
msgid ""
"Within a chapter the first group of screens will usually define those "
"variables, constants, and other data structures needed globally within "
"the chapter. Following that will come the lexicons, loaded in “uses” "
"order. The final lines of the chapter-load screen normally invoke any "
"needed initialization commands."
msgstr ""
"章の中では、最初のグループのスクリーンは通常、章の中でグローバルに必要とされるそれらの変数、定数、および他のデータ構造を定義します。 "
"それに続いて「用途」順にロードされる用語集が来るでしょう。 章ロード・スクリーンの最後の行は、通常、必要な初期化コマンドを呼び出します。"

# Forthwrights wright=職人
#: ../../chapter5.rst:304
msgid ""
"Some of the more style-conscious Forthwrights begin each chapter with a "
"“preamble” that discusses in general terms the theory of operation for "
"the components described in the chapter. :numref:`fig5-3`  is a sample "
"preamble screen which demonstrates the format required at Moore Products "
"Co."
msgstr ""
"よりスタイルを意識したForth職人の中には、各章の冒頭に、その章で説明されているコンポーネントの動作を一般的な用語で説明したものがあります。 "
":numref:`fig5-3` は、ムーアプロダクツ社書式の前書きスクリーンの例です。"

#: ../../chapter5.rst:310
msgid "Moore Products Co.'s format for chapter preambles."
msgstr "ムーアプロダクツ社書式の章前書き"

#: ../../chapter5.rst:312
msgid "Screen #101"
msgstr "Screen #101"

#: ../../chapter5.rst:330
msgid "Screen #102"
msgstr "Screen #102"

#: ../../chapter5.rst:355
msgid ""
"**Charles Moore** (no relation to Moore Products Co.) places less "
"importance on the well-organized hierarchical listing than I do. Moore:"
msgstr ""
"**チャールズ・ムーア** (ムーアプロダクツ社とは無関係です) "
"は、私と違って、yよく整理された階層型リストをあまり重要視しません。ムーアは言います。"

#: ../../chapter5.rst:348
msgid ""
"I structure **applications** hierarchically, but not necessarily "
"**listings.**  My listings are organized in a fairly sloppy way, not at "
"all hierarchically in the sense of primitives first."
msgstr "私はアプリケーションを階層的に構成しますが、必ずしもリストではありません。私のリストはかなりずさんな編成になっています。原始的なのから始めると言う意味で階層的ではありません。"

#: ../../chapter5.rst:352
msgid ""
"I use ``LOCATE`` [also known as ``VIEW``; see the Handy Hint in "
"**Starting Forth**, Chapter Nine].  As a result, the listing is much less"
" carefully organized because I have ``LOCATE`` to find things for me.  I "
"never look at listings."
msgstr ""
"私は ``LOCATE`` を使います( ``VIEW`` としても知られています。 **Starting Forth** のChapter 9 "
"Handy Hint;邦訳 FORTH入門 第9章、「知っていると便利です ソース定義を ``LOCATE`` する方法」P.291)。 "
"その結果、リストはそれほど慎重に整理されていません。なぜなら、``LOCATE`` "
"が、私の探しているものを探し出してくれるからです。私はリストを見たことがありません(訳注: ``LOCATE`` "
"は、指定のワードの定義箇所を、スクリーン群から検索)。"

#: ../../chapter5.rst:358
msgid "––> vs. THRU"
msgstr "––> 対 THRU"

#: ../../chapter5.rst:360
msgid ""
"On the subject of relative loading, one popular way to load a series of "
"adjacent screens is with the word ``-->`` (pronounced “next block”). This"
" word causes the interpreter to immediately cease interpreting the "
"current screen and begin interpreting the next (higher-numbered) screen."
msgstr ""
"相対ロードの問題では、一連の隣接するスクリーンをロードするための一般的な方法の1つは、ワード ``-->`` (「ネクスト・ブロック(next-"
"block)」と発音)を使用することです。 "
"このワードにより、インタプリタは直ちに現在のスクリーンの解釈を中止し、次の(大きい番号の)スクリーンの解釈を開始します。"

#: ../../chapter5.rst:366
msgid ""
"If your system provides ``-->``, you must choose between using the "
"``THRU`` command in your chapter-load screen to load each series of "
"screens, or linking each series together with the arrows and LOADing only"
" the first in the series. (You can’t do both; you’d end up loading most "
"of the screens more than once.)"
msgstr ""
"あなたのシステムが ``-->`` を提供している場合は、章ロード・スクリーンで ``THRU`` "
"コマンドを使用して一連のスクリーンをロードするか、一連のスクリーンを ``-->`` "
"でリンクして最初のものだけをロードするかを選択する必要があります(両方を行うことはできません。両方使うと、ほとんどのスクリーンを複数回読み込むことになります)。"

#: ../../chapter5.rst:373
msgid ""
"The nice thing about the arrows is this: suppose you change a screen in "
"the middle of a series, then reload the screen. The rest of the series "
"will automatically get loaded. You don’t have to know what the last "
"screen is."
msgstr ""
"``-->`` のいいところは、あなたが一連のシリーズの途中でスクリーンを変えて、それからスクリーンをリロードすると仮定してください。 "
"残りスクリーンは自動的に再ロードされます。 最後のスクリーンが何であるかを知る必要がありません。"

#: ../../chapter5.rst:378
msgid ""
"That’s also the nasty thing about the arrows: There’s no way to stop the "
"loading process once it starts. You may compile a lot more screens than "
"you need to test this one screen."
msgstr ""
"それは ``-->`` について厄介な事でもあります。いったんロードを開始すると一連のロードプロセスを止める方法はありません。 "
"あなたは1つのスクリーンをテストするのに、必要な数よりもはるかに多くのスクリーンをコンパイルすることになります。"

#: ../../chapter5.rst:382
msgid ""
"To get analytical about it, there are three things you might want to do "
"after making the change just described:"
msgstr "それについて分析するために、今述べた変更を加えた後に、あなたがしたいと思う事は3つでしょうか。"

#: ../../chapter5.rst:385
msgid "load the one screen only, to test the change,"
msgstr "変更をテストするために1つのスクリーンのみをロードしたい。"

#: ../../chapter5.rst:387
msgid "load the entire section in which the screen appears,"
msgstr "スクリーンがある節全体を読み込たい。"

#: ../../chapter5.rst:389 ../../chapter5.rst:1303 ../../chapter5.rst:1704
#: ../../chapter5.rst:2038
msgid "or"
msgstr "または"

#: ../../chapter5.rst:391
msgid "load the entire remainder of the application."
msgstr "アプリケーションの残りの部分全体をロードしたい。"

#: ../../chapter5.rst:393
msgid "The use of ``THRU`` seems to give you the greatest control."
msgstr "この操作には ``THRU`` を使うの最適に思えます。"

#: ../../chapter5.rst:396
msgid ""
"Some people consider the arrow to be useful for letting definitions cross"
" screen boundaries. In fact ``-->`` is the only way to compile a high-"
"level (colon) definition that occupies more than one screen, because "
"``-->`` is “immediate.” But it’s *never* good style to let a colon "
"definition cross screen boundaries. (They should never be that long!)"
msgstr ""
"何人かの人々は、定義がスクリーンの境界を越えることを可能にする ``-->`` 役に立つと考えています。 実は ``-->`` "
"は、複数のスクリーンに渡る高水準(コロン)定義をコンパイルする唯一の方法です。なぜなら ``-->`` "
"は「即実行(immediate)」だからです。しかし、コロン定義をスクリーン境界を越えさせるのは決して良いスタイルではありません(定義はそんなに長くなるべきではありません！）。"

#: ../../chapter5.rst:402
msgid ""
"On the other hand, an extremely complicated and time-critical piece of "
"assembler coding might occupy several sequential screens. In this case, "
"though, normal ``LOAD`` ing will do just as well, since the assembler "
"does not use compilation mode, and therefore does not require immediacy."
msgstr ""
"一方、非常に複雑でタイムクリティカルなアセンブラコーディングは、いくつかの連続したスクリーンを占有する可能性があります。 "
"ただしこの場合、アセンブラはコンパイルモードを使用せず、したがって即実行(immediate)は必要ないため、通常の ``LOAD`` "
"処理も同様に実行できます。"

#: ../../chapter5.rst:408
msgid ""
"Finally, the arrow wastes an extra line of each source screen. We don’t "
"recommend it."
msgstr "おまけに、 ``-->`` は、各ソーススクリーンの余分な行を無駄にします。 お勧めしません。"

#: ../../chapter5.rst:412
msgid "An Alternative to Screens: Source in Named Files"
msgstr "スクリーンの代替：名前付きファイル内のソース"

#: ../../chapter5.rst:414
msgid ""
"Some Forth practitioners advocate storing source code in variable-length,"
" named text files, deliberately emulating the approach used by "
"traditional compilers and editors. This approach may become more and more"
" common, but its usefulness is still controversial."
msgstr "幾人かのForthの専門家は、伝統的なコンパイラやエディタが使っているアプローチをわざわざエミュレートして、可変長の名前付きテキストファイルにソースコードを格納することを主張しています。このアプローチはますます一般的になるかもしれませんが、その有用性はまだ物議をかもしています。"

#: ../../chapter5.rst:420
msgid ""
"Sure, it’s nice not to have to worry about running out of room in a "
"screen, but the hassle of writing in a restricted area is compensated for"
" by retaining control of discrete chunks of code. In developing an "
"application, you spend a lot more time loading and reloading screens than"
" you do rearranging their contents."
msgstr ""
"確かに、スクリーンのスペースを使い果たすことを心配しなくてもいいのですが、制限された領域に書くわずわらしさは、コードの塊に細心の注意を払って御し続けることで補われます。"
" アプリケーションの開発では、スクリーンの内容を並べ替えるよりもはるかに多くの時間をかけてスクリーンのロードと再ロードを行います。"

#: ../../chapter5.rst:426
msgid ""
"“Infinite-length” files allow sloppy, disorganized thinking and bad "
"factoring. Definitions become longer without the discipline imposed by "
"the 1K block boundaries. The tendency becomes to write a 20K file, or "
"worse: a 20K definition."
msgstr ""
"「長さ制限のない」ファイルは、ずさんな、無秩序な思考と悪いファクタリング(要素分解)を可能にします。 "
"1Kブロック境界によって課される規律がないと、定義は長くなります。 "
"20Kのファイルを書く、あるいはもっと悪いことに、20Kの定義を書くようになります。"

#: ../../chapter5.rst:431
msgid ""
"Perhaps a nice compromise would be a file-based system that allows nested"
" loading, and encourages the use of very small named files. Most likely, "
"though, the more experienced Forth programmers would not use named files "
"longer than 5K to 10K. So what’s the benefit?"
msgstr ""
"おそらく、妥協の余地があるのは、ネストされたロードを可能にし、非常に小さな名前付きファイルの使用を推奨するファイルベースのシステムでしょう。 "
"もっとも、たぶん、経験豊富なForthプログラマは5Kから10Kより長い名前付きファイルを使用しないでしょう。 では、そのメリットは何でしょうか？"

#: ../../chapter5.rst:437
msgid ""
"Some might answer that rhetorical question: “It’s easier to remember "
"names than numbers.” If that’s so, then predefine those block numbers as "
"constants, e.g.:"
msgstr "そのような修辞的な質問に答える人もいるかもしれません。「数字よりも名前を覚える方が簡単だ」そうであれば、それらのブロック番号を定数として事前定義してください。"

#: ../../chapter5.rst:445
msgid "Then to load the “framing” section, enter"
msgstr "以降、``FRAMING`` 節をロードするには、以下のようにします。"

#: ../../chapter5.rst:451
msgid "Or, to list the section’s load block, enter"
msgstr "また、その節のロードブロックをリストするなら、以下のようにします。"

#: ../../chapter5.rst:457
msgid "(It’s a convention that names of sections end in “ING.”)"
msgstr "(節名は「ING」で終わるのが慣例です)"

#: ../../chapter5.rst:459
msgid ""
"Of course, to minimize the hassle of the screen-based approach you need "
"good tools, including editor commands that move lines of source from one "
"screen to another, and words that slide a series of screens forward or "
"back within the listing."
msgstr "もちろん、スクリーンベースのアプローチの煩わしさを最小限に抑えるためには、あるスクリーンから別のスクリーンにソースの行を移動するエディタコマンドや、一連のスクリーンをリスト内で前後にスライドさせるワードなど、優れたツールが必要です。"

#: ../../chapter5.rst:465
msgid "Disk Partitioning"
msgstr "ディスク割り当て"

#: ../../chapter5.rst:467
msgid ""
"The final aspect of the well-organized listing involves standardizing an "
"arrangement for what goes where on the disk. These standards must be set "
"by each shop, or department, or individual programmer, depending on the "
"nature of the work."
msgstr "よく整理されたリストの最後の側面は、ディスクの何処に何を配置するかの標準化です。会社ごと・部門ごと・個々のプログラマーごと・作品の性質ごとに標準を設定する必要があります。"

#: ../../chapter5.rst:473
msgid "Example of a disk-partitioning scheme within one department."
msgstr "ある部門のディスク割当体系サンプル"

#: ../../chapter5.rst:477
msgid "Screen 0"
msgstr "Screen 0"

#: ../../chapter5.rst:478
msgid ""
"is the title screen, showing the name of the application, the current "
"release number, and primary author."
msgstr "アプリケーションの名前、現在のリリース番号、および一次著者を示すタイトル・スクリーンです。"

#: ../../chapter5.rst:480
msgid "Screen 1"
msgstr "Screen 1"

#: ../../chapter5.rst:481
msgid "is the application-load block."
msgstr "アプリケーション・ロード・ブロック"

#: ../../chapter5.rst:482
msgid "Screen 2"
msgstr "Screen 2"

#: ../../chapter5.rst:483
msgid "is reserved for possible continuation from Screen 1"
msgstr "スクリーン1に収まらず継続が必要な時の為に予約されています。"

#: ../../chapter5.rst:484
msgid "Screen 4 and 5"
msgstr "Screen 4 and 5"

#: ../../chapter5.rst:485
msgid "contain system messages."
msgstr "システムメッセージが含まれています。"

#: ../../chapter5.rst:486
msgid "Screens 9 thru 29"
msgstr "Screens 9 thru 29"

#: ../../chapter5.rst:487
msgid ""
"incorporate general utilities needed in, but not restricted to, this "
"application."
msgstr "ここに、このアプリケーションに必要な、ただしこれに限定されない一般的なユーティリティを組み込みます。"

#: ../../chapter5.rst:489
msgid "Screen 30"
msgstr "Screen 30"

#: ../../chapter5.rst:490
msgid "begins the application screens."
msgstr "ここからアプリケーション・スクリーン開始です。"

#: ../../chapter5.rst:492
msgid ":numref:`fig5-4`  shows a typical department’s partitioning scheme."
msgstr ":numref:`fig5-4` は典型的な部門での割り当て方です。"

#: ../../chapter5.rst:494
msgid ""
"In many Forth shops it’s considered desirable to begin sections of code "
"on screen numbers that are evenly divisible by three. Major divisions on "
"a disk should be made on boundaries evenly divisible by thirty."
msgstr ""
"多くのForthの会社では、3で割り切れるスクリーン番号でコード節を始めることが望ましいと考えられています。 "
"ディスク上の主要な分割は、30スクリーン毎に行われるべきです。"

#: ../../chapter5.rst:499
msgid ""
"The reason? By convention, Forth screens are printed three to a page, "
"with the top screen always evenly divisible by three. Such a page is "
"called a “triad;” most Forth systems include the word ``TRIAD`` to "
"produce it, given as an argument the number of any of the three screens "
"in the triad. For instance, if you type"
msgstr ""
"なぜか？ 慣例により、Forthのスクリーンは1ページに3つ出力され、出力時のトップスクリーンは常に3で均等に割り切れます。 "
"そのようなページは「トライアド(triad)」と呼ばれます。ほとんどのForthシステムはトライアドの3つのスクリーンのうちのどれかの番号を引数として与えられてそれを生成するためのワード"
" ``TRIAD`` を含んでいます。 例えば以下のようにタイプすると、"

#: ../../chapter5.rst:509
msgid "you’ll get a page that includes 75, 76, and 77."
msgstr "あなたは75,76,77を含むページを得ます。"

#: ../../chapter5.rst:511
msgid ""
"The main benefit of this convention is that if you change a single "
"screen, you can slip the new triad right into your binder containing the "
"current listing, replacing exactly one page with no overlapping screens."
msgstr "この慣例の主な利点は、単一のスクリーンを変更した場合、現在表示されているリストを含むバインダーに新しいトライアドを入れて、重複するスクリーンがない1ページだけを置き換えられることです。"

#: ../../chapter5.rst:515
msgid ""
"Similarly, the word ``INDEX`` lists the first line of each screen, 60 per"
" page, on boundaries evenly divisible by 60."
msgstr "同様に、ワード ``INDEX`` は各スクリーンの最初の行を1ページに60ずつ、60で割り切れる境界毎に出力します。"

#: ../../chapter5.rst:520
msgid ""
"Begin sections or lexicons on screen numbers evenly divisible by three. "
"Begin applications or chapters on screen numbers evenly divisible by "
"thirty."
msgstr "節または用語集のスクリーン番号を常に3で割り切れる数で初めます。アプリケーションや章のスクリーン番号を常に30で割り切れる数で初めます。"

#: ../../chapter5.rst:525
msgid "Electives"
msgstr "選択"

#: ../../chapter5.rst:527
msgid ""
"Vendors of Forth systems have a problem. If they want to include every "
"command that the customer might expect—words to control graphics, "
"printers, and other niceties—they often find that the system has swollen "
"to more than half the memory capacity of the computer, leaving less room "
"for serious programmers to compile their applications. The solution is "
"for the vendor to provide the bare bones as a precompiled nucleus, with "
"the extra goodies provided in *source* form. This approach allows the "
"programmer to pick and choose the special routines actually needed."
msgstr "Forthシステムのベンダーは問題を抱えています。顧客が期待するすべてのコマンド（グラフィック、プリンタ、その他の機能を制御するためのワード）を含めたい場合は、システムがコンピュータのメモリ容量の半分以上に膨れ上がっていることがよくあります。それはプログラマがアプリケーションをコンパイルする余地を少なくします。解決策は、ベンダーが、「ソース形式」で提供される追加の機能とともに、その他の機能をプリコンパイル済バイナリを提供することです。このアプローチにより、プログラマは実際に必要なルーチンを選ぶことができます。"

#: ../../chapter5.rst:537
msgid ""
"These user-loadable routines are called “electives.” Double-length "
"arithmetic, date and time support, ``CASE`` statements and the "
"``DOER/MAKE`` construct (described later) are some of the features that "
"Forth systems should offer as electives."
msgstr ""
"これらのユーザロード可能なルーチンは 「選択機能(electives)」と呼ばれます。倍長演算、日付と時刻のサポート、 ``CASE`` 文、 "
"``DOER/MAKE`` 組（後述）は、Forthシステムが選択機能として提供する機能の一部です。"

#: ../../chapter5.rst:543
msgid "Screen Layout"
msgstr "スクリーンレイアウト"

#: ../../chapter5.rst:545
msgid "In this section we’ll discuss the layout of each source screen."
msgstr "この節では、各ソース・スクリーンのレイアウトについて説明します。"

#: ../../chapter5.rst:549
msgid "Reserve Line 0 as a \"comment line.\""
msgstr "行0は「コメント行」として確保して下さい。"

#: ../../chapter5.rst:551
msgid ""
"The comment line serves both as a heading for the screen, and also as a "
"line in the disk ``INDEX``. It should describe the purpose of the screen "
"(not list the words defined therein)."
msgstr ""
"コメント行は、スクリーンの見出しとしても、ディスクを``INDEX`` した時の行としても役立ちます。 "
"それはスクリーンの目的を説明するべきです（そこに定義されたワードをリストしないでください）。"

#: ../../chapter5.rst:555
msgid ""
"The comment line minimally contains the name of the screen. In larger "
"applications, you may also include both the chapter name and screen name."
" If the screen is one of a series of screens implementing a lexicon, you "
"should include a “page number” as well."
msgstr ""
"コメント行には、少なくともスクリーン名が含まれています。 大規模なアプリケーションでは、章名とスクリーン名の両方を含めることもできます。 "
"スクリーンが用語集を実装する一連のスクリーンの1つである場合は、「ページ番号」も含める必要があります。"

#: ../../chapter5.rst:560
msgid ""
"The upper right hand corner is reserved for the “stamp.” The stamp "
"includes the date of latest revision and, when authorship is important, "
"the programmer’s initials (three characters to the left of the date); "
"e.g.:"
msgstr "スクリーンの右上隅は「タイムスタンプ」のために予約します。タイムスタンプには最新の改訂日が含まれ、作成者が重要な場合はプログラマのイニシャル（日付の左に3文字）を含めます。例えば、"

#: ../../chapter5.rst:569
msgid "Some Forth editors will enter the stamp for you at the press of a key."
msgstr "Forthエディタの中には、あるキーを押すだけでタイムスタンプを入力できるものもあります。"

#: ../../chapter5.rst:571
msgid "A common form for representing dates is"
msgstr "日付を表すための一般的な形式は、"

#: ../../chapter5.rst:577
msgid "that is, February 6, 1984 would be expressed"
msgstr "1984年2月6日なら、"

#: ../../chapter5.rst:583
msgid "An increasingly popular alternative uses"
msgstr "最近よく使われるようになった形式は、"

#: ../../chapter5.rst:589
msgid "where “Mmm” is a three-letter abbreviation of the month. For instance:"
msgstr "「Mmm」は(英語で)月を表す名前の3文字の略語です。"

#: ../../chapter5.rst:595
msgid "This form requires fewer characters than"
msgstr "上記の形式は下記より少ない文字数で書けます。"

#: ../../chapter5.rst:601
msgid "and eliminates possible confusion between dates and months."
msgstr "そして、どっちが日でどっちが月か混乱する可能性を排除します。"

#: ../../chapter5.rst:603
msgid ""
"If your system has ``\\`` (“skip-line”—see :doc:`Appendix C<appendixc>`),"
" you can write the comment line like this:"
msgstr ""
"システムに ``\\`` (スキップ・ライン(skip-line) :doc:`付録C<appendixc>` "
"参照))がある場合は、次のようにコメント行を書くことができます。"

#: ../../chapter5.rst:610
msgid ""
"As with all comments, use lower-case or a mixture of lower- and upper-"
"case text in the comment line."
msgstr "すべてのコメントと同様に、コメント行には小文字または大文字と小文字の混在を使用してください。"

#: ../../chapter5.rst:613
msgid ""
"One way to make the index of an application reveal more about the "
"organization of the screens is to indent the comment line by three spaces"
" in screens that continue a lexicon.  :numref:`fig5-5` shows a portion of"
" a list produced by ``INDEX`` in which the comment lines for the "
"continuing screens are indented."
msgstr ""
"アプリケーションの索引でスクリーンの整理に関する詳細を明確にする1つの方法は、用語集の継続するスクリーン内のコメント行を3つのスペースでインデントすることです。"
" :numref:`fig5-5` は ``INDEX`` "
"によって生成されたリストの一部を示しており、そこでは継続しているスクリーンのコメント行がインデントされています。"

#: ../../chapter5.rst:622
msgid "The output of ``INDEX`` showing indented comment lines."
msgstr "インデントされたコメント行を示す ``INDEX`` の出力。"

#: ../../chapter5.rst:643
msgid ""
"Begin all definitions at the left edge of the screen, and define only one"
" word per line."
msgstr "すべての定義を画面の左端から始めて、1行に1ワードだけ定義してください。"

#: ../../chapter5.rst:646
msgid "*Bad:*"
msgstr "悪い例"

#: ../../chapter5.rst:652 ../../chapter5.rst:792 ../../chapter5.rst:805
#: ../../chapter5.rst:818 ../../chapter5.rst:1399
msgid "*Good:*"
msgstr "良い例"

#: ../../chapter5.rst:659
msgid ""
"This rule makes it easier to find a definition in the listing. (When "
"definitions continue for more than one line, the subsequent lines should "
"always be indented.) ``VARIABLE`` s and ``CONSTANT`` s should also be "
"defined one per line. (See “Samples of Good Commenting Style” in "
":doc:`Appendix E<appendixe>`) This leaves room for an explanatory comment"
" on the same line. The exception is a large “family” of words (defined by"
" a common defining-word) which do not need unique comments:"
msgstr ""
"このルールにより、リスト内で定義を見つけやすくなります(定義が複数の行にわたって続く場合は、後続の行は常に字下げされるべきです)。 "
"``VARIABLE`` と ``CONSTANT`` も1行に1つ定義されるべきです( :doc:`付録E<appendixe>` の "
"「良いコメントスタイルのサンプル」 を参照)。 これは同じ行に説明コメントを書く余地を残します。 "
"例外は、ユニークなコメントを必要としない、大規模な「ファミリー」のワード（共通の定義用のワードによって定義される）です。"

#: ../../chapter5.rst:675
msgid "Leave lots of room at the bottom of the screen for later additions."
msgstr "後で追加できるように、スクリーンの下部に十分なスペースを確保してください。"

#: ../../chapter5.rst:677
msgid ""
"On your first pass, fill each screen no more than half with code. The "
"iterative approach demands that you sketch out the components of your "
"application first, then iteratively flesh them out until all the "
"requirements are satisfied. Usually this means adding new commands, or "
"adding special-case handling, to existing screens. (Not *always,* though."
" A new iteration may see a simplification of the code. Or a new "
"complexity may really belong in another component and should be factored "
"out, into another screen.)"
msgstr ""
"最初の試行で、各スクリーンを半分以下のコードで埋めます。 "
"反復的なアプローチでは、最初にアプリケーションのコンポーネントをスケッチしてから、すべての要件が満たされるまでそれらを反復的に作成する必要があります。"
" "
"通常これは、既存のスクリーンに新しいコマンドを追加すること、または特殊なケースの処理を追加することを意味します(常にではありませんが、新しい反復でコードが単純化されることもあります。または、新しい複雑さが別のコンポーネントに属しているため、別のスクリーンにまとめて表示する必要があったりします)。"

#: ../../chapter5.rst:686
msgid ""
"Leaving plenty of room at the outset makes later additions more pleasant."
" One writer recommends that on the initial pass, the screen should "
"contain about 20–40 percent code and 80–60 percent whitespace "
"[stevenson81]_ ."
msgstr ""
"最初に十分なスペースを残すことで、後で追加することがより快適になります。 "
"ある作家は、最初のパスで、画面には20から40パーセントのコードと80から60パーセントの空白を含めることを推奨します。 "
"[stevenson81]_"

#: ../../chapter5.rst:691
msgid ""
"Don’t skip a line between each definition. You may, however, skip a line "
"between *groups* of definitions."
msgstr "各定義の間にある行をスキップしないでください。 ただし、定義の「グループ間」の行をスキップすることはできます。"

#: ../../chapter5.rst:696
msgid "All screens must leave ``BASE`` set to ``DECIMAL``."
msgstr "すべてのスクリーンは ``BASE`` を ``DECIMAL`` に設定したままにしてください。"

#: ../../chapter5.rst:698
msgid ""
"Even if you have three screens in a row in which the code is written in "
"``HEX`` (three screens of assembler code, for instance), each screen must"
" set ``BASE`` to ``HEX`` at the top, and restore base to ``DECIMAL`` at "
"the bottom. This rule ensures that each screen could be loaded "
"separately, for purposes of testing, without mucking up the state of "
"affairs. Also, in reading the listing you know that values are in decimal"
" unless the screen explicitly says ``HEX``."
msgstr ""
"コードが ``HEX`` で書かれている3つのスクリーンが並んでいる場合でも(例えば3つのスクリーンのアセンブラコード)、それぞれのスクリーンは "
"``BASE`` を ``HEX`` に設定しなければなりません。 そして底を一番下で ``DECIMAL`` に戻します。 "
"このルールにより、テストの目的で、問題の状況を気にすることなく、各スクリーンを個別にロードできます。 また、リストを読むと、スクリーンに明示的に "
"``HEX`` と表示されていない限り、値は10進数であることがわかります。"

#: ../../chapter5.rst:707
msgid ""
"Some shops take this rule even further. Rather than brashly resetting "
"base to ``DECIMAL`` at the end, they reset base to *whatever it was at "
"the beginning.* This extra bit of insurance can be accomplished in this "
"fashion:"
msgstr ""
"いくつかの会社はさらに以下のルールを設定しています。 最後に基数を ``DECIMAL`` "
"にリセットするのではなく、何でも最初の基数にリセットします。この追加の保証は、次のようにして実現できます。"

#: ../../chapter5.rst:720
msgid ""
"Sometimes an argument is passed on the stack from screen to screen, such "
"as the value returned by ``BEGIN`` or ``IF`` in a multiscreen assembler "
"definition, or the base address passed from one defining word to "
"another—see “Compile-Time Factoring” in :doc:`Chapter Six<chapter6>`. In "
"these cases, it’s best to save the value of ``BASE`` on the return stack "
"like this:"
msgstr ""
"マルチスクリーンアセンブラの定義で ``BEGIN`` や ``IF`` "
"によって返される値、ある定義語から別の定義語に渡されるベースアドレスなど、引数がスクリーンからスクリーンに渡されることがあります( "
":doc:`第6章<chapter6>` の「コンパイル時のファクタリング(要素分解)」を参照)。 このような場合、以下のようにリターンスタックに"
" ``BASE`` の値を保存するのが最善です。"

#: ../../chapter5.rst:733
msgid ""
"Some folks make it a policy to use this approach on any screen that "
"changes ``BASE``, so they don’t have to worry about it."
msgstr ""
"何人かの人々は ``BASE`` "
"を変えるどんなスクリーンでもこのアプローチを使うことを方針にしている、そうすることで彼らはそれについて心配する必要が無くなります。"

#: ../../chapter5.rst:736
msgid ""
"Moore prefers to define ``LOAD`` to invoke ``DECIMAL`` after loading. "
"This approach simplifies the screen’s contents because you don’t have to "
"worry about resetting."
msgstr ""
"ムーアはロード後に ``DECIMAL`` を呼び出ように ``LOAD`` を定義することを好みます。 "
"リセットすることを心配する必要がないため、この方法だとスクリーンの内容が簡単になります。"

#: ../../chapter5.rst:741
msgid "Spacing and Indentation"
msgstr "空白とインデント"

#: ../../chapter5.rst:745
msgid "Spacing and indentation are essential for readability."
msgstr "空白とインデントは読みやすさの必需品です。"

#: ../../chapter5.rst:747
msgid ""
"The examples in this book use widely accepted conventions of spacing and "
"indenting style. Whitespace, appropriately used, lends readability. "
"There’s no penalty for leaving space in source screens except disk "
"memory, which is cheap."
msgstr ""
"本書の例では、広く受け入れられているスペースと字下げスタイルの規則を使用しています。 適切に使用される空白は読みやすさを向上させます。 "
"安価なディスクメモリを除いて、ソース・スクリーンにスペースを空けることによるペナルティはありません。"

#: ../../chapter5.rst:752
msgid ""
"For those who like their conventions in black and white, Table "
":numref:`tab-5-1` is a list of guidelines. (But remember, Forth’s "
"interpreter couldn’t care less about spacing or indentation.)"
msgstr ""
"白黒はっきりした規約を好む人のために、表 :numref:`tab-5-1` "
"はガイドラインの一覧です（ただし、Forthのインタプリタはスペースやインデントにあまり気を遣いません）。"

#: ../../chapter5.rst:756
msgid "Indentation and spacing guidelines"
msgstr "字下げと空白のガイドライン"

#: ../../chapter5.rst:759
msgid "1 space between the colon and the name"
msgstr "空白1つだけ空けるのはコロンと名前の間。"

#: ../../chapter5.rst:760
msgid "2 spaces between the name and the comment [#f1]_"
msgstr "空白2つだけ空けるのは名前とコメントの間。 [#f1]_"

#: ../../chapter5.rst:761
msgid ""
"2 spaces, or a carriage return, after the comment and before the "
"definition [#f1]_"
msgstr "2つの空白か改行入れるのは、 コメントの後と、定義の前。 [#f1]_"

#: ../../chapter5.rst:763
msgid "3 spaces between the name and definition if no comment is used"
msgstr "3つの空白空けるのは、コメントが無い時の名前とその定義の間。"

#: ../../chapter5.rst:764
msgid ""
"3 spaces indentation on each subsequent line (or multiples of 3 for "
"nested indentation)"
msgstr "3つの空白で字下げするのは後続の各行(入れ子になった場合は更に3の倍数)。"

#: ../../chapter5.rst:766
msgid "1 space between words/numbers within a phrase"
msgstr "1つの空白空けるのは、句の中の、ワードや数字の間。"

#: ../../chapter5.rst:767
msgid "2 or 3 spaces between phrases"
msgstr "2か3の空白空けるのは句と句の間。"

#: ../../chapter5.rst:768
msgid "1 space between the last word and the semicolon"
msgstr "1つの空白空けるのは最後のワードとセミコロンの間。"

#: ../../chapter5.rst:769
msgid "1 space between semicolon and ``IMMEDIATE`` (if invoked)"
msgstr "1つの空白空けるのは、(必要な場合、)セミコロンと ``IMMEDIATE`` の間。"

#: ../../chapter5.rst:771
msgid ""
"No blank lines between definitions, except to separate distinct groups of"
" definitions"
msgstr "グループの異なる定義を区切る場合を除き、定義の間に空白行は挟みません。"

#: ../../chapter5.rst:774
msgid "The last position of each line should be blank except for:"
msgstr "各行の最後は、以下を除いて空白にする必要があります。"

#: ../../chapter5.rst:776
msgid "quoted strings that continue onto the next line, or"
msgstr "次の行に続く引用符付き文字列、または、"

#: ../../chapter5.rst:778
msgid "the end of a comment."
msgstr "コメントの終了。"

#: ../../chapter5.rst:780
msgid ""
"A comment that begins with ``\\`` may continue right to the end of the "
"line. Also, a comment that begins with ``(`` may have its delimiting "
"right parenthesis in the last column."
msgstr ""
"``\\``で始まるコメントは、行末まで続きます。 また、 ``(`` で始まるコメントは、最後の桁で右丸括弧 ``)`` "
"で区切ることができます(訳注： ``(`` はワードだが、右括弧 ``)`` は単なる区切り文字)。"

#: ../../chapter5.rst:784
msgid "Here are some common errors of spacing and indentation:"
msgstr "以下は空白と字下げに関するよくある間違いです。"

#: ../../chapter5.rst:786
msgid "*Bad* (name not separated from the body of the definition):"
msgstr "良くない例(名前がその定義本体と分けられていない)"

#: ../../chapter5.rst:798
msgid "*Bad* (subsequent lines not indented three spaces):"
msgstr "良くない例(継続行が3つの空白で字下げされていない)"

#: ../../chapter5.rst:812
msgid "*Bad* (lack of phrasing):"
msgstr "良くない例(句と句の間が分けられていない)"

#: ../../chapter5.rst:824
msgid ""
"Phrasing is a subjective art; I’ve yet to see a useful set of formal "
"rules. Simply strive for readability."
msgstr ""
"句と句の区切り(phrasing)は主観的な芸術です。 私はまだ役に立つ正式な規則のセットをみつけられていません。 "
"あなたが読みやすくなるよう努力してください。"

#: ../../chapter5.rst:828
msgid ""
"An often-seen alternative calls for 1 space between the name and comment "
"and 3 between the comment and the definition. A more liberal technique "
"uses 3 spaces before and after the comment. Whatever you choose, be "
"consistent."
msgstr ""
"よく見られる代替手段では、名前とコメントの間に1スペース、コメントと定義の間に3スペースが必要です。 "
"より自由な手法では、コメントの前後に3つのスペースを使用します。 あなたは何を選んでも構いませんが、一貫性を保ってください。"

#: ../../chapter5.rst:834
msgid "Comment Conventions"
msgstr "コメント規則"

# narrative
# 物語、物語文学、説話、話術、語り口、(本の会話の部分に対して)語りの部分
#: ../../chapter5.rst:836
msgid ""
"Appropriate commenting is essential. There are five types of comments: "
"stack-effect comments, data-structure comments, input-stream comments, "
"purpose comments and narrative comments."
msgstr ""
"適切なコメントは不可欠です。 "
"コメントは５種類あり、それは、スタック効果コメント、データ構造コメント、入力ストリームコメント、目的コメント、物語コメントです。"

#: ../../chapter5.rst:843
msgid "*A* stack-effect comment"
msgstr "スタック効果コメント"

#: ../../chapter5.rst:841
msgid ""
"shows the arguments that the definition consumes from the stack, and the "
"arguments it returns to the stack, if any."
msgstr "定義がスタックから消費する引数と、もしあれば、それがスタックに返す引数を表します。"

#: ../../chapter5.rst:849
msgid "*A* data-structure comment"
msgstr "データ構造コメント"

#: ../../chapter5.rst:846
msgid ""
"indicates the position and meaning of elements in a data structure. For "
"instance, a text buffer might contain a count in the first byte, and 63 "
"free bytes for text."
msgstr ""
"データ構造内の要素の位置と意味を示します。 "
"たとえば、テキストバッファの最初のバイトにはカウントが含まれ、テキストには63の空きバイトが含まれる可能性があります。"

#: ../../chapter5.rst:855
msgid "*An* input-stream comment"
msgstr "入力ストリームコメント"

#: ../../chapter5.rst:852
msgid ""
"indicates what strings the word expects to see in the input stream. For "
"example, the Forth word ``FORGET`` scans for the name of a dictionary "
"entry in the input stream."
msgstr ""
"入力ストリームでワードがどの文字列を見ることを期待しているかを示します。 たとえば、Forthのワード ``FORGET`` "
"は、入力ストリームから区切り文字によって切り出した文字列をワード名とみなして辞書エントリの名前をスキャンします。"

#: ../../chapter5.rst:860
msgid "*A* purpose comment"
msgstr "目的コメント"

#: ../../chapter5.rst:858
msgid ""
"describes, in as few words possible, what the definition does. How the "
"definition works is not the concern of the purpose comment."
msgstr "可能な限り少ない言葉で、定義が何をするのかを説明します。 定義がどのように機能するかは、目的のコメントの範疇ではありません。"

#: ../../chapter5.rst:866
msgid "*A* narrative comment"
msgstr "物語コメント"

#: ../../chapter5.rst:863
msgid ""
"appears amidst a definition to explain what is going on, usually line-by-"
"line. Narrative comments are used only in the “vertical format,” which "
"we’ll describe in a later section."
msgstr "何が行われているのかを説明する定義の中に、通常は1行ずつ表示されます。 物語コメントは、後の節で説明する「垂直書式」でのみ使用されます。"

#: ../../chapter5.rst:868
msgid ""
"Comments are usually typed in lower-case letters to distinguish them from"
" source code. (Most Forth words are spelled with upper-case letters, but "
"lower-case spellings are sometimes used in special cases.)"
msgstr "コメントは通常、ソースコードと区別するために小文字で入力されます(ほとんどのFortワードは大文字でつづられていますが、小文字のスペルは特別な場合に使われることがあります)。"

#: ../../chapter5.rst:872
msgid ""
"In the following sections we’ll summarize the standardized formats for "
"these types of comments and give examples for each type."
msgstr "次の節では、上記の種類のコメントの標準化された形式を要約し、それぞれの種類の例を示します。"

#: ../../chapter5.rst:876
msgid "Stack Notation"
msgstr "スタック表記"

#: ../../chapter5.rst:880
msgid ""
"Every colon or code definition that consumes and/or returns any arguments"
" on the stack must include a stack-effect comment."
msgstr "スタック上の引数を消費したりスタックに返したりする、全てのコロン定義やコード定義は、スタック効果のコメントを含める必要があります。"

#: ../../chapter5.rst:883
msgid ""
"“Stack notation” refers to conventions for representing what’s on the "
"stack. Forms of stack notation include “stack pictures,” “stack effects,”"
" and “stack-effect comments.”"
msgstr ""
"「スタック表記」とは、スタック上の内容を表すための規則を指します。 "
"スタック表記の形式には、「スタック状態」、「スタック効果」、「スタック効果コメント」があります。"

#: ../../chapter5.rst:889
msgid "Stack Picture"
msgstr "スタック状況"

#: ../../chapter5.rst:891
msgid ""
"A stack picture depicts items understood to be on the stack at a given "
"time. Items are listed from left to right, with the leftmost item "
"representing the bottom of the stack and the rightmost item representing "
"the top."
msgstr ""
"スタック状況は、時系列に積み重ねられていると理解されているアイテムを表しています。 "
"項目は左から右に向かってリストされ、一番左の項目がスタックの一番下(bottom)を表し、一番右の項目が一番上(top)を表します。"

#: ../../chapter5.rst:896
msgid "For instance, the stack picture"
msgstr "スタック状況の例です。"

#: ../../chapter5.rst:902
msgid ""
"indicates two numbers on the stack, with n2 on the top (the most "
"accessible position)."
msgstr "スタック上の2つの数字を示し、n2が一番上(top)（最もアクセスしやすい位置）"

#: ../../chapter5.rst:905
msgid ""
"This is the same order that you would use to type these values in; i.e., "
"if n1 is 100 and n2 is 5000, then you would type"
msgstr "これは、これらの値を入力するのに使用するのと同じ順序です。 つまり、n1が100でn2が5000の場合は、以下の通りタイプします。"

#: ../../chapter5.rst:912
msgid "to place these values correctly on the stack."
msgstr "これらの値をスタックに正確に配置します。"

#: ../../chapter5.rst:914
msgid ""
"A stack picture can include either abbreviations, such as “n1,” or fully "
"spelled-out words. Usually abbreviations are used. Some standard "
"abbreviations appear in Table :numref:`tab-5-2`. Whether abbreviations or"
" fully spelled-out words are used, each stack item should be separated by"
" a space."
msgstr ""
"スタックピクチャには、「n1」などの省略形または完全な綴りの単語を含めることができます。 通常は略語が使用されます。 いくつかの標準的な略語が表 "
":numref:`tab-5-2` にあります。 "
"省略形または完全な綴りの単語のどちらを使用する場合でも、各スタック項目はスペースで区切る必要があります。"

#: ../../chapter5.rst:920
msgid ""
"If a stack item is described with a phrase (such as “address-of-latest-"
"link”), the words in the phrase should be joined by hyphens. For example,"
" the stack picture:"
msgstr ""
"スタック項目が句（「address-of-lastest-"
"link」など）で記述されている場合は、フレーズ内の語をハイフンで結合する必要があります。 たとえば、以下のスタック状況のように。"

#: ../../chapter5.rst:928
msgid "shows three elements on the stack."
msgstr "ここでは、スタック上に3つの要素があります。"

#: ../../chapter5.rst:931
msgid "Stack Effect"
msgstr "スタック効果"

#: ../../chapter5.rst:933
msgid ""
"A “stack effect” shows two stack pictures: one picture of any items that "
"may be *consumed* by a definition, and another picture of any items "
"*returned* by the definition. The “before” picture comes first, followed "
"by two hyphens, then the “after” picture."
msgstr ""
"「スタック効果」は2つのスタック状況を示します。定義によって「消費」される可能性のあるアイテムの1つの状況、および定義によって「返される」任意のアイテムの別の状況です。"
" 「前」の状況が最初に来て、その後に2つのハイフンが続き、次に「後」の状況が続きます。"

#: ../../chapter5.rst:938
msgid "For instance, the stack effect for Forth’s addition operator, ``+`` is"
msgstr "例えば、Forthの加算演算子 ``+`` のスタック効果です。"

#: ../../chapter5.rst:944
msgid "where ``+`` consumes two numbers and returns their sum."
msgstr "ここでは ``+`` は2つの数を消費し、それらの合計を返します。"

#: ../../chapter5.rst:946
msgid ""
"Remember that the stack effect describes only the *net result* of the "
"operation on the stack. Other values that happen to reside on the stack "
"beneath the arguments of interest don’t need to be shown. Nor do values "
"that may appear or disappear while the operation is executing."
msgstr ""
"スタック効果は、スタックに対する操作の「最終結果」のみを記述するということを忘れないでください。 "
"たまたま興味のある引数の下のスタックに存在する他の値を表示する必要はありません。 "
"操作の実行中に表示されたり消えたりする可能性のある値を表示する必要もありません。"

#: ../../chapter5.rst:951
msgid ""
"If the word returns any input arguments unchanged, they should be "
"repeated in the output picture; e.g.,"
msgstr "ワードが入力引数を変更せずに返す場合は、出力状況でそれらを繰り返す必要があります。 たとえば、以下のように。"

#: ../../chapter5.rst:958
msgid ""
"Conversely, if the word changes any arguments, the stack comment must use"
" a different descriptor:"
msgstr "逆に、ワードが引数を変更する場合、スタックコメントは異なる記述子を使用しなければなりません。"

# glossaryは訳すかカタカナか 用語集ではlexiconと混乱しないか。
# とりあえず「ワード集」とする。
#: ../../chapter5.rst:966
msgid "A stack effect might appear in a formatted glossary."
msgstr "スタック効果は、フォーマットされたグロッサリー(ワード集)に表示されることがあります。"

#: ../../chapter5.rst:969
msgid "Stack Effect Comment"
msgstr "スタック効果コメント"

#: ../../chapter5.rst:971
msgid ""
"A “stack-effect comment” is a stack effect that appears in source code "
"surrounded by parentheses. Here’s the stack-effect comment for the word "
"COUNT:"
msgstr "「スタック効果コメント」は、括弧で囲まれたソースコードに現れるスタック効果です。 以下がCOUNTというワードに対するスタック効果のコメントです。"

#: ../../chapter5.rst:979
msgid "or:"
msgstr "または"

#: ../../chapter5.rst:985
msgid "(The “count” is on top of the stack after the word has executed.)"
msgstr "（「count」は、そのワードが実行された後のスタックの一番上にあります。）"

#: ../../chapter5.rst:987
msgid ""
"If a definition has no effect on the stack (that is, no effect the user "
"is aware of, despite what gyrations occur within the definition), it "
"needs no stack-effect comment:"
msgstr "定義がスタックに影響を与えない場合（つまり、定義内で、スタック上に既にある引数を一切使用せず、スタック上に何も返さない場合）、スタック効果コメントは不要です。"

#: ../../chapter5.rst:995
msgid "On the other hand, you may want to use an empty stack comment—i.e.,"
msgstr "しかし、上記のように表記する代わりに、以下のように空のスタックコメントを使用することをおすすめします。"

#: ../../chapter5.rst:1001
msgid "to emphasize that the word has no effect on the stack."
msgstr "こうして、ワードがスタックに影響を及ぼさないことを強調します。"

#: ../../chapter5.rst:1003
msgid ""
"If a definition consumes arguments but returns none, the double-hyphen is"
" optional. For instance,"
msgstr "定義が引数を消費しても何も返さない場合、二連ハイフン「--」はオプションです。 例えば以下。"

#: ../../chapter5.rst:1010
msgid "can be shortened to"
msgstr "以下のように短縮できます。"

#: ../../chapter5.rst:1016
msgid ""
"The assumption behind this convention is this: There are many more colon "
"definitions that consume arguments and return nothing than definitions "
"that consume nothing and return arguments."
msgstr "この規約の背後にある仮定は、引数を消費して何も返さないコロン定義は、何も消費せず引数を返す定義よりも多くあるというものです。"

#: ../../chapter5.rst:1021
msgid "Stack Abbreviation Standards"
msgstr "スタック略語規格"

#: ../../chapter5.rst:1023
msgid ""
"Abbreviations used in stack notation should be consistent. Table "
":numref:`tab-5-2` lists most of the commonly used abbreviations. (This "
"table reappears in :doc:`Appendix E<appendixe>`.) The terms “single-"
"length,” “double-length,” etc. refer to the size of a “cell” in the "
"particular Forth system. (If the system uses a 16-bit cell, “n” "
"represents a 16-bit number; if the system uses a 32-bit cell, “n” "
"represents a 32-bit number.)"
msgstr ""
"スタック表記で使用される略語は一貫しているべきです。 表 :numref:`tab-5-2` "
"は一般的に使われる略語の大部分をリストしています(この表は :doc:`付録E<appendixe>` に再掲)。「1倍長(single-"
"length)」、「2倍長(double-"
"length)」などの用語は、特定のForthシステムにおける「セル(cell)」のサイズを表します（システムが16ビットのセルを使用している場合、「n」は16ビットの数を表し、システムが32ビットのセルを使用している場合、「n」は32ビットの数を表します）。"

#: ../../chapter5.rst:1032
msgid "Notation of Flags"
msgstr "フラグの表記"

#: ../../chapter5.rst:1034
msgid ""
"Table :numref:`tab-5-2` shows three ways to represent a boolean flag. To "
"illustrate, here are three versions of the same stack comment for the "
"word ``-TEXT``:"
msgstr ""
"表 :numref:`tab-5-2` にはブールフラグを表す3つの方法が示されています。ここでは例として、ワード ``-TEXT`` "
"に対する同じスタックコメントの3つのバージョンを示します。"

#: ../../chapter5.rst:1044
msgid "Stack-comment abbreviations."
msgstr "スタックコメントの略語"

#: ../../chapter5.rst:1048
msgid "n"
msgstr "n"

#: ../../chapter5.rst:1049
msgid "single-length signed number"
msgstr "1倍長 符号付整数"

#: ../../chapter5.rst:1050
msgid "d"
msgstr "d"

#: ../../chapter5.rst:1051
msgid "double-length signed number"
msgstr "2倍長 符号付整数"

#: ../../chapter5.rst:1052
msgid "u"
msgstr "u"

#: ../../chapter5.rst:1053
msgid "single-length unsigned number"
msgstr "1倍長 符号無整数"

#: ../../chapter5.rst:1054
msgid "ud"
msgstr "ud"

#: ../../chapter5.rst:1055
msgid "double-length unsigned number"
msgstr "2倍長 符号無整数"

#: ../../chapter5.rst:1056
msgid "t"
msgstr "t"

#: ../../chapter5.rst:1057
msgid "triple-length"
msgstr "3倍長(triple)"

#: ../../chapter5.rst:1058
msgid "q"
msgstr "q"

#: ../../chapter5.rst:1059
msgid "quadruple-length"
msgstr "4倍長(quadruple)"

#: ../../chapter5.rst:1060 ../../chapter5.rst:1230
msgid "c"
msgstr "c"

#: ../../chapter5.rst:1061
msgid "7-bit character value"
msgstr "7ビット キャラクタ値(訳注：ASCII表示文字の範囲)"

#: ../../chapter5.rst:1062
msgid "b"
msgstr "b"

#: ../../chapter5.rst:1063
msgid "8-bit byte"
msgstr "8ビット バイト値"

#: ../../chapter5.rst:1064
msgid "?"
msgstr "?"

#: ../../chapter5.rst:1065
msgid "boolean flag; or;"
msgstr "ブーリアンフラグ。左記または以下、"

#: ../../chapter5.rst:1066
msgid "t="
msgstr "t="

#: ../../chapter5.rst:1067
msgid "true"
msgstr "true"

#: ../../chapter5.rst:1068
msgid "f="
msgstr "f="

#: ../../chapter5.rst:1069
msgid "false"
msgstr "false"

#: ../../chapter5.rst:1070
msgid "a or adr"
msgstr "a or adr"

#: ../../chapter5.rst:1071
msgid "address"
msgstr "アドレス"

#: ../../chapter5.rst:1072
msgid "acf"
msgstr "acf"

#: ../../chapter5.rst:1073
msgid "address of code field"
msgstr "コードフィールドのアドレス"

#: ../../chapter5.rst:1074
msgid "apf"
msgstr "apf"

#: ../../chapter5.rst:1075
msgid "address of parameter field"
msgstr "パラメータフィールドのアドレス"

#: ../../chapter5.rst:1076
msgid "\\'"
msgstr "\\'"

#: ../../chapter5.rst:1077
msgid "(as prefix) address of"
msgstr "((英語では)プレフィックスとして) …のアドレス"

#: ../../chapter5.rst:1078
msgid "s d"
msgstr "s d"

#: ../../chapter5.rst:1079
msgid "(as a pair) source destination"
msgstr "(ペアで使って）元(source)、先(destination)"

#: ../../chapter5.rst:1080
msgid "lo hi"
msgstr "lo hi"

#: ../../chapter5.rst:1081
msgid "lower-limit upper-limit (inclusive)"
msgstr "下限(lower-limit)、上限(upper-limit) (内包)"

#: ../../chapter5.rst:1082
msgid "#"
msgstr "#"

#: ../../chapter5.rst:1083
msgid "count"
msgstr "カウント。"

#: ../../chapter5.rst:1084
msgid "o"
msgstr "o"

#: ../../chapter5.rst:1085
msgid "offset"
msgstr "オフセット"

#: ../../chapter5.rst:1086
msgid "i"
msgstr "i"

#: ../../chapter5.rst:1087
msgid "index"
msgstr "インデックス"

#: ../../chapter5.rst:1088
msgid "m"
msgstr "m"

#: ../../chapter5.rst:1089
msgid "mask"
msgstr "mask"

#: ../../chapter5.rst:1090
msgid "x"
msgstr "x"

#: ../../chapter5.rst:1091
msgid "don\\'t care (data structure notation)"
msgstr "詳細を気にしない何か(データ構造記法)"

#: ../../chapter5.rst:1093
msgid "An “offset” is a difference expressed in absolute units, such as bytes."
msgstr "「オフセット」とは、バイトなどの絶対単位で表される差です。"

#: ../../chapter5.rst:1094
msgid ""
"An “index” is a difference expressed in logical units, such as elements "
"or records."
msgstr "「インデックス」とは、要素やレコードなどの論理単位で表される違いです。"

# The result-side of the second version would be read “true means no match".
# 意味よくわからんので省略。falseの意味が人口にかいしゃくされてない時代だったのかも。
#: ../../chapter5.rst:1096
msgid ""
"The equal sign after the symbols “t” and “f” equates the flag outcome "
"with its meaning. The result-side of the second version would be read "
"“true means no match.”"
msgstr "記号「t」と「f」の後の等号「=」は、フラグの結果とその意味を表します。"

#: ../../chapter5.rst:1101
msgid "Notation of Variable Possibilities"
msgstr "ありうる様々な結果の記法"

#: ../../chapter5.rst:1103
msgid ""
"Some definitions yield a different stack effect under different "
"circumstances."
msgstr "定義によっては、状態によってスタック効果が異なります。"

#: ../../chapter5.rst:1105
msgid ""
"If the number of items on the stack remains the same under all "
"conditions, but the items themselves change, you can use the vertical bar"
" ( ``|`` ) to mean “or.” The following stack-effect comment describes a "
"word that returns either the address of a file or, if the requested file "
"is not found, zero:"
msgstr ""
"スタック上の項目の数がすべての条件で同じままで、項目自体が変わる場合は、縦棒「|」を使って「または」を表すことができます。 "
"以下は、ファイルのアドレス、または要求されたファイルが見つからない場合はゼロを返します。"

#: ../../chapter5.rst:1114
msgid ""
"If the number of items in a stack picture can vary—in either the “before”"
" or “after” picture—you must write out both versions of the entire stack "
"picture, along with the double-hyphen, separated by the “or” symbol. For "
"instance:"
msgstr "「前」または「後」のでスタック状況の項目数が異なる場合は、スタック状況全体の両方のバージョンを二連ハイフン「--」とともに「または」の記号で区切って書き出す必要があります。"

#: ../../chapter5.rst:1123
msgid ""
"This comment indicates that if the word is found, three arguments are "
"returned (with the flag on top); otherwise only a false flag is returned."
msgstr ""
"このコメントは、ワードが見つかった場合、3つの引数が返されることを示します（trueフラグがスタック・トップにあります）。 "
"それ以外の場合はfalseフラグのみが返されます。"

#: ../../chapter5.rst:1127
msgid ""
"Note the importance of the second “--”. Its omission would indicate that "
"the definition always returned three arguments, the top one being a flag."
msgstr ""
"2番目の「--」の重要性に注意してください。 "
"その省略は、定義が常に3つの引数を返すことを示します。スタックトップはフラグです(訳注：2番めの「--」を省略すると「-- apf len "
"t=found | f=not-found」となり、これは「-- apf len t=found | -- apf len f=not-"
"found」 という意味になってしまう)。"

#: ../../chapter5.rst:1131
msgid ""
"If you prefer, you can write the entire stack effect twice, either on the"
" same line, separated by three spaces:"
msgstr "必要に応じて、スタック効果全体を3行のスペースで区切って同じ行に2回書き込むことができます。"

#: ../../chapter5.rst:1139
msgid "or listed vertically:"
msgstr "または垂直書式だと、"

#: ../../chapter5.rst:1147
msgid "Data-Structure Comments"
msgstr "データ構造コメント"

#: ../../chapter5.rst:1149
msgid ""
"A “data-structure comment” depicts the elements in a data structure. For "
"example, here’s the definition of an insert buffer called ``|INSERT`` :"
msgstr "「データ構造コメント」は、データ構造の要素を表します。 たとえば、 ``|INSERT`` という挿入バッファの定義は次のようになります。"

#: ../../chapter5.rst:1156
msgid ""
"The “faces” (curly-brackets) begin and end the structure comment; the "
"bars separate the various elements in the structure; the numbers "
"represent bytes per element. In the comment above, the first byte "
"contains the count, and the remaining 63 bytes contain the text."
msgstr ""
"波括弧「{…}」(faces)は、構造コメントの開始と終了を表します。 縦棒は構造内のさまざまな要素を区切ります。 "
"数字は要素ごとのバイト数を表します。 上記のコメントでは、最初のバイトにカウントが含まれ、残りの63バイトにテキストが含まれています。"

#: ../../chapter5.rst:1161
msgid ""
"A “bit comment” uses the same format as a data-structure comment to "
"depict the meaning of bits in a byte or cell. For instance, the bit "
"comment"
msgstr "「ビットコメント」は、データ構造のコメントと同じフォーマットを使用して、バイトまたはセル内のビットの意味を表します。 例えば、以下のビットコメント、"

#: ../../chapter5.rst:1170
msgid ""
"describes the format of a 16-bit status register of a communications "
"channel. The first two bits are flags, the second two bits are unused, "
"and the final pair of six-bit fields indicate the input and output "
"devices which this channel is connected to."
msgstr ""
"通信チャネルの16ビットステータスレジスタのフォーマットを記述します。 "
"最初の2ビットはフラグ、2番目の2ビットは未使用、最後の6ビットフィールドのペアは、このチャネルが接続されている入力デバイスと出力デバイスを示します。"

#: ../../chapter5.rst:1176
msgid ""
"If more than one data structure employs the same pattern of elements, "
"write out the comment only once (possibly in the preamble), and give a "
"name to the pattern for reference in subsequent screens. For instance, if"
" the preamble gives the above bit-pattern the name “status,” then "
"“status” can be used in stack comments to indicate values with that "
"pattern:"
msgstr ""
"複数のデータ構造が同じパターンの要素を使用している場合は、コメントを1回だけ（おそらく前書きに）書き出し、後続のスクリーン参照するためにパターンに名前を付けます。"
" "
"たとえば、前書き上記のビットパターンに「status」という名前を付ける場合は、スタックコメントで「status」を使用してそのパターンの値を示すことができます。"

#: ../../chapter5.rst:1187
msgid ""
"If a ``2VARIABLE`` contains one double-length value, the comment should "
"be a stack picture that indicates the contents:"
msgstr "``2VARIABLE`` が1つの2倍長値を含む場合、コメントは内容を示すスタック状況になります。"

#: ../../chapter5.rst:1194
msgid ""
"If a ``2VARIABLE`` contains two single-length data elements, it’s given a"
" stack picture showing what would be on the stack after a ``2@``. Thus:"
msgstr ""
"``2VARIABLE`` に2つの1倍長データ要素が含まれる場合、 ``2@`` の後に何がスタックにあるのかを示すスタック状況を与えます。 "
"したがって下記のようになります。"

#: ../../chapter5.rst:1202
msgid ""
"This is different from the comment that would be used if ``MEASUREMENTS``"
" were defined by ``CREATE``."
msgstr "これは `` MEASUREMENTS`` が ``CREATE`` によって定義されている場合に使われるであろうコメントとは異なります。"

#: ../../chapter5.rst:1209
msgid ""
"(While both statements produce the same result in the dictionary, the use"
" of ``2VARIABLE`` implies that the values will normally be “2-fetched” "
"and “2-stored” together-thus we use a *stack* comment. The high-order "
"part, appearing on top of the stack, is listed to the right. The use of "
"``CREATE`` implies that the values will normally be fetched and stored "
"separately–thus we use a data structure comment. The item in the 0th "
"position is listed to the left.)"
msgstr ""
"(どちらの文も辞書に同じ結果を生成しますが、 ``2VARIABLE`` "
"の使用は値を通常「2-fetched」や「2-stored」する事になることを意味しますので、「スタックコメント」コメントを使います。 "
"``CREATE`` を使うことは通常値が別々にフェッチされ格納されることを意味します。したがってデータ構造のコメントを使います。 "
"左に0番目の位置が表示されます。"

#: ../../chapter5.rst:1219
msgid "Input-stream Comments"
msgstr "入力ストリームコメント"

#: ../../chapter5.rst:1221
msgid ""
"The input-stream comment indicates what words and/or strings are presumed"
" to be in the input stream. Table :numref:`tab-5-3` lists the "
"designations used for input stream arguments."
msgstr ""
"入力ストリームコメントは、どのワードや文字列が入力ストリームにあると推定されるかを示します。表 :numref:`tab-5-3` "
"は入力ストリーム引数に使われる指定をリストしています。"

#: ../../chapter5.rst:1225
msgid "Input-stream comment designations."
msgstr "入力ストリームのコメント凡例"

#: ../../chapter5.rst:1230
msgid "single character, blank-delimited"
msgstr "空白で区切られた単一文字"

#: ../../chapter5.rst:1231
msgid "name"
msgstr "name"

#: ../../chapter5.rst:1231
msgid "sequence of characters, blank delimited"
msgstr "空白で区切られた文字の連なり"

#: ../../chapter5.rst:1232
msgid "text"
msgstr "text"

#: ../../chapter5.rst:1232
msgid "sequence of characters, delimited by non-blank"
msgstr "空白以外で区切られた文字の連なり"

#: ../../chapter5.rst:1235
#, fuzzy
msgid ""
"Follow \"text\" with the actual delimiter required; e.g.: text\\\" or "
"text\\)"
msgstr "実際の区切り文字をtextの後に続けます。 例: text\\\" または text\\)"

#: ../../chapter5.rst:1237
msgid ""
"The input-stream comment appears *before* the stack comment, and is *not*"
" encapsulated between its own pair of parentheses, but simply surrounded "
"by three spaces on each side. For instance, here’s one way to comment the"
" definition of ``’`` (tick) showing first the input-stream comment, then "
"the stack comment:"
msgstr ""
"入力ストリームコメントはスタックコメントの「前」に現れ、括弧で囲まれることなく、両側に3つのスペースで囲まれるだけです。以下に ``’`` "
"(tick)の定義のコメントのやり方があります。それは最初に入力ストリームのコメントを表示し、それからスタックのコメントを表示します。"

#: ../../chapter5.rst:1247
msgid "If you prefer to use ``(`` , the comment would look like this:"
msgstr "``(`` を使いたければ、コメントは次のようになります。"

#: ../../chapter5.rst:1253
msgid ""
"Incidentally, there are three distinct ways to receive string input. To "
"avoid confusion, here are the terms:"
msgstr "ちなみに、文字列入力を受け取るには3種類の方法があります。 混乱を避けるために、以下に用語を示します。"

#: ../../chapter5.rst:1260
msgid "Scanning-for"
msgstr "何それをスキャン(Scanning-for)"

#: ../../chapter5.rst:1258
msgid ""
"means looking ahead in the input stream, either for a word or number as "
"in the case of tick, or for a delimiter as in the case of ``.\"`` and "
"``(`` ."
msgstr ""
"``’`` (tick)の場合に単語のためか数字のためかのいずれか、または ``.\"`` や ``(`` "
"の場合の区切り文字の為に、入力ストリームを先読みする事を意味します。"

#: ../../chapter5.rst:1264
msgid "Expecting"
msgstr "期待して待つ(Expecting)"

#: ../../chapter5.rst:1263
msgid ""
"means waiting for. ``EXPECT`` and ``KEY``, and definitions that invoke "
"them, are ones that “expect” input."
msgstr "待つことを意味します。``EXPECT`` や ``KEY`` およびそれらを呼び出す定義は、入力を「予期する」ものです。"

#: ../../chapter5.rst:1269
msgid "Presuming"
msgstr "推定する(Presuming)"

#: ../../chapter5.rst:1267
msgid ""
"indicates that in normal usage something will follow. The word: “scans-"
"for” the name to be defined, and “presumes” that a definition will "
"follow."
msgstr ""
"通常の使用では何かが続くことを示します。 ワード：定義される名前を「スキャンする(scans-"
"for)」、そして定義が続くことを「想定する(presumes)」。"

#: ../../chapter5.rst:1271
msgid "The input-stream comment is only appropriate for input being scanned-for."
msgstr "入力ストリームのコメントは、スキャン対象(scanned-for)の入力にのみ適しています。"

#: ../../chapter5.rst:1275
msgid "Purpose Comments"
msgstr "目的コメント"

#: ../../chapter5.rst:1279
msgid "Every definition should bear a purpose comment unless:"
msgstr "以下の場合を除き、すべての定義に目的コメントを付ける必要があります。"

#: ../../chapter5.rst:1281
msgid "its purpose is clear from its name or its stack-effect comment, or"
msgstr "その目的は、名前またはスタック効果コメントから明らか。または、"

#: ../../chapter5.rst:1282
msgid "if it consists of three or fewer words."
msgstr "それが3つ以下のワードで構成されている場合。"

#: ../../chapter5.rst:1284
msgid ""
"The purpose comment should be kept to a minimum-never more than a full "
"line. For example:"
msgstr "目的コメントは、最小限にとどめ、1行を超えないようにする必要があります。 たとえば以下のように。"

#: ../../chapter5.rst:1292
msgid ""
"Use the imperative mood: “set Foreground color,” not “sets Foreground "
"color.”"
msgstr "命令文を使用してください。「前景色設定」ではなく「前景色を設定しろ」。"

#: ../../chapter5.rst:1295
msgid ""
"On the other hand, a word’s purpose can often be described in terms of "
"its stack-effect comment. You rarely need both a stack comment and a "
"purpose comment. For instance:"
msgstr ""
"反面、ワードの目的は、そのスタック効果コメントで説明することができます。 "
"スタックコメントと目的コメントの両方が必要になることはめったにありません。 たとえば以下のように。"

#: ../../chapter5.rst:1309
msgid ""
"This definition takes as its incoming argument a number that represents "
"the number of spaces to type."
msgstr "この定義は、入力引数として、入力するスペースの数を表す数値を取ります。"

#: ../../chapter5.rst:1318
msgid ""
"This definition converts an index, which it consumes, into an address "
"within a table of 2-byte elements corresponding to the indexed element."
msgstr "この定義は、それが消費するインデックスを、インデックス付けされた要素に対応する2バイト要素のテーブル内のアドレスに変換します。"

#: ../../chapter5.rst:1325
msgid "This definition returns an address of a scratch region of memory."
msgstr "この定義はメモリのスクラッチ領域のアドレスを返します。"

#: ../../chapter5.rst:1327
msgid ""
"Occasionally, readability is best served by including both types of "
"comment. In this case, the purpose comment should appear last. For "
"instance:"
msgstr "時々は、両方のタイプのコメントを含めることによってとても読みやすくなります。この場合、目的コメントは最後に現れます。 たとえば以下です。"

#: ../../chapter5.rst:1337
msgid ""
"Indicate the type of comment by ordering: input-stream comments first, "
"stack-effect comments second, purpose comments last."
msgstr "コメントの種類を次の順序で示します。最初は入力ストリームのコメント、次はスタック効果のコメント、３番めは目的コメントです。"

#: ../../chapter5.rst:1340
msgid "For example:"
msgstr "例えば"

#: ../../chapter5.rst:1346
msgid "If you prefer to use ``(``, then write:"
msgstr "もし ``(`` を使いたければ、次のように書いてください。"

#: ../../chapter5.rst:1352
msgid "If necessary, you can put the purpose comment on a second line:"
msgstr "必要に応じて、目的コメントを2行目に置く事ができます。"

#: ../../chapter5.rst:1361
msgid "Comments for Defining Words"
msgstr "定義用のワードのコメント"

#: ../../chapter5.rst:1363
msgid "The definition of a defining word involves two behaviors:"
msgstr "定義用のワードの定義は、2つの振る舞いを含んでいます。"

#: ../../chapter5.rst:1366
msgid ""
"that of the defining word as it defines its “child” (compile-time "
"behavior), and"
msgstr "「定義用のワードの子供」を定義するときの定義用のワード（コンパイル時(compile-time)の振る舞い）、そして、"

#: ../../chapter5.rst:1369
msgid "that of the child itself (run-time behavior)."
msgstr "子供それ自身のもの(実行時(run-time)の振る舞い)です。"

#: ../../chapter5.rst:1371
msgid "These two behaviors must be commented separately."
msgstr "これら２つの振る舞いは別々にコメントしなければなりません。"

#: ../../chapter5.rst:1375
msgid ""
"Comment a defining word's compile-time behavior in the usual way; comment"
" its run-time behavior separately, following the word ``DOES>`` (or "
"``;CODE``)."
msgstr ""
"定義語のコンパイル時の動作を通常の方法でコメントします。 その実行時の振る舞いを ``DOES>`` (または ``;CODE`` "
")の後にコメントします。"

#: ../../chapter5.rst:1379
msgid "For instance,"
msgstr "例えば"

#: ../../chapter5.rst:1386
msgid ""
"The stack-effect comment for the run-time (child’s) behavior represents "
"the net stack effect for the child word. Therefore it does not include "
"the address returned by ``DOES>,`` even though this address is on the "
"stack when the run-time code begins."
msgstr ""
"(子供の)実行時の動作に対するスタック効果のコメントは、子供のワード実行時の正味のスタック効果を表します。 したがって、( ``DOES>`` "
"のあとの)実行時コード開始時には ``DOES>`` によって返されるアドレスがスタック上にありますが、それは含めません。"

#: ../../chapter5.rst:1391
msgid "*Bad* (run-time comment includes apf):"
msgstr "悪い例(実行時コメントがapf(パラメータフィールドアドレス)を含んでいる)"

#: ../../chapter5.rst:1407
msgid "Words defined by this word ``ARRAY`` will exhibit the stack effect:"
msgstr "このワード ``ARRAY`` によって定義されたワードはスタック効果があります。"

#: ../../chapter5.rst:1413
msgid ""
"If the defining word does not specify the run-time behavior, there still "
"exists a run-time behavior, and it may be commented:"
msgstr "定義語が実行時の振る舞いを指定していない場合でも、実行時の振る舞いが存在し、コメント化される可能性があります。"

#: ../../chapter5.rst:1422
msgid "Comments for Compiling Words"
msgstr "コンパイル用のワードのコメント"

#: ../../chapter5.rst:1424
msgid "As with defining words, most compiling words involve two behaviors:"
msgstr "定義用のワードと同様に、ほとんどのコンパイル用のワードには2つの振る舞いがあります。"

#: ../../chapter5.rst:1426
msgid ""
"That of the compiling word as the definition in which it appears is "
"compiled"
msgstr "定義に現れるコンパイル用のワードはコンパイルされます。"

#: ../../chapter5.rst:1429
msgid ""
"That of the run-time routine which will execute when we invoke the word "
"being defined. Again we must comment each behavior separately."
msgstr "それは、定義済のワードを呼び出す時に実行される実行時ルーチンです。繰り返しになりますが、それぞれの振る舞いは個別にコメントしなければなりません。"

#: ../../chapter5.rst:1434
msgid ""
"Comment a compiling word's run-time behavior in the usual way; comment "
"its compile-time behavior separately, beginning with the label "
"\"Compile:\"."
msgstr "コンパイル用のワードの実行時の振る舞いを通常の方法でコメントします。 コンパイル時のコメントは、ラベル「Compile:」に続いて書きます。"

#: ../../chapter5.rst:1438
msgid "For instance:"
msgstr "例えば"

#: ../../chapter5.rst:1446
msgid ""
"In the case of compiling words, the first comment describes the run-time "
"behavior, which is usually the *syntax for using* the word. The second "
"comment describes what the word *actually does* in compiling (which is of"
" less importance to the user)."
msgstr ""
"コンパイル用ワードの場合、最初のコメントは実行時の動作を記述します。これは通常、ワードを使用するための構文です。 "
"2番目のコメントは、コンパイル時にワードが実際にどのように機能するのかを説明しています(これはユーザにとっては重要性は低いです）。"

#: ../../chapter5.rst:1451
msgid "Other examples:"
msgstr "他の例"

#: ../../chapter5.rst:1458
msgid ""
"Occasionally a compiling word may exhibit a different behavior when it is"
" invoked *outside* a colon definition. Such words (to be fastidious about"
" it) require three comments. For instance:"
msgstr ""
"時折、コンパイル用のワードがコロン定義の外で呼び出されると、異なる動作を示すことがあります。 "
"そのようなワードは（それについて忠実になるために）3つのコメントを必要とします。 たとえば以下です。"

#: ../../chapter5.rst:1469
msgid ""
":doc:`Appendix E<appendixe>` includes two screens showing good commenting"
" style."
msgstr ":doc:`付録E<appendixe>` には、良いコメントスタイルを示す2つのスクリーンがあります。"

#: ../../chapter5.rst:1472
msgid "Vertical Format vs. Horizontal Format"
msgstr "垂直書式 対 水平書式"

#: ../../chapter5.rst:1474
msgid ""
"The purpose of commenting is to allow a reader of your code to easily "
"determine what’s going on. But how much commenting is necessary? To "
"determine the level of commenting appropriate for your circumstances, you"
" must ask yourself two questions:"
msgstr ""
"コメントする目的は、コードの読者が何が起こっているのかを簡単に判断できるようにすることです。 しかし、どれだけのコメントが必要ですか？ "
"あなたの状況にふさわしいコメントのレベルを決定するために、あなたは自身に2つの問い掛けをしなければなりません。"

#: ../../chapter5.rst:1479
msgid "Who will be reading my code?"
msgstr "私のコードを読むのは誰ですか？"

#: ../../chapter5.rst:1481
msgid "How readable are my definitions?"
msgstr "私の定義はどのぐらい読みやすいですか？"

#: ../../chapter5.rst:1483
msgid ""
"There are two basic styles of commenting to choose from. The first style,"
" often called the “vertical format,” includes a step-by-step description "
"of the process, in the manner of a well-commented assembly language "
"listing. These line-by-line comments are called “narrative comments.”"
msgstr ""
"2つの基本的なスタイルのコメントを選択できます。しばしば「垂直書式」と呼ばれる最初のスタイルは、よくコメントされたアセンブリ言語のリストのように、プロセスのステップバイステップの説明を含みます。"
" これらの行ごとのコメントは「物語コメント」と呼ばれます。"

#: ../../chapter5.rst:1506
msgid ""
"The other approach does not intersperse narrative comments between code "
"phrases. This is called the “horizontal format.”"
msgstr "もう1つの方法では、コード句間に物語のコメントが散在しません。 これは「水平書式」と呼ばれます。"

#: ../../chapter5.rst:1515
msgid ""
"The vertical format is preferred when a large team of programmers are "
"coding and maintaining the application. Typically, such a team will "
"include several junior-level programmers responsible for minor "
"corrections. In such an environment, diligent commenting can save a lot "
"of time and upset. As Johnson of Moore Products Co. says: “When "
"maintaining code you are usually interested in just one small section, "
"and the more information written there the better your chances for a "
"speedy fix.”"
msgstr ""
"大規模なプログラマチームがアプリケーションをコーディングおよび保守している場合は、垂直フォーマットが推奨されます。 "
"通常、このようなチームには、小さな修正を担当する駆け出しレベルのプログラマが何人か含まれます。 "
"そのような環境では、勤勉なコメントは多くの時間と動揺を節約することができます。ムーアプロダクツ社のジョンソン氏が言うように、「コードを保守するときには、たった1つの小さなセクションに関心があり、そこに書かれている情報が多ければ多いほど、迅速な修正が可能になります。」"

#: ../../chapter5.rst:1524
msgid ""
"Here are several pertinent rules required of the Forth programmers at "
"Moore Products Co. (I’m paraphrasing):"
msgstr "以下がムーアプロダクツ社のForthプログラマに要求される、いくつかの適切とされる規則です（句と句の間隔取り）。"

#: ../../chapter5.rst:1527
msgid ""
"A vertical format will be used. Comments will appear to the right of the "
"source code, but may continue to engulf the next line totally if needed."
msgstr "垂直書式を使用します。コメントはソースコードの右側に表示されますが、必要に応じて次行も使います。"

#: ../../chapter5.rst:1531
msgid ""
"There should be more comment characters than source characters. (The "
"company encourages long descriptive names, greater than ten characters, "
"and allows the names to be counted as comment characters.)"
msgstr "ソース文字よりも多くのコメント文字があるはずです(この会社は、10文字を超える長い説明的な名前を推奨し、名前をコメント文字として数えることを許可しています)。"

#: ../../chapter5.rst:1536
msgid ""
"Any conditional structure or application word should appear on a separate"
" line. “Noise words” can be grouped together. Indentation is used to show"
" nested conditionals."
msgstr ""
"条件付き構造またはアプリケーション・ワードは、別の行に表示する必要があります。 「ノイズワード」はまとめてグループ化できます。 "
"字下げは入れ子になった条件を示すために使用されます。"

#: ../../chapter5.rst:1540
msgid ""
"There are some difficulties with this format, however. For one thing, "
"line-by-line commenting is time-consuming, even with a good screen "
"editor. Productivity can be stifled, especially when stopping to write "
"the comments breaks your chain of thought."
msgstr ""
"ただし、この形式にはいくつかの問題があります。 1つには、優れたスクリーンエディタを使用したとしても、行ごとのコメントは時間がかかります。 "
"特にコメントを書くのを中断すると思考の連鎖が崩れ、生産性が低下する可能性があります。"

#: ../../chapter5.rst:1546
msgid ""
"Also, you must also carefully ensure that the comments are up-to-date. "
"Very often code is corrected, the revision is tested, the change "
"works—and the programmer forgets to change the comments. The more "
"comments there are, the more likely they are to be wrong. If they’re "
"wrong, they’re worse than useless."
msgstr ""
"また、コメントが最新のものであることも慎重に確認する必要があります。 "
"多くの場合、コードが修正され、改訂版がテストされ、変更が行われ、プログラマがコメントを変更するのを忘れます。 "
"コメントが多いほど、それらは間違っている可能性が高くなります。 コメントが間違っているならば、それは役に立たないより悪いです。"

#: ../../chapter5.rst:1552
msgid ""
"This problem can be alleviated if the project supervisor carefully "
"reviews code and ensures the accuracy of comments."
msgstr "プロジェクトの監督者がコードを慎重に確認し、コメントの正確さを保証すれば、この問題を軽減することができます。"

#: ../../chapter5.rst:1555
msgid ""
"Finally, line-by-line commenting can allow a false sense of security. "
"Don’t assume that because each *line* has a comment, the *application* is"
" well-com-men-ted. Line-by-line commenting doesn’t address the "
"significant aspects of a definition’s operation. What, for instance, is "
"the thinking behind the checksum algorithm used? Who knows, from the "
"narrative comments?"
msgstr ""
"最後に、行ごとのコメントは誤った安心感を与える可能性があります。 "
"「各行にコメントがあるので、アプリケーションはうまく機能している」とは思わないでください。 "
"行ごとのコメントでは、定義の操作における重要な側面については説明されていません。 "
"たとえば、使用されているチェックサムアルゴリズムの背後にある考え方は何ですか？ 物語のコメントから誰が知っているのですか？"

#: ../../chapter5.rst:1563
msgid ""
"To properly describe, in prose, the implications of a given procedure "
"usually requires many paragraphs, not a single phrase. Such descriptions "
"properly belong in auxiliary documentation or in the chapter preamble."
msgstr ""
"正確に説明するために、概説では、与えられた手続きの意味は通常、単一の句ではなく多くの段落を必要とします。 "
"そのような説明は、補助的な文書または章の前文に含めるのが適切です。"

#: ../../chapter5.rst:1567
msgid ""
"Despite these cautions, many companies find the vertical format "
"necessary. Certainly a team that is newly exposed to Forth should adopt "
"it, as should any very large team."
msgstr ""
"これらの注意にもかかわらず、多くの企業は垂直書式を必要としています。 "
"確かに、Forthに初めて触れるチームは、他の大規模チームと同様にそれを採用する必要があります。"

#: ../../chapter5.rst:1571
msgid ""
"What about the horizontal format? Perhaps it’s an issue of art vs. "
"practicality, but I feel compelled to defend the horizontal format as "
"equally valid and in some ways superior."
msgstr ""
"水平書式はどうですか？ "
"おそらくそれは芸術性と実用性の問題ですが、私は水平書式を同じように有効で、ある意味では優れていると擁護しなければならないと感じています。"

#: ../../chapter5.rst:1575
msgid ""
"If Forth code is really well-written, there should be nothing ambiguous "
"about it. This means that:"
msgstr "Forthのコードが本当によく書かれていれば、それについてあいまいなものは何もないはずです。 つまり、以下の事が言えます。"

#: ../../chapter5.rst:1578
msgid "supporting lexicons have a well-designed syntax"
msgstr "サポートしている用語集は、よく練られた構文を持ちます。"

#: ../../chapter5.rst:1580
msgid "stack inputs and outputs are commented"
msgstr "スタックの入出力はコメント化されています。"

#: ../../chapter5.rst:1582
msgid ""
"the purpose is commented (if it’s not clear from the name or stack "
"comment)"
msgstr "(名前やスタックコメントから明らかで無い場合)目的コメントがある。"

#: ../../chapter5.rst:1585
msgid "definitions are not too long"
msgstr "定義は長すぎない"

#: ../../chapter5.rst:1587
msgid ""
"not too many arguments are passed to a single definition via the stack "
"(see “The Stylish Stack” in :doc:`Chapter Seven<chapter7>`)."
msgstr "スタックを介して単一の定義に渡される引数が多すぎない( :doc:`第7章<chapter7>` の「スタイリッシュなスタック」参照)。"

#: ../../chapter5.rst:1590
msgid ""
"Forth is simply not like other languages, in which line-by-line "
"commenting is one of the few things you can do to make programs more "
"readable."
msgstr "Forthは、他の言語とは異なり、行ごとのコメント付けは、プログラムを読みやすくするためにできるいくつかのことの1つです。"

#: ../../chapter5.rst:1594
msgid ""
"Skillfully written Forth code is like poetry, containing precise meaning "
"that both programmer and machine can easily read. Your *goal* should be "
"to write code that does not need commenting, even if you choose to "
"comment it. Design your application so that the code, not the comments, "
"conveys the meaning."
msgstr ""
"巧みに書かれたForthコードは詩のように、プログラマと機械の両方が容易に読むことができる正確な意味を含んでいます。 "
"あなたの目標は、あなたがコメントすることを選んだとしても、コメントを必要としないコードを書くことです。 "
"コメントではなくコードが意味を伝えるようにアプリケーションを設計してください。"

#: ../../chapter5.rst:1600
msgid ""
"If you succeed, then you can eliminate the clutter of excessive "
"commenting, achieving a purity of expression without redundant "
"explanations."
msgstr "あなたが成功すれば、過度のコメントをする必要がなくなり、余分な説明をせずに純粋な表現を実現できます。"

#: ../../chapter5.rst:1609
msgid "Wiggins, proud of his commenting technique."
msgstr "ウィギンス、彼のコメント・テクニックを誇りに思う。"

#: ../../chapter5.rst:1613
msgid "The most-accurate, least-expensive documentation is self-documenting code."
msgstr "最も正確で安価な文書は、自己文書化コードです。"

#: ../../chapter5.rst:1616
msgid ""
"Unfortunately, even the best programmers, given the pressure of a "
"deadline, may write working code that is not easily readable without "
"comments. If you are writing for yourself, or for a small group with whom"
" you can verbally communicate, the horizontal format is ideal. Otherwise,"
" consider the vertical format."
msgstr ""
"残念ながら、最高のプログラマでさえ、締め切りのプレッシャーを与えられて、コメントなしでは容易に読めない実用的なコードを書くかもしれません。 "
"あなた自身のために、またはあなたが口頭でコミュニケーションをとることができる人と小さなグループのために書いているならば、水平書式は理想的です。 "
"それ以外の場合は、垂直書式を検討してください。"

#: ../../chapter5.rst:1624
msgid "Choosing Names: The Art"
msgstr "名前の選択、それは芸術"

#: ../../chapter5.rst:1626
msgid ""
"Besides a mathematical inclination, an exceptionally good mastery of "
"one\\'s native tongue is the most vital asset of a competent programmer "
"(**Prof.  Edsger W. Dijkstra** [dijkstra82]_ )."
msgstr ""
"数学的な下地に加えて、母国語への非常に優れた習熟は、有能なプログラマにとって最も重要な財産です( ** エドガー・ダイクストラ教授 ** "
"[dijkstra82]_ )。"

#: ../../chapter5.rst:1630
msgid ""
"We’ve talked about the significance of using names to symbolize ideas and"
" objects in the application. The choosing of names turns out to be an "
"important part of the design process."
msgstr ""
"私たちはアプリケーション内のアイデアやオブジェクトを象徴するために名前を使用することの意味について説明しました。 "
"名前の選択は設計プロセスの重要な部分であることがわかりました。"

#: ../../chapter5.rst:1635
msgid ""
"Newcomers tend to overlook the important of names. “After all,” they "
"think, “the computer doesn’t care what names I choose.”"
msgstr "新人は名前の重要性を見逃しがちです。 新人は「結局のところ、コンピュータは私が選んだ名前を気にしない」と考えます。"

#: ../../chapter5.rst:1638
msgid ""
"But good names are essential for readability. Moreover, the mental "
"exercise of summoning a one-word description bears a synergistic effect "
"on your perceptions of what the entity should or should not do."
msgstr ""
"しかし、良い名前は読みやすさのために不可欠です。 "
"さらに、一つの単語の説明を召喚するという精神的な運動は、実体が何を為すべきか何を為さないべきかというあなたの認識に相乗効果をもたらします。"

#: ../../chapter5.rst:1642
msgid "Here are some rules for choosing good names:"
msgstr "良い名前を選択するためのいくつかの規則は次のとおりです。"

#: ../../chapter5.rst:1646
msgid "Choose names according to \"what,\" not \"how.\""
msgstr "「どのように(how)」ではなく、「何をするのか(what)」に従って名前を選んで下さい。"

#: ../../chapter5.rst:1648
msgid ""
"A definition should hide the complexities of implementation from other "
"definitions which invoke it. The name, too, should hide the details of "
"the procedure, and instead should describe the outward appearance or net "
"effect."
msgstr "定義はそれを呼び出す他の定義から実装の複雑さを隠すべきです。 名前も手順の詳細を隠し、代わりに外観または正味効果を説明する必要があります。"

#: ../../chapter5.rst:1653
msgid ""
"For instance, the Forth word ``ALLOT`` simply increments the dictionary "
"pointer (called ``DP`` or ``H`` in most systems). But the name ``ALLOT`` "
"is better than ``DP+!`` because the user is thinking of reserving space, "
"not incrementing a pointer."
msgstr ""
"たとえば、Forthのワード ``ALLOT`` (訳注:割り当てる の意)は辞書ポインタ(ほとんどのシステムでは ``DP`` または "
"``H`` と呼ばれる)をインクリメントだけです。しかし、ユーザはポインタをインクリメントするのではなく、スペースを確保することを考えているので、"
" ``ALLOT`` という名前は ``DP+!`` よりも優れています。"

#: ../../chapter5.rst:1659
msgid ""
"The ’83 Standard adopted the name ``CMOVE>`` instead of the previous name"
" for the same function, ``<CMOVE``. The operation makes it possible to "
"copy a region of memory *forward* into overlapping memory. It "
"accomplishes this by starting with the last byte and working *backward*. "
"In the new name, the forwardness of the “what” supersedes the "
"backwardness of the “how.”"
msgstr ""
"FORTH-83規格では、同じ機能に対して、以前の名前 ``<CMOVE`` の代わりに ``CMOVE>`` という名前を採用しました。 "
"この操作により、メモリの前方領域を重複メモリにコピーすることができます。 最後のバイトから始めて後ろ向きに実行することでこれを実現します。 "
"新しい名前では、「何をするのか(what)」の前向きさが「どうするのか(how)」の後向き性に優先します。"

#: ../../chapter5.rst:1668
msgid "Find the most expressive word."
msgstr "最も表現力豊かな単語を見つけてください。"

#: ../../chapter5.rst:1672
msgid ""
"A powerful agent is the right word.  Whenever we come upon one of those "
"intensely right words in a book or a newspaper the resulting effect is "
"physical as well as spiritual, and electrically prompt **(Mark Twain)** ."
msgstr ""
"正しい単語は強力なエージェントです。 "
"私たちが本や新聞の中でそれらの非常に正しい単語のうちの1つに遭遇するときはいつでも、結果として生じる効果は肉体的であると同時に霊的でもあり、そして稲妻に打たれたような啓示です。"
" **マーク・トウェイン**"

#: ../../chapter5.rst:1677
msgid ""
"The difference between the right word and the almost-right word is like "
"the difference between lightning and the lightning bug **(Mark Twain)** ."
msgstr ""
"正しい単語とほぼ正しい単語の違いは、lightning(稲妻)とlightning bug(ほたる)の違いに似ています。  "
"**マーク・トウェイン**"

#: ../../chapter5.rst:1681
msgid ""
"Suit the action to the word, the word to the action **(Shakespeare, "
"Hamlet, Act~III)** ."
msgstr "しぐさは言葉に合わせ、言葉はしぐさに合わせるように(シェイクスピア ハムレット 第3幕)"

#: ../../chapter5.rst:1684
msgid ""
"Henry Laxen, a Forth consultant and author, suggests that the most "
"important Forth development tool is a good thesaurus [laxen]_ ."
msgstr ""
"Forthのコンサルタント兼作家であるHenry "
"Laxenは、最も重要なForth開発ツールは優れたシソーラス(類語辞典)であることを示唆しています。 [laxen]_"

#: ../../chapter5.rst:1688
msgid ""
"Sometimes you’ll think of an adequate word for a definition, but it "
"doesn’t feel quite right. It may be months later before you realize that "
"you fell short of the mark. In the Roman numeral example in :doc:`Chapter"
" Four<chapter4>` one-less-than the next symbol’s value. My first choice "
"was ``4-0R-9``. That’s awkward, but it was much later that I thought of "
"``ALMOST``."
msgstr ""
"定義にふさわしい言葉を考えることがあるかもしれませんが、それはまったく正しいとは言えません。 "
"数カ月後になって、あなたが目標を達成できなかったことに気付くでしょう。 :doc:`第4章<chapter4>` "
"のローマ数字の例では、次のシンボルのの値よりも1小さい値を表す言葉が必要でした。私の最初の選択は ``4-0R-9`` でした。厄介なことに、私が"
" ``ALMOST`` を思いついたのはずっと後になってからでした。"

#: ../../chapter5.rst:1694
msgid ""
"Most fig-Forth systems include the word ``VLIST``, which lists the names "
"of all the words in the current vocabulary. After many years someone "
"realized that a nicer name is ``WORDS``. Not only does ``WORDS`` sound "
"more pleasant by itself, it also works nicely with vocabulary names. For "
"instance:"
msgstr ""
"ほとんどのfig-Forthシステムは、現在の語彙のすべての単語の名前をリストするワード ``VLIST`` を含みます。 "
"何年もの後、誰かがより良い名前が ``WORDS`` であることに気づきました。 ``WORDS`` "
"はそれ自体がより快適に聞こえるだけでなく、ボキャブラリ名に対してもうまく機能します。 たとえば以下のように。"

#: ../../chapter5.rst:1710
msgid ""
"On the other hand, Moore points out that inappropriate names can become a"
" simple technique for encryption. If you need to provide security when "
"you’re forced to distribute source, you can make your code very "
"unreadable by deliberately choosing misleading names. Of course, "
"maintenance becomes impossible."
msgstr ""
"反面、ムーアは、不適切な名前は暗号化のための単純な手法になる可能性があると指摘しています。 "
"ソースの配布を強いられたときにセキュリティを確保する必要がある場合は、誤解を招くような名前を慎重に選択することで、コードを非常に読みにくくすることができます。"
" もちろん、メンテナンスは不可能になります。"

#: ../../chapter5.rst:1719
msgid "Choose names that work in phrases."
msgstr "その句の中で活きる名前を選択してください。"

#: ../../chapter5.rst:1721
msgid ""
"Faced with a definition you don’t know what to call, think about how the "
"word will be used in context. For instance:"
msgstr "あなたが何を呼ぶべきかわからない定義に直面したら、文脈の中でその言葉がどのように使われるかについて考えて下さい。例えば以下のように。"

#: ../../chapter5.rst:1726
msgid "``SHUTTER OPEN``"
msgstr "``SHUTTER OPEN``"

#: ../../chapter5.rst:1725
msgid ""
"``OPEN`` is the appropriate name for a word that sets a bit in an I/O "
"address identified with the name ``SHUTTER``."
msgstr "``OPEN`` は、 ``SHUTTER`` という名前で識別されるI/Oアドレスにビットをセットするワードに適切な名前です。"

#: ../../chapter5.rst:1732
msgid "``3 BUTTON DOES IGNITION``"
msgstr "``3 BUTTON DOES IGNITION``"

#: ../../chapter5.rst:1729
msgid ""
"``DOES`` is a good choice for a word that vectors the address of the "
"function ``IGNITION`` into a table of functions, so that ``IGNITION`` "
"will be executed when Button 3 is pushed."
msgstr ""
"``DOES`` は、 ``IGNITION`` 機能のアドレスを機能の表にベクトル化するワードに適しています。そのため、ボタン3が押されると "
"``IGNITION`` が実行されます。"

#: ../../chapter5.rst:1739
msgid "``SAY HELLO``"
msgstr "``SAY HELLO``"

#: ../../chapter5.rst:1735
msgid ""
"``SAY`` is the perfect choice for vectoring ``HELLO`` into an execution "
"variable.  (When I first wrote this example for Starting Forth, I called "
"it ``VERSION``. Moore reviewed the manuscript and suggested ``SAY``, "
"which is clearly much better.)"
msgstr ""
"``SAY`` は ``HELLO`` を実行変数にベクトル化するのに最適です(私が最初にこの例をForth入門(Starting "
"Forth)用に書いたとき、私はそれを ``VERSION`` と呼びました。ムーアは原稿をレビューして ``SAY`` を提案しました)。"

#: ../../chapter5.rst:1743
msgid "``I'M HARRY``"
msgstr "``I'M HARRY``"

#: ../../chapter5.rst:1742
msgid ""
"The word ``I'M`` seems more natural than ``LOGON HARRY``, ``LOGIN HARRY``"
" or ``SESSION HARRY``, as often seen."
msgstr ""
"よくあるように、``I'M`` という言葉は、 ``LOGON HARRY`` 、``LOGIN HARRY`` または ``SESSION "
"HARRY`` よりも自然に見えます。"

#: ../../chapter5.rst:1758
msgid "The choice of ``I'M`` is another invention of **Moore**, who says:"
msgstr "``I'M`` という選択は **ムーア** のまた別の発明であり、彼はこう言っています。"

#: ../../chapter5.rst:1748
msgid ""
"I detest the word ``LOGON``. There is no such word in English.  I was "
"looking for a word that said, \"I'm ...\" It was a natural. I just "
"stumbled across it.  Even though it's clumsy with that apostrophe, it has"
" that sense of rightness."
msgstr ""
"私は ``LOGON`` という言葉を嫌います。 英語にそのような言葉はありません。 "
"「私は…」という言葉を探していました。それは当たり前のことでした。 私はちょうどそれに出くわした。 "
"たとえそれがそのアポストロフィで不器用であっても、それはその正当性の感覚を持ちます。"

#: ../../chapter5.rst:1753
msgid ""
"All these little words are the nicest way of getting the \"Aha!\" "
"reaction.  If you think of the right word, it is **obviously** the right "
"word."
msgstr ""
"これらの小さな言葉はすべて、「なるほど！(Aha!)反応」 取得のための最良の方法です。 "
"あなたが正しい言葉を考えれば、あたりまえに正しいワードになります。"

#: ../../chapter5.rst:1757
msgid ""
"If you have a wide recall vocabulary, you're in a better position to come"
" up with the right word."
msgstr "あなたに幅広い連想ボキャブラリがあれば、正しい言葉を思いつきやすくなります。"

#: ../../chapter5.rst:1760
msgid ""
"Another of Moore’s favorite words is ``TH``, which he uses as an array "
"indexing word. For instance, the phrase"
msgstr "ムーアのもう1つのお気に入りのワードは ``TH`` です。彼はこれを配列インデックスワードとして使用します。 たとえば以下の句のように。"

#: ../../chapter5.rst:1767
msgid "returns the address of the “fifth” element of the array."
msgstr "配列の5番目の要素のアドレスを返します。"

#: ../../chapter5.rst:1772
msgid "Spell names in full."
msgstr "スペルに省略形を使わないで下さい。"

#: ../../chapter5.rst:1774
msgid ""
"I once saw some Forth code published in a magazine in which the author "
"seemed hell-bent on purging all vowels from his names, inventing such "
"eyesores as ``DSPL-BFR`` for “display buffer.” Other writers seem to "
"think that three characters magically says it all, coining ``LEN`` for "
"“length.” Such practices reflect thinking from a bygone age."
msgstr ""
"私はかつて雑誌に掲載されたForthコードを見たことがあります。その作者は「display buffer」を表す「DSPL-"
"BFR」のような目障りな名前を発明し、名前から全ての母音を追放することに必死なように見えました。他の作者共は「length」を意味する「LEN」をこねくり出して、3文字の呪文のように皆がそれを唱えてくれると思っているようです。そのような習慣は過ぎ去った時代からの思考を引きずっています。"

#: ../../chapter5.rst:1780
msgid ""
"Forth words should be fully spelled out. Feel proud to type every letter "
"of ``INITIALIZE`` or ``TERMINAL`` or ``BUFFER``. These are the words you "
"mean. The worst problem with abbreviating a word is that you forget just "
"how you abbreviated it. Was that ``DSPL`` or ``DSPLY``?"
msgstr ""
"Forthのワードはフルスペルであるべきです。 ``INITIALIZE`` や ``TERMINAL`` や ``BUFFER`` "
"のすべての文字を入力してください。 これらはあなたが意味する言葉です。 "
"ワードを短縮することの最悪の問題は、あなたがそれをどのように短縮したかを忘れているということです。 それは ``DSPL`` 、それとも "
"``DSPLY`` ですか？"

#: ../../chapter5.rst:1786
msgid ""
"Another problem is that abbreviations hinder readability. Any programming"
" language is hard enough to read without compounding the difficulty."
msgstr "もう1つの問題は、省略形が読みやすさを妨げることです。 どんなプログラミング言語でも読み下す難易度が上がります。"

#: ../../chapter5.rst:1790
msgid "Still, there are exceptions. Here are a few:"
msgstr "しかし、例外もあります。 "

#: ../../chapter5.rst:1792
msgid ""
"Words that you use extremely frequently in code. Forth employs a handful "
"of commands that get used over and over, but have little or no intrinsic "
"meaning:"
msgstr "コードで非常に頻繁に使用するワード。以下のように、Forthでは何度も繰り返し使われるが、本質的な意味をほとんど持たないか、または全く持たないコマンドがいくつかあります。"

#: ../../chapter5.rst:1800
msgid ""
"But there are so few of them, and they’re used so often, they become old "
"friends. I would never want to type, on a regular basis,"
msgstr ""
"しかし、それらの数はごくわずかであり、それらは頻繁に使用されているので、彼らは古くからの友達になります。 "
"私はそれらをフルスペルでタイプしまくりたいとは思いません。"

#: ../../chapter5.rst:1808
msgid ""
"(Interestingly, most of these symbols don’t have English counterparts. We"
" use the phrase “*colon* definition” because there’s no other term; we "
"say “*comma* a number into the dictionary” because it’s not exactly "
"compiling, and there’s no other term.)"
msgstr ""
"（興味深いことに、これらのシンボルの大部分は言葉(英語)に対応するものを持っていません。他に用語がないので「コロン定義(colon "
"definition)」という句を使用します。 他の用語はありません。）"

#: ../../chapter5.rst:1813
msgid ""
"Words that a terminal operator might use frequently to control an "
"operation. These words should be spelled as single letters, as are line "
"editor commands."
msgstr ""
"端末オペレータが操作を制御するために頻繁に使用する可能性のあるワード。 "
"これらのワードは、ラインエディタのコマンドと同様に、1文字のスペルで入力できるようにすべきです。"

#: ../../chapter5.rst:1817
msgid ""
"Words in which familiar usage implies that they be abbreviated. Forth "
"assembler mnemonics are typically patterned after the manufacturer’s "
"suggested mnemonics, which are abbreviations (such as JMP and MOV)."
msgstr "皆が知っている略語。Forthアセンブラのニーモニックは通常、製造元が推奨するニーモニック（JMPやMOVなど）の略称に基づいてパターン化されています。"

#: ../../chapter5.rst:1821
msgid ""
"Your names should be pronounceable; otherwise you may regret it when you "
"try to discuss the program with other people. If the name is symbolic, "
"invent a pronunciation (e.g., ``>R`` is called “to-r”; ``R>`` is called "
"“r-from”)."
msgstr ""
"あなたの名前は発音できるはずです。 そうでなければ、他の人とプログラムについて話し合おうとしたときに、後悔するかもしれません。 "
"名前がシンボリックである場合は、発音を考案してください（たとえば、 ``>R`` は「to-r」と呼ばれ、 ``R>`` "
"は「r-from」と呼ばれます）。"

#: ../../chapter5.rst:1828
msgid "Favor short words."
msgstr "短い言葉を好んで下さい。"

#: ../../chapter5.rst:1830
msgid ""
"Given the choice between a three-syllable word and a one-syllable word "
"that means the same thing, choose the shorter. ``BRIGHT`` is a better "
"name than ``INTENSE``. ``ENABLE`` is a better name than ``ACTIVATE``; "
"``GO``, ``RUN``, or ``ON`` may be better still."
msgstr ""
"同じことを意味する、3音節の単語と1音節の単語の選択を考えるなら、短い方を選択してください。 ``BRIGHT`` は ``INTENSE`` "
"よりも良い名前です。 ``ENABLE``  は ``ACTIVATE`` よりもいい名前です。 ``GO`` 、 ``RUN`` 、``ON``"
" の方がまだマシかもしれません。"

#: ../../chapter5.rst:1834
msgid ""
"Shorter names are easier to type. They save space in the source screen. "
"Most important, they make your code crisp and clean."
msgstr ""
"短い名前ほど入力が簡単です。 それらはソーススクリーンのスペースを節約します。 "
"最も重要なのは、それらがあなたのコードをくっきりときれいにすることです。"

#: ../../chapter5.rst:1839
msgid "Hyphenated names may be a sign of bad factoring."
msgstr "ハイフンで繋がれた名前は悪いファクタリング(要素分解)の兆候かもしれません。"

#: ../../chapter5.rst:1850
msgid "**Moore**:"
msgstr "ムーアは言います。"

#: ../../chapter5.rst:1842
msgid ""
"There are diverging programming styles in the Forth community.  One uses "
"hyphenated words that express in English what the word is doing. You "
"string these big long words together and you get something that is quite "
"readable."
msgstr ""
"Forthコミュニティには多様なプログラミングスタイルがあります。 "
"そのワードが何をしているのかを言葉(英語)で表現するハイフン付きのワードを使用します。 "
"あなたはこれらの大きな長い言葉を一緒につなぎ合わせると、かなり読みやすい何かを得ます。"

#: ../../chapter5.rst:1847
msgid ""
"But I immediately suspect that the programmer didn't think out the words "
"carefully enough, that the hyphen should be broken and the words defined "
"separately.  That isn't always possible, and it isn't always "
"advantageous. But I suspect a hyphenated word of mixing two concepts."
msgstr ""
"しかし、私はいの一番に、プログラマが十分に慎重にワードを考えなかった、ハイフンは無くすべきであり、ワードは別々に定義されるべきであると思います。 "
"それは必ずしも可能ではありません、そしてそれは常に有利ではありません。 "
"しかし、私は2つの概念を混在させるという、ハイフンでつながれたワードを疑っています。"

#: ../../chapter5.rst:1852
msgid "Compare the following two strategies for saying the same thing:"
msgstr "同じことを述べるための、以下の左右の戦略を比較してください。"

#: ../../chapter5.rst:1865
msgid ""
"The syntax on the left requires eight dictionary entries; the syntax on "
"the right requires only six-and some of the words are likely to be reused"
" in other parts of the application. If you had a ``MIDDLE`` motor and "
"solenoid as well, you’d need only seven words to describe sixteen "
"combinations."
msgstr ""
"左側の構文には8つの辞書エントリが必要です。 "
"右側の構文は6つだけでよく、ワードのいくつかはアプリケーションの他の部分で再利用できる可能性もあります。 ``MIDDLE`` "
"のモーターとソレノイドを使用している場合、16個の組み合わせを説明するのに7語しか必要ありません。"

#: ../../chapter5.rst:1873
msgid "Don't bundle numbers into names."
msgstr "名前に数値をまとめないでください。"

#: ../../chapter5.rst:1875
msgid ""
"Watch out for a series of names beginning or ending with numbers, such as"
" ``1CHANNEL``, ``2CHANNEL``, ``3CHANNEL``, etc."
msgstr ""
"``1CHANNEL`` 、 ``2CHANNEL`` 、 ``3CHANNEL`` "
"などのように、数値で始まる、または数値でわる名前のシリーズに注意してください。"

#: ../../chapter5.rst:1878
msgid ""
"This bundling of names and numbers may be an indication of bad factoring."
" The crime is similar to hyphenation, except that what should be factored"
" out is a number, not a word. A better factoring of the above would be"
msgstr ""
"名前と数値をこのようにまとめることは、ファクタリング(要素分解)が悪いことを示している可能性があります。 "
"ハイフン犯罪に似ていますが、括り出す必要があるのは単語ではなく数値である点が異なります。 "
"上記のより良いファクタリング(要素分解)は以下のようになるでしょう。"

#: ../../chapter5.rst:1889
msgid "In this case, the three words were reduced to one."
msgstr "この場合、3つあったワードを1つ減らせました。"

#: ../../chapter5.rst:1891
msgid ""
"Often the bundling of names and numbers indicates fuzzy naming. In the "
"above case, more descriptive names might indicate the purpose of the "
"channels, as in"
msgstr ""
"多くの場合、名前と数値をまとめることはあいまいな命名を示します。 ``CHANNEL`` "
"の例は、下記のように、よりわかりやすい名前でチャネルの目的を示すことができます。"

#: ../../chapter5.rst:1899
msgid "We’ll amplify on these ideas in the next chapter on “Factoring.”"
msgstr "次の「ファクタリング(要素分解)」の章で、これらの考えを詳しく説明します。"

#: ../../chapter5.rst:1902
msgid "Naming Standards: The Science"
msgstr "命名基準：その科学"

#: ../../chapter5.rst:1906
msgid "Learn and adopt Forth\\'s naming conventions."
msgstr "Forthの命名規則を学び、採り入れて下さい。"

#: ../../chapter5.rst:1908
msgid ""
"In the quest for short, yet meaningful names, Forth programmers have "
"adopted certain naming conventions. :doc:`Appendix E<appendixe>` includes"
" a list of the most useful conventions developed over the years."
msgstr ""
"短くても意味のある名前を探すために、Forthプログラマは特定の命名規則を採用しました。 :doc:`付録E<appendixe>` "
"には、長年にわたって開発された最も有用な規約のリストがあります。"

#: ../../chapter5.rst:1912
msgid ""
"An example of the power of naming conventions is the use of “dot” to mean"
" “print” or “display.” Forth itself uses"
msgstr "命名規則のパワーの一例は、「print」または「display」を意味するための「ドット(``.``)」の使用です。"

#: ../../chapter5.rst:1919
msgid ""
"for displaying various types of numbers in various formats. The "
"convention extends to application words as well. If you have a variable "
"called ``DATE,`` and you want a word that displays the date, use the name"
msgstr ""
"さまざまな形式でさまざまな種類の数値を表示するためのものです。 この規約はアプリケーションのワードにも適用されます。 ``DATE`` "
"という変数があり、日付を表示するワードが必要な場合は以下のようになります。"

#: ../../chapter5.rst:1927
msgid ""
"A caution: The overuse of prefixes and suffixes makes words uglier and "
"ultimately less readable. Don’t try to describe everything a word does by"
" its name alone. After all, a name is a symbol, not a shorthand for code."
" Which is more readable and natural sounding?:"
msgstr ""
"注意：接頭辞と接尾辞を使いすぎると、ワードが曖昧になり、最終的に読みにくくなります。 "
"その名前だけでワードがすることすべてを説明しようとしないでください。 結局、名前はシンボルであり、コードの省略形ではありません。 "
"以下はどちらが読みやすく、自然に聞こえますか？"

#: ../../chapter5.rst:1932
msgid "Oedipus complex"
msgstr "Oedipus complex"

#: ../../chapter5.rst:1934
msgid "(which bears no intrinsic meaning), or"
msgstr "（本質的な意味はありません）、または"

#: ../../chapter5.rst:1936
msgid "subconscious-attachment-to-parent-of-opposite-sex complex"
msgstr "subconscious-attachment-to-parent-of-opposite-sex complex"

#: ../../chapter5.rst:1938
msgid "Probably the former, even though it assumes you know the play."
msgstr "あなたがそのプレイを知っていると仮定していても、おそらく前者です。"

#: ../../chapter5.rst:1942
msgid ""
"Use prefixes and suffices to differentiate between like words rather than"
" to cram details of meaning into the name itself."
msgstr "意味の詳細を名前自体に詰め込むのではなく、同じ単語を区別するために接頭辞と接尾辞を使用して下さい。"

#: ../../chapter5.rst:1945
msgid "For instance, the phrase"
msgstr "例えば、このフレーズ"

#: ../../chapter5.rst:1951
msgid "is just as readable as"
msgstr "これより、以下の方が読みやすい"

#: ../../chapter5.rst:1957
msgid ""
"and cleaner as well. It is therefore preferable, unless we need an "
"additional word called ``DONE`` (as a flag, for instance)."
msgstr "そしてきれいになる。 したがって、 ``DONE`` と呼ばれる追加のワードが（フラグとして）必要でない限り、それが望ましいです。"

#: ../../chapter5.rst:1960
msgid "A final tip on naming:"
msgstr "名前付けに関する最後のヒントです。"

#: ../../chapter5.rst:1964
msgid ""
"Begin all hex numbers with \"0\" (zero) to avoid potential collisions "
"with names."
msgstr "名前との衝突を避けるために、すべての16進数を 0(ゼロ)で始めてください。"

#: ../../chapter5.rst:1967
msgid "For example, write ``0ADD``, not ``ADD``."
msgstr "例えば 「ADD」ではなく、「0ADD」と書いて下さい。"

#: ../../chapter5.rst:1969
msgid ""
"By the way, don’t expect your Forth system to necessarily conform to the "
"above conventions. The conventions are meant to be used in new "
"applications."
msgstr ""
"ただし、あなたのForthシステムが必ずしも上記の規約に準拠することを期待しないでください。 "
"規約は新しいアプリケーションで使用されることを意図しています。"

#: ../../chapter5.rst:1973
msgid ""
"Forth was created and refined over many years by people who used it as a "
"means to an end. At that time, it was neither reasonable nor possible to "
"impose naming standards on a tool that was still growing and evolving."
msgstr ""
"Forthは何年にもわたってそれを最後の手段として使用した人々によって作成され洗練されました。 "
"その当時、まだ成長し進化しているツールに命名基準を課すことは合理的でも可能でもありませんでした。"

#: ../../chapter5.rst:1977
msgid "Had Forth been designed by committee, we would not love it so."
msgstr "Forthが政府の委員会で設計された代物だったら、私はForthをこんなには愛さなかったでしょう。"

#: ../../chapter5.rst:1980
msgid "More Tips for Readability"
msgstr "より読みやすくするためのヒント"

#: ../../chapter5.rst:1982
msgid ""
"Here are some final suggestions to make your code more readable. "
"(Definitions appear in :doc:`Appendix C<appendixc>`.)"
msgstr "ここに、コードを読みやすくするための最後の提案をいくつか示します(その定義は :doc:`付録C<appendixc>` にあります)。"

#: ../../chapter5.rst:1985
msgid ""
"One constant that pays for itself in most applications is ``BL`` (the "
"ASCII value for “blank-space”)."
msgstr "ほとんどのアプリケーションでは、``BL`` (「空白(Blank-Space)」のASCII値)という代償があります。"

#: ../../chapter5.rst:1988
msgid ""
"The word ``ASCII`` is used primarily within colon definitions to free you"
" from having to know the literal value of an ASCII character. For "
"instance, instead of writing:"
msgstr "``ASCII`` というワードは、ASCII文字のリテラル値を知らなくても済むようにするために、主にコロンの定義内で使用されます。 "

#: ../../chapter5.rst:1996
msgid "where 41 is the ASCII representation for right-parenthesis, you can write"
msgstr "ここで、41は右括弧 ``)`` のASCIIコードです。それは以下のように書く事ができます。"

#: ../../chapter5.rst:2003
msgid ""
"A pair of words that can make dealing with booleans more readable are "
"``TRUE`` and ``FALSE``. With these additions you can write phrases such "
"as"
msgstr ""
"ブール値を扱いやすくするためのワードのペアは、 ``TRUE`` と ``FALSE`` です。 "
"これらの追加を使うと、以下のようなフレーズを書くことができます。"

#: ../../chapter5.rst:2012
msgid "to set a flag or"
msgstr "のようにフラグをセットしたり、"

#: ../../chapter5.rst:2018
msgid "to clear it."
msgstr "のようにフラグをクリアします。"

#: ../../chapter5.rst:2020
msgid ""
"(I once used ``T`` and ``F``, but the words are needed so rarely I now "
"heed the injunction against abbreviations.)"
msgstr ""
"(私はかつて ``T`` と ``F`` "
"を使ったことがありますが、そのワードが必要とされることはめったにないので、今では私は略語禁止規則に気をつける必要はありません。)"

#: ../../chapter5.rst:2024
msgid ""
"As part of your application (not necessarily part of your Forth system), "
"you can take this idea a step further and define:"
msgstr "アプリケーションの一部として（必ずしもForthシステムの一部ではありませんが）、このアイデアをさらに一歩進めて次のように定義することができます。"

#: ../../chapter5.rst:2032
msgid "These words allow you to write:"
msgstr "これらのワードによって、あなたは以下のように書く事ができます。"

#: ../../chapter5.rst:2044
msgid ""
"Other names for these definitions include ``SET`` and ``RESET``, although"
" ``SET`` and ``RESET`` most commonly use bit masks to manipulate "
"individual bits."
msgstr ""
"これらの定義の他の名前には、 ``SET`` と ``RESET`` がありますが、 ``SET`` と ``RESET`` "
"は個々のビットを操作するのに通常ビットマスクを使います。"

#: ../../chapter5.rst:2047
msgid ""
"An often-used word is ``WITHIN``, which determines whether a given value "
"lies within two other values. The syntax is:"
msgstr "よく使われるワードは ``WITHIN`` です。これは与えられた値が他の2つの値の間にあるかどうかを決定します。 構文は次のとおりです。"

#: ../../chapter5.rst:2055
msgid ""
"where “n” is the value to be tested and “lo” and “hi” represent the "
"range. ``WITHIN`` returns true if “n” is *greater-than or equal-to* “lo” "
"and *less-than* “hi.” This use of the non-inclusive upper limit parallels"
" the syntax of ``DO``  ``LOOP`` s."
msgstr ""
"ここで、「n」はテストする値、「lo」と「hi」は範囲を表します。「n」が「lo」以上「hi」未満の場合、 ``WITHIN`` "
"はtrueを返します。この包括的な上限の使用は、 ``DO LOOP`` の構文と同等です。"

#: ../../chapter5.rst:2060
msgid ""
"Moore recommends the word ``UNDER+``. It’s useful for adding a value to "
"the number just under the top stack item, instead of to the top stack "
"item. It could be implemented in high level as:"
msgstr ""
"ムーアは、 ``UNDER+`` というワードを推奨しています。 "
"一番上のスタック項目の代わりに一番上の項目の直下にある数値に値を追加するのに便利です。 それは以下のように高レベルで実装されるかもしれません。"

#: ../../chapter5.rst:2070
msgid "Summary"
msgstr "要約"

#: ../../chapter5.rst:2072
msgid ""
"Maintainability requires readability. In this chapter we’ve enumerated "
"various ways to make a source listing more readable. We’ve assumed a "
"policy of making our code as self-documenting as possible. Techniques "
"include listing organization, spacing and indenting, commenting, name "
"choices, and special words that enhance clarity."
msgstr ""
"保守性には読みやすさが必要です。 この章では、ソースリストを読みやすくするためのさまざまな方法を列挙しました。 "
"私たちは自分たちのコードをできる限り自己文書化することを方針としています。 "
"その技法には、リスト整理、空白と字下げ、コメント、名前の選択、および明確さを高める特別なワードが含まれます。"

#: ../../chapter5.rst:2078
msgid ""
"We’ve mentioned only briefly auxiliary documentation, which includes all "
"documentation apart from the listing itself. We won’t discuss auxiliary "
"documentation further in this volume, but it remains an integral part of "
"the software development process."
msgstr ""
"ここでは、リスト自体以外のすべてのドキュメントを含む、補助的なドキュメントについて簡単に説明しました。 "
"このドキュメントでは、補足資料についてはこれ以上説明しませんが、それでもこれらはソフトウェア開発プロセスに不可欠な部分です。"

#: ../../chapter5.rst:2084
msgid "REFERNCES"
msgstr "参考文献"

#: ../../chapter5.rst:2086
msgid ""
"Gregory Stevenson, \"Documentation Priorities,\" **1981 FORML Conference "
"Proceedings,**  p. 401."
msgstr ""
"Gregory Stevenson, \"Documentation Priorities,\" **1981 FORML Conference "
"Proceedings,**  p. 401."

#: ../../chapter5.rst:2087
msgid ""
"Joanne Lee, \"Quality Assurance in a ForthEnvironment,\" (Appendix A),  "
"**1981 FORML Proceedings,**  p. 363."
msgstr ""
"Joanne Lee, \"Quality Assurance in a ForthEnvironment,\" (Appendix A),  "
"**1981 FORML Proceedings,**  p. 363."

#: ../../chapter5.rst:2088
msgid ""
"Edsger W. Dijkstra,  **Selected Writings on Computing: A Personal "
"Perspective,**  New York, Springer Verlag, Inc.,1982."
msgstr ""
"エドガー・ダイクストラ(Edsger W. Dijkstra),  **Selected Writings on Computing: A "
"Personal Perspective,**  New York, Springer Verlag, Inc.,1982."

#: ../../chapter5.rst:2089
msgid ""
"Henry Laxen, \"Choosing Names,\"  **Forth Dimensions,** vol. 4, no.\\ 4, "
"Forth Interest Group."
msgstr ""
"Henry Laxen, \"Choosing Names,\"  **Forth Dimensions,** vol. 4, no.\\ 4, "
"Forth Interest Group."

