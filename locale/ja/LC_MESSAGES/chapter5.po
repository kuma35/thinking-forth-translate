# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Leo Brodie
# This file is distributed under the same license as the Thinking Forth
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Thinking Forth 0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-16 05:01+0900\n"
"PO-Revision-Date: 2019-07-16 05:03+0900\n"
"Last-Translator: kuma35\n"
"Language: ja_JP\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../chapter5.rst:4
msgid "5. Implementation: Elements of Forth Style"
msgstr "第５章 実装(Forthスタイルの要素)"

#: ../../chapter5.rst:6
msgid ""
"Badly written Forth has been accused of looking like “code that went "
"through a trash compactor.” It’s true, Forth affords more freedom in the "
"way we write applications. But that freedom also gives us a chance to "
"write exquisitely readable and easily maintainable code, provided we "
"consciously employ the elements of good Forth style."
msgstr "正しく書かれていないForthは、「ゴミ圧縮機を通過したコード」のように見えると非難されてきました。事実、Forthは、アプリケーションをより自由に書くことができます。しかし、一方でその自由度は、私たちが良きForthスタイルの要素を意識的に採用するなら、私たちに絶妙に読解可能で容易に保守可能なコードを書く機会も与えます。"

#: ../../chapter5.rst:13
msgid "In this chapter we’ll delve into Forth coding convention including:"
msgstr "この章では、Forthのコーディング規約について詳しく説明します。"

#: ../../chapter5.rst:15
msgid "listing organization"
msgstr "リストの組織化"

#: ../../chapter5.rst:17
msgid "screen layout, spacing and indentation"
msgstr "画面レイアウト、間隔、字下げ"

#: ../../chapter5.rst:19
msgid "commenting"
msgstr "コメント"

#: ../../chapter5.rst:21
msgid "choosing names"
msgstr "名前の選び方"

#: ../../chapter5.rst:23
msgid ""
"I wish I could recommend a list of hard-and-fast conventions for "
"everyone. Unfortunately, such a list may be inappropriate in many "
"situations. This chapter merges many widely-adopted conventions with "
"personal preferences, commented with alternate ideas and the reasons for "
"the preferences. In other words:"
msgstr ""
"私は、誰のためにもなる、最も速くて速い規約のリストを推薦することができれば、と思います。 "
"残念ながら、そのようなリストは多くの状況で不適切な場合があります。 "
"この章では、広く採用されている多くの規則と個人的な好みを組み合わせ、別のアイデアや好みの理由についてコメントしています。 言い換えると、"

#: ../../chapter5.rst:33
msgid ""
"I’d especially like to thank Kim Harris, who proposed many of the "
"conventions described in this chapter, for his continuing efforts at "
"unifying divergent views on good Forth style."
msgstr "私は特に、この章で説明されている規約の多くを提案してくれたキム・ハリスに、素晴らしいForthスタイルについて、意見の相違を統一する努力を続けてくれたことに感謝します。"

#: ../../chapter5.rst:39
msgid "Listing Organization"
msgstr "リストの組織化"

#: ../../chapter5.rst:41
msgid ""
"A well-organized book has clearly defined chapters, with clearly defined "
"sections, and a table of contents to help you see the organization at a "
"glance. A well-organized book is easy to read. A badly organized book "
"makes comprehension more difficult, and makes finding information later "
"on nearly impossible."
msgstr ""
"よく組織化されている本には、明確に定義された章、明確に定義された節、および一目で構成を見るのに役立つ目次があります。 "
"よく組織化されている本は読みやすいです。 本がよく組織化されていないと、理解が難しくなり、後で情報を見つけることがほぼ不可能になります。"

#: ../../chapter5.rst:52
msgid "I still don't see how these programming conventions enhance readability."
msgstr "私はまだこれらのプログラミング規約がどのように読みやすさを向上させるか分かりません。"

#: ../../chapter5.rst:54
msgid ""
"The necessity for good organization applies to an application listing as "
"well. Good organization has three aspects:"
msgstr "優れた組織化の必要性は、アプリケーションリストにも当てはまります。 良い組織化には3つの側面があります。"

#: ../../chapter5.rst:57 ../../chapter5.rst:64
msgid "Decomposition"
msgstr "分解"

#: ../../chapter5.rst:59 ../../chapter5.rst:81
msgid "Composition"
msgstr "構成"

#: ../../chapter5.rst:61
msgid "Disk partitioning"
msgstr "ディスク割当て"

#: ../../chapter5.rst:66
msgid ""
"As we’ve already seen, the organization of a listing should follow the "
"decomposition of the application into lexicons. Generally these lexicons "
"should be sequenced in “uses” order. Lexicons being *used* should precede"
" the lexicons which *use* them."
msgstr ""
"すでに見たように、リストの組織化はアプリケーションの用語集への分解に従うべきです。 一般に、これらの用語集は「使用」順に並べられるべきです。 "
"使用されている用語集は、それらを使用している用語集の前に置くべきです。"

#: ../../chapter5.rst:71
msgid ""
"On a larger scale, elements in a listing should be organized by degree of"
" complexity, with the most complex variations appearing towards the end. "
"It’s best to arrange things so that you can leave off the lattermost "
"screens (i.e., not load them) and still have a self-sufficient, running "
"application, working properly except for the lack of the more advanced "
"features."
msgstr "大規模では、リスト内の要素は複雑さの度合いによって組織されるべきであり、最も複雑なバリエーションはその終わりに現れます。最後の画面を表示せず（つまりロードしないで）、より高度な機能がないことを除けば適切に動作する自給自足のアプリケーションを使用できるようにすることをお勧めします。"

#: ../../chapter5.rst:78
msgid ""
"We discussed the art of decomposition extensively in :doc:`Chapter "
"Three<chapter3>`."
msgstr "分解の技術については、 :doc:`第３章<chapter3>` で詳しく説明しました。"

#: ../../chapter5.rst:83
msgid ""
"Composition is the putting together of pieces to create a whole. Good "
"composition requires as much artistry as good decomposition."
msgstr "構成は全体を作成するための部分の組み合わせです。 良い構成は、良い分解と同じくらいの腕前が必要です。"

#: ../../chapter5.rst:86
msgid ""
"One of Forth’s present conventions is that source code resides in "
"“screens,” which are 1K units of mass storage. (The term “screen” refers "
"to a block used specifically for source code.) It’s possible in Forth to "
"chain every screen of code to the next, linking the entire listing "
"together linearly like a lengthy parchment scroll. This is not a useful "
"approach. Instead:"
msgstr ""
"Forthの現在の慣習の1つは、ソースコードが1Kの大容量記憶装置の「スクリーン(screen)」上にあるということです(「スクリーン」という用語は、ソースコード専用に使用されるブロック(block)を指します)。(。"
" Forthでは、長い羊皮紙スクロールのようにリスト全体を線形にリンクすることで、コードのすべての画面を次の画面にチェインすることができます。 "
"これは便利なアプローチではありません。 代わりに、"

#: ../../chapter5.rst:95
msgid "Structure your application listing like a book: hierarchically."
msgstr "アプリケーションのリストの構造を本のようにします。つまり階層化です。"

#: ../../chapter5.rst:97
msgid "An application may consist of:"
msgstr "1つのアプリケーションは以下で構成されます。"

#: ../../chapter5.rst:100
msgid "Screens:"
msgstr "(複数の)スクリーン"

#: ../../chapter5.rst:100
msgid "the smallest unit of Forth source"
msgstr "Forthのソースの最小単位です。"

#: ../../chapter5.rst:103
msgid "Lexicons:"
msgstr "(複数の)用語集"

#: ../../chapter5.rst:103
msgid "one to three screens, enough to implement a component"
msgstr "1から3スクリーンは、1つのコンポーネントを実装するのに充分な大きさです。"

#: ../../chapter5.rst:106
msgid "Chapters:"
msgstr "(複数の)章"

#: ../../chapter5.rst:106
msgid "a series of related lexicons, and"
msgstr "一連の関連する用語集。そして、"

#: ../../chapter5.rst:110
msgid "Load screens:"
msgstr "(複数の)一括ロード用スクリーン"

#: ../../chapter5.rst:109
msgid ""
"analogous to a table of contents, a screen that loads the chapters in the"
" proper sequence."
msgstr "目次と同じように、章を適切な順序でロードするスクリーンです。"

#: ../../chapter5.rst:112
msgid "Example of an application-load screen"
msgstr "アプリケーション・ロード・スクリーンの例"

#: ../../chapter5.rst:114
msgid "Screen #1"
msgstr "Screen #1"

#: ../../chapter5.rst:133
msgid "Application-load Screen"
msgstr "アプリケーション・ロード・スクリーン"

#: ../../chapter5.rst:135
msgid ""
":numref:`fig5-1`  is an example of an application-load screen. Since it "
"resides in Screen 1, you can load this entire application by entering"
msgstr ""
":numref:`fig5-1` アプリケーション・ロード・スクリーンの例です。 "
"スクリーン1にあるので、以下のとおり入力してこのアプリケーション全体をロードできます。"

#: ../../chapter5.rst:143
msgid ""
"The individual load commands within this screen load the chapters of the "
"application. For instance, Screen 12 is the load screen for the video "
"primitives chapter."
msgstr ""
"このスクリーン内の個々のロードコマンドはアプリケーションの章をロードします。 "
"たとえば、スクリーン12は、ビデオプリミティブの章のロード・スクリーンです。"

#: ../../chapter5.rst:147
msgid ""
"As a reference tool, the application-load screen tells you where to find "
"all of the chapters. For instance, if you want to look at the routines "
"that do framing, you can see that the section starts at Screen 90."
msgstr ""
"参照ツールとして、アプリケーション・ロード・スクリーンでは、すべての章の場所がわかります。 "
"たとえば、フレーミングを実行するルーチンを見たい場合は、そのセクションがスクリーン90から始まることがわかります。"

#: ../../chapter5.rst:151
msgid ""
"Each chapter-load screen in turn, loads all of the screens comprising the"
" chapter. We’ll study some formats for chapter-load screens shortly."
msgstr "各章のロードスクリーンは、順番に章を構成するすべてのスクリーンをロードします。 章ロード画面のフォーマットについてはすぐ後で検討します。"

#: ../../chapter5.rst:154
msgid ""
"The primary benefit of this hierarchical scheme is that you can load any "
"section, or any screen by itself, without having to load the entire "
"application. Modularity of the source code is one of the reasons for "
"Forth’s quick turnaround time for editing, loading, and testing "
"(necessary for the iterative approach). Like pages of a book, each screen"
" can be accessed individually and quickly. It’s a “random access” "
"approach to source-code maintenance."
msgstr ""
"この階層構造の主な利点は、アプリケーション全体をロードしなくても、任意のセクションまたは任意のスクリーンを単独でロードできることです。 "
"ソースコードのモジュール性は、Forthの編集・ロード・テストのための短いターンアラウンドタイム（反復アプローチのために必要）の理由の1つです。 "
"本のページと同様に、各スクリーンにも個別にすばやくアクセスできます。 これはソースコードのメンテナンスに対する「ランダムアクセス」アプローチです。"

#: ../../chapter5.rst:162
msgid ""
"You can also replace any passage of code with a new, trial version by "
"simply changing the screen numbers in the load screen. You don’t have to "
"move large passages of source code around within a file."
msgstr ""
"ロード・スクリーンでスクリーン番号を変更するだけで、コードの一部を新しい試用版に置き換えることもできます。 "
"ファイル内で大量のソースコードを移動する必要はありません。"

#: ../../chapter5.rst:166
msgid ""
"In small applications, there may not be such things as chapters. The "
"application-load screen will directly load all the lexicons. In larger "
"applications, however, the extra level of hierarchy can improve "
"maintainability. A screen should either be a load-screen or a code-"
"screen, not a mixture. Avoid embedding a ``LOAD`` or ``THRU`` command in "
"the middle of a screen containing definitions just because you “need "
"something” or because you “ran out of room.”"
msgstr ""
"小さなアプリケーションでは、章のようなものがないかもしれません。 アプリケーション・ロード・スクリーンはすべての用語集を直接ロードします。 "
"ただし、大規模なアプリケーションでは、階層を追加することで保守性を向上させることができます。 "
"スクリーンは混合ではなく、ロード・スクリーンまたはコード・スクリーンのどちらかにする必要があります。 定義が表示されているスクリーンの途中に "
"``LOAD`` や ``THRU`` "
"コマンドを埋め込むのは避けてください。それを行うのは「何か必要」または「スクリーンを使い果たした」という理由の時だけにしてください。"

#: ../../chapter5.rst:176
msgid "Skip Commands"
msgstr "スキップ・コマンド"

#: ../../chapter5.rst:178
msgid ""
"Two commands make it easy to control what gets loaded in each screen and "
"what gets ignored. They are:"
msgstr "以下の2つのコマンドを使用すると、各画面に何をロードし、何を無視するかを簡単に制御できます。"

#: ../../chapter5.rst:186
msgid ""
"``\\`` is pronounced “skip-line.” It causes the Forth interpreter to "
"ignore everything to the right of it on the same line. (Since ``\\`` is a"
" Forth word, it must be followed by a space.) It does not require a "
"delimiter."
msgstr ""
"``\\`` は「スキップ・ライン」(skip-"
"line)と発音します。それはForthインタプリタに同じ行のそれの右側にあるすべてを無視させます( ``\\`` "
"はForthのワードであるため、スペースを続ける必要があります)。(訳注: ``(`` … ``)`` と異なり)区切り文字は不要です。"

#: ../../chapter5.rst:191
msgid ""
"In :numref:`fig5-1` , you see ``\\`` used in two ways: to begin the "
"screen-comment line (Line 0), and to begin comments on individual lines "
"which have no more code to the right of the comment."
msgstr ""
":numref:`fig5-1` では、``\\`` "
"が2つの方法で使われているのがわかります。スクリーンコメント行(行0)の始めと、個々の行のコードの後ろのコメントの始まりとしてです。"

#: ../../chapter5.rst:195
msgid ""
"During testing, ``\\`` also serves to temporarily “paren out” lines that "
"already contain a right parenthesis in a name or comment. For instance, "
"these two “skip-line”s keep the definition of ``NUTATE`` from being "
"compiled without causing problems in encountering either right "
"parenthesis:"
msgstr ""
"テスト中に、 ``\\`` は、すでに名前やコメントに右括弧が含まれている行を一時的にコメントアウトするのにも役立ちます。 "
"例えば、以下の2つの「スキップ・ライン」は、右括弧に出くわすことによる問題を引き起こすことなく、 ``NUTATE`` "
"の定義がコンパイルされるのを防ぎます。"

#: ../../chapter5.rst:206
msgid ""
"``\\S`` is pronounced “skip-screen.” It causes the Forth interpreter to "
"stop interpreting the screen entirely, as though there were nothing else "
"in the screen beyond ``\\S``."
msgstr ""
"``\\S`` は「スキップ／スクリーン(skip-screen)」と発音します。これはForthインタプリタに、 ``\\S`` "
"を超えて以降、そのスクリーンに何もなかったかのように、 ``\\S`` 以降のスクリーン内の解釈を完全に停止させます。"

#: ../../chapter5.rst:210
msgid ""
"In many Forth systems, this function is the same as ``EXIT``, which is "
"the run-time routine for semicolon. In these systems the use of ``EXIT`` "
"is acceptable. Some Forth systems, however, require for internal reasons "
"a different routine for the “skip-screen” function."
msgstr ""
"多くのForthシステムでは、この機能はセミコロンのためのランタイムルーチンである ``EXIT`` と同じです。 これらのシステムでは "
"``EXIT`` "
"の使用は受け付けられます。ただし、Forthシステムの中には、内部的な理由から「スクリーンのスキップ」機能に対して別のルーチンを必要とするものがあります。"

#: ../../chapter5.rst:216
msgid ""
"Definitions for ``\\`` and ``\\S`` can be found in :doc:`Appendix "
"C<appendixc>`."
msgstr "``\\`` と ``\\S`` の定義は :doc:`付録C<appendixc>` にあります。"

#: ../../chapter5.rst:219
msgid "Chapter-load Screens"
msgstr "章ロード・スクリーン"

#: ../../chapter5.rst:221
msgid ""
":numref:`fig5-2`  illustrates a typical chapter-load screen. The screens "
"loaded by this screen are referred to relatively, not absolutely as they "
"were in the application-load screen."
msgstr ""
":numref:`fig5-2` は典型的な章ロード・スクリーンを示しています。 "
"ここでロードされるスクリーンは相対番号指定です。アプリケーション・ロード・スクリーンでの絶対番号指定とは異なります。"

#: ../../chapter5.rst:225
msgid ""
"This is because the chapter-load screen is the first screen of the "
"contiguous range of screens in the chapter. You can move an entire "
"chapter forward or backward within the listing; the relative pointers in "
"the chapter-load screen are position-independent. All you have to change "
"is the single number in the application-load screen that points to the "
"beginning of the chapter."
msgstr ""
"これは、章ロード・スクリーンが章内の連続したスクリーン範囲の最初のスクリーンであるためです。 リスト内で章全体を前後に移動できます。 "
"章ロード・スクリーンの相対ポインタは絶対位置に依存しません。 "
"変更する必要があるのは、アプリケーション・ロード・スクリーンの1つの数字だけで、章の先頭を指しています。"

#: ../../chapter5.rst:232
msgid "Example of a chapter-load screen."
msgstr "章ロード・スクリーンの例"

#: ../../chapter5.rst:234
msgid "Screen #100"
msgstr "Screen #100"

#: ../../chapter5.rst:251
msgid ""
"Use absolute screen numbers in the application-load screen.  Use relative"
" screen numbers in the chapter- or section-load screens."
msgstr ""
"アプリケーション・ロード・スクリーンでは絶対スクリーン番号を使用してください。 "
"章ロードまたは節ロード・スクリーンでは、相対的なスクリーン番号を使用してください。"

#: ../../chapter5.rst:254
msgid ""
"There are two ways to implement relative loading. The most common is to "
"define:"
msgstr "相対ロードを実装する方法は2つあります。 最も一般的なのは以下です。"

#: ../../chapter5.rst:261
msgid "and"
msgstr "そして"

#: ../../chapter5.rst:268
msgid ""
"My own way, which I submit as a more useful factoring, requires a single "
"word, ``FH`` (see :doc:`Appendix C<appendixc>` for its definition)."
msgstr ""
"私流の、より有用な因数分解として提示する方法は、単一のワード ``FH`` を必要とします(その定義については "
":doc:`付録C<appendixc>` 参照)。"

#: ../../chapter5.rst:271
msgid "The phrase"
msgstr "それはこんなフレーズです。"

#: ../../chapter5.rst:277
msgid "is read “1 from here ``LOAD``,” and is equivalent to 1 ``+LOAD``."
msgstr "「1 From Here load」(ここから1へだたったスクリーンをロード)と読みます。これは「1 ``+LOAD`` 」と同じです。"

#: ../../chapter5.rst:279
msgid "Similarly,"
msgstr "同様に、"

#: ../../chapter5.rst:285
msgid "is read “2 from here, 5 from here ``THRU``.”"
msgstr ""
"「2 from here, 5 from here ``THRU`` "
"」(ここから1へだったったところから、ここから5へだたったところまで、通しで)と読みます。"

#: ../../chapter5.rst:287
msgid "Some programmers begin each chapter with a dummy word; e.g.,"
msgstr "プログラマの中には各章をダミーのワードで始める人もいます。"

#: ../../chapter5.rst:293
msgid ""
"and list its name in the comment on the line where the chapter is loaded "
"in the application-load screen. This permits selectively ``FORGET`` ting "
"any chapter and reloading from that point on without having to look at "
"the chapter itself."
msgstr ""
"アプリケーション・ロード・スクリーンで章がロードされている行のコメントにその名前をリストします。 "
"これにより、章自体を見なくても、任意の章を選択して、 ``FORGET`` してその場所からリロードできます。"

#: ../../chapter5.rst:298
msgid ""
"Within a chapter the first group of screens will usually define those "
"variables, constants, and other data structures needed globally within "
"the chapter. Following that will come the lexicons, loaded in “uses” "
"order. The final lines of the chapter-load screen normally invoke any "
"needed initialization commands."
msgstr ""
"章の中では、最初のグループのスクリーンは通常、章の中でグローバルに必要とされるそれらの変数、定数、および他のデータ構造を定義します。 "
"それに続いて「用途」順にロードされる用語集が来るでしょう。 章ロード・スクリーンの最後の行は、通常、必要な初期化コマンドを呼び出します。"

# Forthwrights wright=職人
#: ../../chapter5.rst:304
msgid ""
"Some of the more style-conscious Forthwrights begin each chapter with a "
"“preamble” that discusses in general terms the theory of operation for "
"the components described in the chapter. :numref:`fig5-3`  is a sample "
"preamble screen which demonstrates the format required at Moore Products "
"Co."
msgstr ""
"よりスタイルを意識したForth職人の中には、各章の冒頭に、その章で説明されているコンポーネントの動作を一般的な用語で説明したものがあります。 "
":numref:`fig5-3` は、ムーアプロダクツ社書式の前書きスクリーンの例です。"

#: ../../chapter5.rst:310
msgid "Moore Products Co.'s format for chapter preambles."
msgstr "ムーアプロダクツ社書式の章前書き"

#: ../../chapter5.rst:312
msgid "Screen #101"
msgstr "Screen #101"

#: ../../chapter5.rst:330
msgid "Screen #102"
msgstr "Screen #102"

#: ../../chapter5.rst:355
msgid ""
"**Charles Moore** (no relation to Moore Products Co.) places less "
"importance on the well-organized hierarchical listing than I do. Moore:"
msgstr "**チャールズ・ムーア** (ムーアプロダクツ社とは無関係です) は、私と違って、組織化された階層型リストをあまり重要視しません。ムーアは言います。"

#: ../../chapter5.rst:348
msgid ""
"I structure **applications** hierarchically, but not necessarily "
"**listings.**  My listings are organized in a fairly sloppy way, not at "
"all hierarchically in the sense of primitives first."
msgstr "私はアプリケーションを階層的に構成しますが、必ずしもリストではありません。私のリストはかなりずさんな編成になっています。原始的なのから始めると言う意味で階層的ではありません。"

#: ../../chapter5.rst:352
msgid ""
"I use ``LOCATE`` [also known as ``VIEW``; see the Handy Hint in "
"**Starting Forth**, Chapter Nine].  As a result, the listing is much less"
" carefully organized because I have ``LOCATE`` to find things for me.  I "
"never look at listings."
msgstr ""
"私は ``LOCATE`` を使います( ``VIEW`` としても知られています。 **Starting Forth** のChapter 9 "
"Handy Hint;邦訳 FORTH入門 第9章、「知っていると便利です ソース定義を ``LOCATE`` する方法」P.291)。 "
"その結果、リストはそれほど慎重に整理されていません。なぜなら、``LOCATE`` "
"が、私の探しているものを探し出してくれるからです。私はリストを見たことがありません(訳注: ``LOCATE`` "
"は、指定のワードの定義箇所を、スクリーン群から検索)。"

#: ../../chapter5.rst:358
msgid "––> vs. THRU"
msgstr "––> 対 THRU"

#: ../../chapter5.rst:360
msgid ""
"On the subject of relative loading, one popular way to load a series of "
"adjacent screens is with the word ``-->`` (pronounced “next block”). This"
" word causes the interpreter to immediately cease interpreting the "
"current screen and begin interpreting the next (higher-numbered) screen."
msgstr ""
"相対ロードの問題では、一連の隣接するスクリーンをロードするための一般的な方法の1つは、ワード ``-->`` (「ネクスト・ブロック(next-"
"block)」と発音)を使用することです。 "
"このワードにより、インタプリタは直ちに現在のスクリーンの解釈を中止し、次の(大きい番号の)スクリーンの解釈を開始します。"

#: ../../chapter5.rst:366
msgid ""
"If your system provides ``-->``, you must choose between using the "
"``THRU`` command in your chapter-load screen to load each series of "
"screens, or linking each series together with the arrows and LOADing only"
" the first in the series. (You can’t do both; you’d end up loading most "
"of the screens more than once.)"
msgstr ""
"あなたのシステムが ``-->`` を提供している場合は、章ロード・スクリーンで ``THRU`` "
"コマンドを使用して一連のスクリーンをロードするか、一連のスクリーンを ``-->`` "
"でリンクして最初のものだけをロードするかを選択する必要があります(両方を行うことはできません。両方使うと、ほとんどのスクリーンを複数回読み込むことになります)。"

#: ../../chapter5.rst:373
msgid ""
"The nice thing about the arrows is this: suppose you change a screen in "
"the middle of a series, then reload the screen. The rest of the series "
"will automatically get loaded. You don’t have to know what the last "
"screen is."
msgstr ""
"``-->`` のいいところは、あなたが一連のシリーズの途中でスクリーンを変えて、それからスクリーンをリロードすると仮定してください。 "
"残りスクリーンは自動的に再ロードされます。 最後のスクリーンが何であるかを知る必要がありません。"

#: ../../chapter5.rst:378
msgid ""
"That’s also the nasty thing about the arrows: There’s no way to stop the "
"loading process once it starts. You may compile a lot more screens than "
"you need to test this one screen."
msgstr ""
"それは ``-->`` について厄介な事でもあります。いったんロードを開始すると一連のロードプロセスを止める方法はありません。 "
"あなたは1つのスクリーンをテストするのに、必要な数よりもはるかに多くのスクリーンをコンパイルすることになります。"

#: ../../chapter5.rst:382
msgid ""
"To get analytical about it, there are three things you might want to do "
"after making the change just described:"
msgstr "それについて分析するために、今述べた変更を加えた後に、あなたがしたいと思う事は3つでしょうか。"

#: ../../chapter5.rst:385
msgid "load the one screen only, to test the change,"
msgstr "変更をテストするために1つのスクリーンのみをロードしたい。"

#: ../../chapter5.rst:387
msgid "load the entire section in which the screen appears,"
msgstr "スクリーンがある節全体を読み込たい。"

#: ../../chapter5.rst:389 ../../chapter5.rst:1303 ../../chapter5.rst:1704
#: ../../chapter5.rst:2038
msgid "or"
msgstr "または"

#: ../../chapter5.rst:391
msgid "load the entire remainder of the application."
msgstr "アプリケーションの残りの部分全体をロードしたい。"

#: ../../chapter5.rst:393
msgid "The use of ``THRU`` seems to give you the greatest control."
msgstr "この操作には ``THRU`` を使うの最適に思えます。"

#: ../../chapter5.rst:396
msgid ""
"Some people consider the arrow to be useful for letting definitions cross"
" screen boundaries. In fact ``-->`` is the only way to compile a high-"
"level (colon) definition that occupies more than one screen, because "
"``-->`` is “immediate.” But it’s *never* good style to let a colon "
"definition cross screen boundaries. (They should never be that long!)"
msgstr ""
"何人かの人々は、定義がスクリーンの境界を越えることを可能にする ``-->`` 役に立つと考えています。 実は ``-->`` "
"は、複数のスクリーンに渡る高水準(コロン)定義をコンパイルする唯一の方法です。なぜなら ``-->`` "
"は「即実行(immediate)」だからです。しかし、コロン定義をスクリーン境界を越えさせるのは決して良いスタイルではありません(定義はそんなに長くなるべきではありません！）。"

#: ../../chapter5.rst:402
msgid ""
"On the other hand, an extremely complicated and time-critical piece of "
"assembler coding might occupy several sequential screens. In this case, "
"though, normal ``LOAD`` ing will do just as well, since the assembler "
"does not use compilation mode, and therefore does not require immediacy."
msgstr ""
"一方、非常に複雑でタイムクリティカルなアセンブラコーディングは、いくつかの連続したスクリーンを占有する可能性があります。 "
"ただしこの場合、アセンブラはコンパイルモードを使用せず、したがって即実行(immediate)は必要ないため、通常の ``LOAD`` "
"処理も同様に実行できます。"

#: ../../chapter5.rst:408
msgid ""
"Finally, the arrow wastes an extra line of each source screen. We don’t "
"recommend it."
msgstr "おまけに、 ``-->`` は、各ソーススクリーンの余分な行を無駄にします。 お勧めしません。"

#: ../../chapter5.rst:412
msgid "An Alternative to Screens: Source in Named Files"
msgstr "スクリーンの代替：名前付きファイル内のソース"

#: ../../chapter5.rst:414
msgid ""
"Some Forth practitioners advocate storing source code in variable-length,"
" named text files, deliberately emulating the approach used by "
"traditional compilers and editors. This approach may become more and more"
" common, but its usefulness is still controversial."
msgstr "幾人かのForthの専門家は、伝統的なコンパイラやエディタが使っているアプローチをわざわざエミュレートして、可変長の名前付きテキストファイルにソースコードを格納することを主張しています。このアプローチはますます一般的になるかもしれませんが、その有用性はまだ物議をかもしています。"

#: ../../chapter5.rst:420
msgid ""
"Sure, it’s nice not to have to worry about running out of room in a "
"screen, but the hassle of writing in a restricted area is compensated for"
" by retaining control of discrete chunks of code. In developing an "
"application, you spend a lot more time loading and reloading screens than"
" you do rearranging their contents."
msgstr ""
"確かに、スクリーンのスペースを使い果たすことを心配しなくてもいいのですが、制限された領域に書くわずわらしさは、コードの塊に細心の注意を払って御し続けることで補われます。"
" アプリケーションの開発では、スクリーンの内容を並べ替えるよりもはるかに多くの時間をかけてスクリーンのロードと再ロードを行います。"

#: ../../chapter5.rst:426
msgid ""
"“Infinite-length” files allow sloppy, disorganized thinking and bad "
"factoring. Definitions become longer without the discipline imposed by "
"the 1K block boundaries. The tendency becomes to write a 20K file, or "
"worse: a 20K definition."
msgstr ""
"「長さ制限のない」ファイルは、ずさんな、無秩序な思考と悪い因数分解を可能にします。 "
"1Kブロック境界によって課される規律がないと、定義は長くなります。 "
"20Kのファイルを書く、あるいはもっと悪いことに、20Kの定義を書くようになります。"

#: ../../chapter5.rst:431
msgid ""
"Perhaps a nice compromise would be a file-based system that allows nested"
" loading, and encourages the use of very small named files. Most likely, "
"though, the more experienced Forth programmers would not use named files "
"longer than 5K to 10K. So what’s the benefit?"
msgstr ""
"おそらく、妥協の余地があるのは、ネストされたロードを可能にし、非常に小さな名前付きファイルの使用を推奨するファイルベースのシステムでしょう。 "
"もっとも、たぶん、経験豊富なForthプログラマは5Kから10Kより長い名前付きファイルを使用しないでしょう。 では、そのメリットは何でしょうか？"

#: ../../chapter5.rst:437
msgid ""
"Some might answer that rhetorical question: “It’s easier to remember "
"names than numbers.” If that’s so, then predefine those block numbers as "
"constants, e.g.:"
msgstr "そのような修辞的な質問に答える人もいるかもしれません。「数字よりも名前を覚える方が簡単だ」そうであれば、それらのブロック番号を定数として事前定義してください。"

#: ../../chapter5.rst:445
msgid "Then to load the “framing” section, enter"
msgstr "以降、``FRAMING`` 節をロードするには、以下のようにします。"

#: ../../chapter5.rst:451
msgid "Or, to list the section’s load block, enter"
msgstr "また、その節のロードブロックをリストするなら、以下のようにします。"

#: ../../chapter5.rst:457
msgid "(It’s a convention that names of sections end in “ING.”)"
msgstr "(節名は「ING」で終わるのが慣例です)"

#: ../../chapter5.rst:459
msgid ""
"Of course, to minimize the hassle of the screen-based approach you need "
"good tools, including editor commands that move lines of source from one "
"screen to another, and words that slide a series of screens forward or "
"back within the listing."
msgstr "もちろん、スクリーンベースのアプローチの煩わしさを最小限に抑えるためには、あるスクリーンから別のスクリーンにソースの行を移動するエディタコマンドや、一連のスクリーンをリスト内で前後にスライドさせるワードなど、優れたツールが必要です。"

#: ../../chapter5.rst:465
msgid "Disk Partitioning"
msgstr "ディスク割り当て"

#: ../../chapter5.rst:467
msgid ""
"The final aspect of the well-organized listing involves standardizing an "
"arrangement for what goes where on the disk. These standards must be set "
"by each shop, or department, or individual programmer, depending on the "
"nature of the work."
msgstr "よく組織化されたリストの最後の側面は、ディスクの何処に何を配置するかの標準化です。会社ごと・部門ごと・個々のプログラマーごと・作品の性質ごとに標準を設定する必要があります。"

#: ../../chapter5.rst:473
msgid "Example of a disk-partitioning scheme within one department."
msgstr "ある部門のディスク割当体系サンプル"

#: ../../chapter5.rst:477
msgid "Screen 0"
msgstr "Screen 0"

#: ../../chapter5.rst:478
msgid ""
"is the title screen, showing the name of the application, the current "
"release number, and primary author."
msgstr "アプリケーションの名前、現在のリリース番号、および一次著者を示すタイトル・スクリーンです。"

#: ../../chapter5.rst:480
msgid "Screen 1"
msgstr "Screen 1"

#: ../../chapter5.rst:481
msgid "is the application-load block."
msgstr "アプリケーション・ロード・ブロック"

#: ../../chapter5.rst:482
msgid "Screen 2"
msgstr "Screen 2"

#: ../../chapter5.rst:483
msgid "is reserved for possible continuation from Screen 1"
msgstr "スクリーン1に収まらず継続が必要な時の為に予約されています。"

#: ../../chapter5.rst:484
msgid "Screen 4 and 5"
msgstr "Screen 4 and 5"

#: ../../chapter5.rst:485
msgid "contain system messages."
msgstr "システムメッセージが含まれています。"

#: ../../chapter5.rst:486
msgid "Screens 9 thru 29"
msgstr "Screens 9 thru 29"

#: ../../chapter5.rst:487
msgid ""
"incorporate general utilities needed in, but not restricted to, this "
"application."
msgstr "ここに、このアプリケーションに必要な、ただしこれに限定されない一般的なユーティリティを組み込みます。"

#: ../../chapter5.rst:489
msgid "Screen 30"
msgstr "Screen 30"

#: ../../chapter5.rst:490
msgid "begins the application screens."
msgstr "ここからアプリケーション・スクリーン開始です。"

#: ../../chapter5.rst:492
msgid ":numref:`fig5-4`  shows a typical department’s partitioning scheme."
msgstr ":numref:`fig5-4` は典型的な部門での割り当て方です。"

#: ../../chapter5.rst:494
msgid ""
"In many Forth shops it’s considered desirable to begin sections of code "
"on screen numbers that are evenly divisible by three. Major divisions on "
"a disk should be made on boundaries evenly divisible by thirty."
msgstr ""
"多くのForthの会社では、3で割り切れるスクリーン番号でコード節を始めることが望ましいと考えられています。 "
"ディスク上の主要な分割は、30スクリーン毎に行われるべきです。"

#: ../../chapter5.rst:499
msgid ""
"The reason? By convention, Forth screens are printed three to a page, "
"with the top screen always evenly divisible by three. Such a page is "
"called a “triad;” most Forth systems include the word ``TRIAD`` to "
"produce it, given as an argument the number of any of the three screens "
"in the triad. For instance, if you type"
msgstr ""
"なぜか？ 慣例により、Forthのスクリーンは1ページに3つ出力され、出力時のトップスクリーンは常に3で均等に割り切れます。 "
"そのようなページは「トライアド(triad)」と呼ばれます。ほとんどのForthシステムはトライアドの3つのスクリーンのうちのどれかの番号を引数として与えられてそれを生成するためのワード"
" ``TRIAD`` を含んでいます。 例えば以下のようにタイプすると、"

#: ../../chapter5.rst:509
msgid "you’ll get a page that includes 75, 76, and 77."
msgstr "あなたは75,76,77を含むページを得ます。"

#: ../../chapter5.rst:511
msgid ""
"The main benefit of this convention is that if you change a single "
"screen, you can slip the new triad right into your binder containing the "
"current listing, replacing exactly one page with no overlapping screens."
msgstr "この慣例の主な利点は、単一のスクリーンを変更した場合、現在表示されているリストを含むバインダーに新しいトライアドを入れて、重複するスクリーンがない1ページだけを置き換えられることです。"

#: ../../chapter5.rst:515
msgid ""
"Similarly, the word ``INDEX`` lists the first line of each screen, 60 per"
" page, on boundaries evenly divisible by 60."
msgstr "同様に、ワード ``INDEX`` は各スクリーンの最初の行を1ページに60ずつ、60で割り切れる境界毎に出力します。"

#: ../../chapter5.rst:520
msgid ""
"Begin sections or lexicons on screen numbers evenly divisible by three. "
"Begin applications or chapters on screen numbers evenly divisible by "
"thirty."
msgstr "節または用語集のスクリーン番号を常に3で割り切れる数で初めます。アプリケーションや章のスクリーン番号を常に30で割り切れる数で初めます。"

#: ../../chapter5.rst:525
msgid "Electives"
msgstr "選択"

#: ../../chapter5.rst:527
msgid ""
"Vendors of Forth systems have a problem. If they want to include every "
"command that the customer might expect—words to control graphics, "
"printers, and other niceties—they often find that the system has swollen "
"to more than half the memory capacity of the computer, leaving less room "
"for serious programmers to compile their applications. The solution is "
"for the vendor to provide the bare bones as a precompiled nucleus, with "
"the extra goodies provided in *source* form. This approach allows the "
"programmer to pick and choose the special routines actually needed."
msgstr "Forthシステムのベンダーは問題を抱えています。顧客が期待するすべてのコマンド（グラフィック、プリンタ、その他の機能を制御するためのワード）を含めたい場合は、システムがコンピュータのメモリ容量の半分以上に膨れ上がっていることがよくあります。それはプログラマがアプリケーションをコンパイルする余地を少なくします。解決策は、ベンダーが、「ソース形式」で提供される追加の機能とともに、その他の機能をプリコンパイル済バイナリを提供することです。このアプローチにより、プログラマは実際に必要なルーチンを選ぶことができます。"

#: ../../chapter5.rst:537
msgid ""
"These user-loadable routines are called “electives.” Double-length "
"arithmetic, date and time support, ``CASE`` statements and the "
"``DOER/MAKE`` construct (described later) are some of the features that "
"Forth systems should offer as electives."
msgstr ""
"これらのユーザロード可能なルーチンは 「選択機能(electives)」と呼ばれます。倍長演算、日付と時刻のサポート、 ``CASE`` 文、 "
"``DOER/MAKE`` 組（後述）は、Forthシステムが選択機能として提供する機能の一部です。"

#: ../../chapter5.rst:543
msgid "Screen Layout"
msgstr "スクリーンレイアウト"

#: ../../chapter5.rst:545
msgid "In this section we’ll discuss the layout of each source screen."
msgstr "この節では、各ソース・スクリーンのレイアウトについて説明します。"

#: ../../chapter5.rst:549
msgid "Reserve Line 0 as a \"comment line.\""
msgstr "行0は「コメント行」として確保して下さい。"

#: ../../chapter5.rst:551
msgid ""
"The comment line serves both as a heading for the screen, and also as a "
"line in the disk ``INDEX``. It should describe the purpose of the screen "
"(not list the words defined therein)."
msgstr ""
"コメント行は、スクリーンの見出しとしても、ディスクを``INDEX`` した時の行としても役立ちます。 "
"それはスクリーンの目的を説明するべきです（そこに定義されたワードをリストしないでください）。"

#: ../../chapter5.rst:555
msgid ""
"The comment line minimally contains the name of the screen. In larger "
"applications, you may also include both the chapter name and screen name."
" If the screen is one of a series of screens implementing a lexicon, you "
"should include a “page number” as well."
msgstr ""
"コメント行には、少なくともスクリーン名が含まれています。 大規模なアプリケーションでは、章名とスクリーン名の両方を含めることもできます。 "
"スクリーンが用語集を実装する一連のスクリーンの1つである場合は、「ページ番号」も含める必要があります。"

#: ../../chapter5.rst:560
msgid ""
"The upper right hand corner is reserved for the “stamp.” The stamp "
"includes the date of latest revision and, when authorship is important, "
"the programmer’s initials (three characters to the left of the date); "
"e.g.:"
msgstr "スクリーンの右上隅は「タイムスタンプ」のために予約します。タイムスタンプには最新の改訂日が含まれ、作成者が重要な場合はプログラマのイニシャル（日付の左に3文字）を含めます。例えば、"

#: ../../chapter5.rst:569
msgid "Some Forth editors will enter the stamp for you at the press of a key."
msgstr "Forthエディタの中には、あるキーを押すだけでタイムスタンプを入力できるものもあります。"

#: ../../chapter5.rst:571
msgid "A common form for representing dates is"
msgstr "日付を表すための一般的な形式は、"

#: ../../chapter5.rst:577
msgid "that is, February 6, 1984 would be expressed"
msgstr "1984年2月6日なら、"

#: ../../chapter5.rst:583
msgid "An increasingly popular alternative uses"
msgstr "最近よく使われるようになった形式は、"

#: ../../chapter5.rst:589
msgid "where “Mmm” is a three-letter abbreviation of the month. For instance:"
msgstr "「Mmm」は(英語で)月を表す名前の3文字の略語です。"

#: ../../chapter5.rst:595
msgid "This form requires fewer characters than"
msgstr "上記の形式は下記より少ない文字数で書けます。"

#: ../../chapter5.rst:601
msgid "and eliminates possible confusion between dates and months."
msgstr "そして、どっちが日でどっちが月か混乱する可能性を排除します。"

#: ../../chapter5.rst:603
msgid ""
"If your system has ``\\`` (“skip-line”—see :doc:`Appendix C<appendixc>`),"
" you can write the comment line like this:"
msgstr ""
"システムに ``\\`` (スキップ・ライン(skip-line) :doc:`付録C<appendixc>` "
"参照))がある場合は、次のようにコメント行を書くことができます。"

#: ../../chapter5.rst:610
msgid ""
"As with all comments, use lower-case or a mixture of lower- and upper-"
"case text in the comment line."
msgstr "すべてのコメントと同様に、コメント行には小文字または大文字と小文字の混在を使用してください。"

#: ../../chapter5.rst:613
msgid ""
"One way to make the index of an application reveal more about the "
"organization of the screens is to indent the comment line by three spaces"
" in screens that continue a lexicon.  :numref:`fig5-5` shows a portion of"
" a list produced by ``INDEX`` in which the comment lines for the "
"continuing screens are indented."
msgstr ""
"アプリケーションの索引でスクリーンの組織化に関する詳細を明確にする1つの方法は、用語集の継続するスクリーン内のコメント行を3つのスペースでインデントすることです。"
" :numref:`fig5-5` は ``INDEX`` "
"によって生成されたリストの一部を示しており、そこでは継続しているスクリーンのコメント行がインデントされています。"

#: ../../chapter5.rst:622
msgid "The output of ``INDEX`` showing indented comment lines."
msgstr "インデントされたコメント行を示す ``INDEX`` の出力。"

#: ../../chapter5.rst:643
msgid ""
"Begin all definitions at the left edge of the screen, and define only one"
" word per line."
msgstr "すべての定義を画面の左端から始めて、1行に1ワードだけ定義してください。"

#: ../../chapter5.rst:646
msgid "*Bad:*"
msgstr "悪い例"

#: ../../chapter5.rst:652 ../../chapter5.rst:792 ../../chapter5.rst:805
#: ../../chapter5.rst:818 ../../chapter5.rst:1399
msgid "*Good:*"
msgstr "良い例"

#: ../../chapter5.rst:659
msgid ""
"This rule makes it easier to find a definition in the listing. (When "
"definitions continue for more than one line, the subsequent lines should "
"always be indented.) ``VARIABLE`` s and ``CONSTANT`` s should also be "
"defined one per line. (See “Samples of Good Commenting Style” in "
":doc:`Appendix E<appendixe>`) This leaves room for an explanatory comment"
" on the same line. The exception is a large “family” of words (defined by"
" a common defining-word) which do not need unique comments:"
msgstr ""
"このルールにより、リスト内で定義を見つけやすくなります(定義が複数の行にわたって続く場合は、後続の行は常に字下げされるべきです)。 "
"``VARIABLE`` と ``CONSTANT`` も1行に1つ定義されるべきです( :doc:`付録E<appendixe>` の "
"「良いコメントスタイルのサンプル」 を参照)。 これは同じ行に説明コメントを書く余地を残します。 "
"例外は、ユニークなコメントを必要としない、大規模な「ファミリー」のワード（共通の定義ワードによって定義される）です。"

#: ../../chapter5.rst:675
msgid "Leave lots of room at the bottom of the screen for later additions."
msgstr "後で追加できるように、スクリーンの下部に十分なスペースを確保してください。"

#: ../../chapter5.rst:677
msgid ""
"On your first pass, fill each screen no more than half with code. The "
"iterative approach demands that you sketch out the components of your "
"application first, then iteratively flesh them out until all the "
"requirements are satisfied. Usually this means adding new commands, or "
"adding special-case handling, to existing screens. (Not *always,* though."
" A new iteration may see a simplification of the code. Or a new "
"complexity may really belong in another component and should be factored "
"out, into another screen.)"
msgstr ""
"最初の試行で、各スクリーンを半分以下のコードで埋めます。 "
"反復的なアプローチでは、最初にアプリケーションのコンポーネントをスケッチしてから、すべての要件が満たされるまでそれらを反復的に作成する必要があります。"
" "
"通常これは、既存のスクリーンに新しいコマンドを追加すること、または特殊なケースの処理を追加することを意味します(常にではありませんが、新しい反復でコードが単純化されることもあります。または、新しい複雑さが別のコンポーネントに属しているため、別のスクリーンにまとめて表示する必要があったりします)。"

#: ../../chapter5.rst:686
msgid ""
"Leaving plenty of room at the outset makes later additions more pleasant."
" One writer recommends that on the initial pass, the screen should "
"contain about 20–40 percent code and 80–60 percent whitespace "
"[stevenson81]_ ."
msgstr ""
"最初に十分なスペースを残すことで、後で追加することがより快適になります。 "
"ある作家は、最初のパスで、画面には20から40パーセントのコードと80から60パーセントの空白を含めることを推奨します。 "
"[stevenson81]_"

#: ../../chapter5.rst:691
msgid ""
"Don’t skip a line between each definition. You may, however, skip a line "
"between *groups* of definitions."
msgstr "各定義の間にある行をスキップしないでください。 ただし、定義の「グループ間」の行をスキップすることはできます。"

#: ../../chapter5.rst:696
msgid "All screens must leave ``BASE`` set to ``DECIMAL``."
msgstr "すべてのスクリーンは ``BASE`` を ``DECIMAL`` に設定したままにしてください。"

#: ../../chapter5.rst:698
msgid ""
"Even if you have three screens in a row in which the code is written in "
"``HEX`` (three screens of assembler code, for instance), each screen must"
" set ``BASE`` to ``HEX`` at the top, and restore base to ``DECIMAL`` at "
"the bottom. This rule ensures that each screen could be loaded "
"separately, for purposes of testing, without mucking up the state of "
"affairs. Also, in reading the listing you know that values are in decimal"
" unless the screen explicitly says ``HEX``."
msgstr ""
"コードが ``HEX`` で書かれている3つのスクリーンが並んでいる場合でも(例えば3つのスクリーンのアセンブラコード)、それぞれのスクリーンは "
"``BASE`` を ``HEX`` に設定しなければなりません。 そして底を一番下で ``DECIMAL`` に戻します。 "
"このルールにより、テストの目的で、問題の状況を気にすることなく、各スクリーンを個別にロードできます。 また、リストを読むと、スクリーンに明示的に "
"``HEX`` と表示されていない限り、値は10進数であることがわかります。"

#: ../../chapter5.rst:707
msgid ""
"Some shops take this rule even further. Rather than brashly resetting "
"base to ``DECIMAL`` at the end, they reset base to *whatever it was at "
"the beginning.* This extra bit of insurance can be accomplished in this "
"fashion:"
msgstr ""
"いくつかの会社はさらに以下のルールを設定しています。 最後に基数を ``DECIMAL`` "
"にリセットするのではなく、何でも最初の基数にリセットします。この追加の保証は、次のようにして実現できます。"

#: ../../chapter5.rst:720
msgid ""
"Sometimes an argument is passed on the stack from screen to screen, such "
"as the value returned by ``BEGIN`` or ``IF`` in a multiscreen assembler "
"definition, or the base address passed from one defining word to "
"another—see “Compile-Time Factoring” in :doc:`Chapter Six<chapter6>`. In "
"these cases, it’s best to save the value of ``BASE`` on the return stack "
"like this:"
msgstr ""
"マルチスクリーンアセンブラの定義で ``BEGIN`` や ``IF`` "
"によって返される値、ある定義語から別の定義語に渡されるベースアドレスなど、引数がスクリーンからスクリーンに渡されることがあります( "
":doc:`第6章<chapter6>` の「コンパイル時の因数分解」を参照)。 このような場合、以下のようにリターンスタックに ``BASE``"
" の値を保存するのが最善です。"

#: ../../chapter5.rst:733
msgid ""
"Some folks make it a policy to use this approach on any screen that "
"changes ``BASE``, so they don’t have to worry about it."
msgstr ""
"何人かの人々は ``BASE`` "
"を変えるどんなスクリーンでもこのアプローチを使うことを方針にしている、そうすることで彼らはそれについて心配する必要が無くなります。"

#: ../../chapter5.rst:736
msgid ""
"Moore prefers to define ``LOAD`` to invoke ``DECIMAL`` after loading. "
"This approach simplifies the screen’s contents because you don’t have to "
"worry about resetting."
msgstr ""
"ムーアはロード後に ``DECIMAL`` を呼び出ように ``LOAD`` を定義することを好みます。 "
"リセットすることを心配する必要がないため、この方法だとスクリーンの内容が簡単になります。"

#: ../../chapter5.rst:741
msgid "Spacing and Indentation"
msgstr "空白とインデント"

#: ../../chapter5.rst:745
msgid "Spacing and indentation are essential for readability."
msgstr "空白とインデントは読みやすさの必需品です。"

#: ../../chapter5.rst:747
msgid ""
"The examples in this book use widely accepted conventions of spacing and "
"indenting style. Whitespace, appropriately used, lends readability. "
"There’s no penalty for leaving space in source screens except disk "
"memory, which is cheap."
msgstr ""
"本書の例では、広く受け入れられているスペースと字下げスタイルの規則を使用しています。 適切に使用される空白は読みやすさを向上させます。 "
"安価なディスクメモリを除いて、ソース・スクリーンにスペースを空けることによるペナルティはありません。"

#: ../../chapter5.rst:752
msgid ""
"For those who like their conventions in black and white, Table "
":numref:`tab-5-1` is a list of guidelines. (But remember, Forth’s "
"interpreter couldn’t care less about spacing or indentation.)"
msgstr ""
"白黒はっきりした規約を好む人のために、表 :numref:`tab-5-1` "
"はガイドラインの一覧です（ただし、Forthのインタプリタはスペースやインデントにあまり気を遣いません）。"

#: ../../chapter5.rst:756
msgid "Indentation and spacing guidelines"
msgstr "字下げと空白のガイドライン"

#: ../../chapter5.rst:759
msgid "1 space between the colon and the name"
msgstr "空白1つだけ空けるのはコロンと名前の間。"

#: ../../chapter5.rst:760
msgid "2 spaces between the name and the comment [#f1]_"
msgstr "空白2つだけ空けるのは名前とコメントの間。 [#f1]_"

#: ../../chapter5.rst:761
msgid "2 spaces, or a carriage return, after the comment and"
msgstr "2つの空白空か改行入れるのは、 コメントの後と、"

#: ../../chapter5.rst:762
msgid "before the definition [#f1]_"
msgstr "定義の前。 [#f1]_"

#: ../../chapter5.rst:763
msgid "3 spaces between the name and definition if no comment is used"
msgstr "3つの空白空けるのは、コメントが無い時の名前とその定義の間。"

#: ../../chapter5.rst:764
msgid ""
"3 spaces indentation on each subsequent line (or multiples of 3 for "
"nested indentation)"
msgstr "3つの空白で字下げするのは後続の各行(入れ子になった場合は更に3の倍数)。"

#: ../../chapter5.rst:766
msgid "1 space between words/numbers within a phrase"
msgstr "1つの空白空けるのは、句の中の、ワードや数字の間。"

#: ../../chapter5.rst:767
msgid "2 or 3 spaces between phrases"
msgstr "2か3の空白空けるのは句と句の間。"

#: ../../chapter5.rst:768
msgid "1 space between the last word and the semicolon"
msgstr "1つの空白空けるのは最後のワードとセミコロンの間。"

#: ../../chapter5.rst:769
msgid "1 space between semicolon and ``IMMEDIATE`` (if invoked)"
msgstr "1つの空白空けるのは、(必要な場合、)セミコロンと ``IMMEDIATE`` の間。"

#: ../../chapter5.rst:771
msgid ""
"No blank lines between definitions, except to separate distinct groups of"
" definitions"
msgstr "グループの異なる定義を区切る場合を除き、定義の間に空白行は挟みません。"

#: ../../chapter5.rst:774
msgid "The last position of each line should be blank except for:"
msgstr "各行の最後は、以下を除いて空白にする必要があります。"

#: ../../chapter5.rst:776
msgid "quoted strings that continue onto the next line, or"
msgstr "次の行に続く引用符付き文字列、または、"

#: ../../chapter5.rst:778
msgid "the end of a comment."
msgstr "コメントの終了。"

#: ../../chapter5.rst:780
msgid ""
"A comment that begins with ``\\`` may continue right to the end of the "
"line. Also, a comment that begins with ``(`` may have its delimiting "
"right parenthesis in the last column."
msgstr ""
"``\\``で始まるコメントは、行末まで続きます。 また、 ``(`` で始まるコメントは、最後の桁で右丸括弧 ``)`` "
"で区切ることができます(訳注： ``(`` はワードだが、右括弧 ``)`` は単なる区切り文字)。"

#: ../../chapter5.rst:784
msgid "Here are some common errors of spacing and indentation:"
msgstr "以下は空白と字下げに関するよくある間違いです。"

#: ../../chapter5.rst:786
msgid "*Bad* (name not separated from the body of the definition):"
msgstr "良くない例(名前がその定義本体と分けられていない)"

#: ../../chapter5.rst:798
msgid "*Bad* (subsequent lines not indented three spaces):"
msgstr "良くない例(継続行が3つの空白で字下げされていない)"

#: ../../chapter5.rst:812
msgid "*Bad* (lack of phrasing):"
msgstr "良くない例(句と句の間が分けられていない)"

#: ../../chapter5.rst:824
msgid ""
"Phrasing is a subjective art; I’ve yet to see a useful set of formal "
"rules. Simply strive for readability."
msgstr ""
"句と句の区切り(phrasing)は主観的な芸術です。 私はまだ役に立つ正式な規則のセットをみつけられていません。 "
"あなたが読みやすくなるよう努力してください。"

#: ../../chapter5.rst:828
msgid ""
"An often-seen alternative calls for 1 space between the name and comment "
"and 3 between the comment and the definition. A more liberal technique "
"uses 3 spaces before and after the comment. Whatever you choose, be "
"consistent."
msgstr ""
"よく見られる代替手段では、名前とコメントの間に1スペース、コメントと定義の間に3スペースが必要です。 "
"より自由な手法では、コメントの前後に3つのスペースを使用します。 あなたは何を選んでも構いませんが、一貫性を保ってください。"

#: ../../chapter5.rst:834
msgid "Comment Conventions"
msgstr "コメント規則"

# narrative
# 物語、物語文学、説話、話術、語り口、(本の会話の部分に対して)語りの部分
#: ../../chapter5.rst:836
msgid ""
"Appropriate commenting is essential. There are five types of comments: "
"stack-effect comments, data-structure comments, input-stream comments, "
"purpose comments and narrative comments."
msgstr ""
"適切なコメントは不可欠です。 "
"コメントは５種類あり、それは、スタック効果コメント、データ構造コメント、入力ストリームコメント、目的コメント、物語コメントです。"

#: ../../chapter5.rst:843
msgid "*A* stack-effect comment"
msgstr "スタック効果コメント"

#: ../../chapter5.rst:841
msgid ""
"shows the arguments that the definition consumes from the stack, and the "
"arguments it returns to the stack, if any."
msgstr "定義がスタックから消費する引数と、もしあれば、それがスタックに返す引数を表します。"

#: ../../chapter5.rst:849
msgid "*A* data-structure comment"
msgstr "データ構造コメント"

#: ../../chapter5.rst:846
msgid ""
"indicates the position and meaning of elements in a data structure. For "
"instance, a text buffer might contain a count in the first byte, and 63 "
"free bytes for text."
msgstr ""
"データ構造内の要素の位置と意味を示します。 "
"たとえば、テキストバッファの最初のバイトにはカウントが含まれ、テキストには63の空きバイトが含まれる可能性があります。"

#: ../../chapter5.rst:855
msgid "*An* input-stream comment"
msgstr "入力ストリームコメント"

#: ../../chapter5.rst:852
msgid ""
"indicates what strings the word expects to see in the input stream. For "
"example, the Forth word ``FORGET`` scans for the name of a dictionary "
"entry in the input stream."
msgstr ""
"入力ストリームでワードがどの文字列を見ることを期待しているかを示します。 たとえば、Forthのワード ``FORGET`` "
"は、入力ストリームから区切り文字によって切り出した文字列をワード名とみなして辞書エントリの名前をスキャンします。"

#: ../../chapter5.rst:860
msgid "*A* purpose comment"
msgstr "目的コメント"

#: ../../chapter5.rst:858
msgid ""
"describes, in as few words possible, what the definition does. How the "
"definition works is not the concern of the purpose comment."
msgstr "可能な限り少ない言葉で、定義が何をするのかを説明します。 定義がどのように機能するかは、目的のコメントの範疇ではありません。"

#: ../../chapter5.rst:866
msgid "*A* narrative comment"
msgstr "物語コメント"

#: ../../chapter5.rst:863
msgid ""
"appears amidst a definition to explain what is going on, usually line-by-"
"line. Narrative comments are used only in the “vertical format,” which "
"we’ll describe in a later section."
msgstr "何が行われているのかを説明する定義の中に、通常は1行ずつ表示されます。 物語コメントは、後の節で説明する「垂直書式」でのみ使用されます。"

#: ../../chapter5.rst:868
msgid ""
"Comments are usually typed in lower-case letters to distinguish them from"
" source code. (Most Forth words are spelled with upper-case letters, but "
"lower-case spellings are sometimes used in special cases.)"
msgstr "コメントは通常、ソースコードと区別するために小文字で入力されます(ほとんどのFortワードは大文字でつづられていますが、小文字のスペルは特別な場合に使われることがあります)。"

#: ../../chapter5.rst:872
msgid ""
"In the following sections we’ll summarize the standardized formats for "
"these types of comments and give examples for each type."
msgstr "次の節では、上記の種類のコメントの標準化された形式を要約し、それぞれの種類の例を示します。"

#: ../../chapter5.rst:876
msgid "Stack Notation"
msgstr "スタック表記"

#: ../../chapter5.rst:880
msgid ""
"Every colon or code definition that consumes and/or returns any arguments"
" on the stack must include a stack-effect comment."
msgstr "スタック上の引数を消費したりスタックに返したりする、全てのコロン定義やコード定義は、スタック効果のコメントを含める必要があります。"

#: ../../chapter5.rst:883
msgid ""
"“Stack notation” refers to conventions for representing what’s on the "
"stack. Forms of stack notation include “stack pictures,” “stack effects,”"
" and “stack-effect comments.”"
msgstr ""
"「スタック表記」とは、スタック上の内容を表すための規則を指します。 "
"スタック表記の形式には、「スタック状態」、「スタック効果」、「スタック効果コメント」があります。"

#: ../../chapter5.rst:889
msgid "Stack Picture"
msgstr "スタック状況"

#: ../../chapter5.rst:891
msgid ""
"A stack picture depicts items understood to be on the stack at a given "
"time. Items are listed from left to right, with the leftmost item "
"representing the bottom of the stack and the rightmost item representing "
"the top."
msgstr ""
"スタック状況は、時系列に積み重ねられていると理解されているアイテムを表しています。 "
"項目は左から右に向かってリストされ、一番左の項目がスタックの一番下(bottom)を表し、一番右の項目が一番上(top)を表します。"

#: ../../chapter5.rst:896
msgid "For instance, the stack picture"
msgstr "スタック状況の例です。"

#: ../../chapter5.rst:902
msgid ""
"indicates two numbers on the stack, with n2 on the top (the most "
"accessible position)."
msgstr "スタック上の2つの数字を示し、n2が一番上(top)（最もアクセスしやすい位置）"

#: ../../chapter5.rst:905
msgid ""
"This is the same order that you would use to type these values in; i.e., "
"if n1 is 100 and n2 is 5000, then you would type"
msgstr "これは、これらの値を入力するのに使用するのと同じ順序です。 つまり、n1が100でn2が5000の場合は、以下の通りタイプします。"

#: ../../chapter5.rst:912
msgid "to place these values correctly on the stack."
msgstr "これらの値をスタックに正確に配置します。"

#: ../../chapter5.rst:914
msgid ""
"A stack picture can include either abbreviations, such as “n1,” or fully "
"spelled-out words. Usually abbreviations are used. Some standard "
"abbreviations appear in Table :numref:`tab-5-2`. Whether abbreviations or"
" fully spelled-out words are used, each stack item should be separated by"
" a space."
msgstr ""
"スタックピクチャには、「n1」などの省略形または完全な綴りの単語を含めることができます。 通常は略語が使用されます。 いくつかの標準的な略語が表 "
":numref:`tab-5-2` にあります。 "
"省略形または完全な綴りの単語のどちらを使用する場合でも、各スタック項目はスペースで区切る必要があります。"

#: ../../chapter5.rst:920
msgid ""
"If a stack item is described with a phrase (such as “address-of-latest-"
"link”), the words in the phrase should be joined by hyphens. For example,"
" the stack picture:"
msgstr ""
"スタック項目が句（「address-of-lastest-"
"link」など）で記述されている場合は、フレーズ内の語をハイフンで結合する必要があります。 たとえば、以下のスタック状況のように。"

#: ../../chapter5.rst:928
msgid "shows three elements on the stack."
msgstr "ここでは、スタック上に3つの要素があります。"

#: ../../chapter5.rst:931
msgid "Stack Effect"
msgstr "スタック効果"

#: ../../chapter5.rst:933
msgid ""
"A “stack effect” shows two stack pictures: one picture of any items that "
"may be *consumed* by a definition, and another picture of any items "
"*returned* by the definition. The “before” picture comes first, followed "
"by two hyphens, then the “after” picture."
msgstr ""
"「スタック効果」は2つのスタック状況を示します。定義によって「消費」される可能性のあるアイテムの1つの状況、および定義によって「返される」任意のアイテムの別の状況です。"
" 「前」の状況が最初に来て、その後に2つのハイフンが続き、次に「後」の状況が続きます。"

#: ../../chapter5.rst:938
msgid "For instance, the stack effect for Forth’s addition operator, ``+`` is"
msgstr "例えば、Forthの加算演算子 ``+`` のスタック効果です。"

#: ../../chapter5.rst:944
msgid "where ``+`` consumes two numbers and returns their sum."
msgstr "ここでは ``+`` は2つの数を消費し、それらの合計を返します。"

#: ../../chapter5.rst:946
msgid ""
"Remember that the stack effect describes only the *net result* of the "
"operation on the stack. Other values that happen to reside on the stack "
"beneath the arguments of interest don’t need to be shown. Nor do values "
"that may appear or disappear while the operation is executing."
msgstr ""
"スタック効果は、スタックに対する操作の「最終結果」のみを記述するということを忘れないでください。 "
"たまたま興味のある引数の下のスタックに存在する他の値を表示する必要はありません。 "
"操作の実行中に表示されたり消えたりする可能性のある値を表示する必要もありません。"

#: ../../chapter5.rst:951
msgid ""
"If the word returns any input arguments unchanged, they should be "
"repeated in the output picture; e.g.,"
msgstr "ワードが入力引数を変更せずに返す場合は、出力状況でそれらを繰り返す必要があります。 たとえば、以下のように。"

#: ../../chapter5.rst:958
msgid ""
"Conversely, if the word changes any arguments, the stack comment must use"
" a different descriptor:"
msgstr "逆に、ワードが引数を変更する場合、スタックコメントは異なる記述子を使用しなければなりません。"

# glossaryは訳すかカタカナか 用語集ではlexiconと混乱しないか。
# とりあえず「ワード集」とする。
#: ../../chapter5.rst:966
msgid "A stack effect might appear in a formatted glossary."
msgstr "スタック効果は、フォーマットされたグロッサリー(ワード集)に表示されることがあります。"

#: ../../chapter5.rst:969
msgid "Stack Effect Comment"
msgstr "スタック効果コメント"

#: ../../chapter5.rst:971
msgid ""
"A “stack-effect comment” is a stack effect that appears in source code "
"surrounded by parentheses. Here’s the stack-effect comment for the word "
"COUNT:"
msgstr "「スタック効果コメント」は、括弧で囲まれたソースコードに現れるスタック効果です。 以下がCOUNTというワードに対するスタック効果のコメントです。"

#: ../../chapter5.rst:979
msgid "or:"
msgstr "または"

#: ../../chapter5.rst:985
msgid "(The “count” is on top of the stack after the word has executed.)"
msgstr "（「count」は、そのワードが実行された後のスタックの一番上にあります。）"

#: ../../chapter5.rst:987
msgid ""
"If a definition has no effect on the stack (that is, no effect the user "
"is aware of, despite what gyrations occur within the definition), it "
"needs no stack-effect comment:"
msgstr "定義がスタックに影響を与えない場合（つまり、定義内で、スタック上に既にある引数を一切使用せず、スタック上に何も返さない場合）、スタック効果コメントは不要です。"

#: ../../chapter5.rst:995
msgid "On the other hand, you may want to use an empty stack comment—i.e.,"
msgstr "しかし、上記のように表記する代わりに、以下のように空のスタックコメントを使用することをおすすめします。"

#: ../../chapter5.rst:1001
msgid "to emphasize that the word has no effect on the stack."
msgstr "こうして、ワードがスタックに影響を及ぼさないことを強調します。"

#: ../../chapter5.rst:1003
msgid ""
"If a definition consumes arguments but returns none, the double-hyphen is"
" optional. For instance,"
msgstr "定義が引数を消費しても何も返さない場合、二連ハイフン「--」はオプションです。 例えば以下。"

#: ../../chapter5.rst:1010
msgid "can be shortened to"
msgstr "以下のように短縮できます。"

#: ../../chapter5.rst:1016
msgid ""
"The assumption behind this convention is this: There are many more colon "
"definitions that consume arguments and return nothing than definitions "
"that consume nothing and return arguments."
msgstr "この規約の背後にある仮定は、引数を消費して何も返さないコロン定義は、何も消費せず引数を返す定義よりも多くあるというものです。"

#: ../../chapter5.rst:1021
msgid "Stack Abbreviation Standards"
msgstr "スタック略語規格"

#: ../../chapter5.rst:1023
msgid ""
"Abbreviations used in stack notation should be consistent. Table "
":numref:`tab-5-2` lists most of the commonly used abbreviations. (This "
"table reappears in :doc:`Appendix E<appendixe>`.) The terms “single-"
"length,” “double-length,” etc. refer to the size of a “cell” in the "
"particular Forth system. (If the system uses a 16-bit cell, “n” "
"represents a 16-bit number; if the system uses a 32-bit cell, “n” "
"represents a 32-bit number.)"
msgstr ""
"スタック表記で使用される略語は一貫しているべきです。 表 :numref:`tab-5-2` "
"は一般的に使われる略語の大部分をリストしています(この表は :doc:`付録E<appendixe>` に再掲)。「1倍長(single-"
"length)」、「2倍長(double-"
"length)」などの用語は、特定のForthシステムにおける「セル(cell)」のサイズを表します（システムが16ビットのセルを使用している場合、「n」は16ビットの数を表し、システムが32ビットのセルを使用している場合、「n」は32ビットの数を表します）。"

#: ../../chapter5.rst:1032
msgid "Notation of Flags"
msgstr "フラグの表記"

#: ../../chapter5.rst:1034
msgid ""
"Table :numref:`tab-5-2` shows three ways to represent a boolean flag. To "
"illustrate, here are three versions of the same stack comment for the "
"word ``-TEXT``:"
msgstr ""
"表 :numref:`tab-5-2` にはブールフラグを表す3つの方法が示されています。ここでは例として、ワード ``-TEXT`` "
"に対する同じスタックコメントの3つのバージョンを示します。"

#: ../../chapter5.rst:1044
msgid "Stack-comment abbreviations."
msgstr "スタックコメントの略語"

#: ../../chapter5.rst:1048
msgid "n"
msgstr "n"

#: ../../chapter5.rst:1049
msgid "single-length signed number"
msgstr "1倍長 符号付整数"

#: ../../chapter5.rst:1050
msgid "d"
msgstr "d"

#: ../../chapter5.rst:1051
msgid "double-length signed number"
msgstr "2倍長 符号付整数"

#: ../../chapter5.rst:1052
msgid "u"
msgstr "u"

#: ../../chapter5.rst:1053
msgid "single-length unsigned number"
msgstr "1倍長 符号無整数"

#: ../../chapter5.rst:1054
msgid "ud"
msgstr "ud"

#: ../../chapter5.rst:1055
msgid "double-length unsigned number"
msgstr "2倍長 符号無整数"

#: ../../chapter5.rst:1056
msgid "t"
msgstr "t"

#: ../../chapter5.rst:1057
msgid "triple-length"
msgstr "3倍長(triple)"

#: ../../chapter5.rst:1058
msgid "q"
msgstr "q"

#: ../../chapter5.rst:1059
msgid "quadruple-length"
msgstr "4倍長(quadruple)"

#: ../../chapter5.rst:1060 ../../chapter5.rst:1230
msgid "c"
msgstr "c"

#: ../../chapter5.rst:1061
msgid "7-bit character value"
msgstr "7ビット キャラクタ値(訳注：ASCII表示文字の範囲)"

#: ../../chapter5.rst:1062
msgid "b"
msgstr "b"

#: ../../chapter5.rst:1063
msgid "8-bit byte"
msgstr "8ビット バイト値"

#: ../../chapter5.rst:1064
msgid "?"
msgstr "?"

#: ../../chapter5.rst:1065
msgid "boolean flag; or;"
msgstr "ブーリアンフラグ。左記または以下、"

#: ../../chapter5.rst:1066
msgid "t="
msgstr "t="

#: ../../chapter5.rst:1067
msgid "true"
msgstr "true"

#: ../../chapter5.rst:1068
msgid "f="
msgstr "f="

#: ../../chapter5.rst:1069
msgid "false"
msgstr "false"

#: ../../chapter5.rst:1070
msgid "a or adr"
msgstr "a or adr"

#: ../../chapter5.rst:1071
msgid "address"
msgstr "アドレス"

#: ../../chapter5.rst:1072
msgid "acf"
msgstr "acf"

#: ../../chapter5.rst:1073
msgid "address of code field"
msgstr "コードフィールドのアドレス"

#: ../../chapter5.rst:1074
msgid "apf"
msgstr "apf"

#: ../../chapter5.rst:1075
msgid "address of parameter field"
msgstr "パラメータフィールドのアドレス"

#: ../../chapter5.rst:1076
msgid "\\'"
msgstr "\\'"

#: ../../chapter5.rst:1077
msgid "(as prefix) address of"
msgstr "((英語では)プレフィックスとして) …のアドレス"

#: ../../chapter5.rst:1078
msgid "s d"
msgstr "s d"

#: ../../chapter5.rst:1079
msgid "(as a pair) source destination"
msgstr "(ペアで使って）元(source)、先(destination)"

#: ../../chapter5.rst:1080
msgid "lo hi"
msgstr "lo hi"

#: ../../chapter5.rst:1081
msgid "lower-limit upper-limit (inclusive)"
msgstr "下限(lower-limit)、上限(upper-limit) (内包)"

#: ../../chapter5.rst:1082
msgid "#"
msgstr "#"

#: ../../chapter5.rst:1083
msgid "count"
msgstr "カウント。"

#: ../../chapter5.rst:1084
msgid "o"
msgstr "o"

#: ../../chapter5.rst:1085
msgid "offset"
msgstr "オフセット"

#: ../../chapter5.rst:1086
msgid "i"
msgstr "i"

#: ../../chapter5.rst:1087
msgid "index"
msgstr "インデックス"

#: ../../chapter5.rst:1088
msgid "m"
msgstr "m"

#: ../../chapter5.rst:1089
msgid "mask"
msgstr "mask"

#: ../../chapter5.rst:1090
msgid "x"
msgstr "x"

#: ../../chapter5.rst:1091
msgid "don\\'t care (data structure notation)"
msgstr "詳細を気にしない何か(データ構造記法)"

#: ../../chapter5.rst:1093
msgid "An “offset” is a difference expressed in absolute units, such as bytes."
msgstr "「オフセット」とは、バイトなどの絶対単位で表される差です。"

#: ../../chapter5.rst:1094
msgid ""
"An “index” is a difference expressed in logical units, such as elements "
"or records."
msgstr "「インデックス」とは、要素やレコードなどの論理単位で表される違いです。"

# The result-side of the second version would be read “true means no match".
# 意味よくわからんので省略。falseの意味が人口にかいしゃくされてない時代だったのかも。
#: ../../chapter5.rst:1096
msgid ""
"The equal sign after the symbols “t” and “f” equates the flag outcome "
"with its meaning. The result-side of the second version would be read "
"“true means no match.”"
msgstr "記号「t」と「f」の後の等号「=」は、フラグの結果とその意味を表します。"

#: ../../chapter5.rst:1101
msgid "Notation of Variable Possibilities"
msgstr "ありうる様々な結果の記法"

#: ../../chapter5.rst:1103
msgid ""
"Some definitions yield a different stack effect under different "
"circumstances."
msgstr "定義によっては、状態によってスタック効果が異なります。"

#: ../../chapter5.rst:1105
msgid ""
"If the number of items on the stack remains the same under all "
"conditions, but the items themselves change, you can use the vertical bar"
" ( ``|`` ) to mean “or.” The following stack-effect comment describes a "
"word that returns either the address of a file or, if the requested file "
"is not found, zero:"
msgstr ""
"スタック上の項目の数がすべての条件で同じままで、項目自体が変わる場合は、縦棒「|」を使って「または」を表すことができます。 "
"以下は、ファイルのアドレス、または要求されたファイルが見つからない場合はゼロを返します。"

#: ../../chapter5.rst:1114
msgid ""
"If the number of items in a stack picture can vary—in either the “before”"
" or “after” picture—you must write out both versions of the entire stack "
"picture, along with the double-hyphen, separated by the “or” symbol. For "
"instance:"
msgstr "「前」または「後」のでスタック状況の項目数が異なる場合は、スタック状況全体の両方のバージョンを二連ハイフン「--」とともに「または」の記号で区切って書き出す必要があります。"

#: ../../chapter5.rst:1123
msgid ""
"This comment indicates that if the word is found, three arguments are "
"returned (with the flag on top); otherwise only a false flag is returned."
msgstr ""
"このコメントは、ワードが見つかった場合、3つの引数が返されることを示します（trueフラグがスタック・トップにあります）。 "
"それ以外の場合はfalseフラグのみが返されます。"

#: ../../chapter5.rst:1127
msgid ""
"Note the importance of the second “--”. Its omission would indicate that "
"the definition always returned three arguments, the top one being a flag."
msgstr ""
"2番目の「--」の重要性に注意してください。 "
"その省略は、定義が常に3つの引数を返すことを示します。スタックトップはフラグです(訳注：2番めの「--」を省略すると「-- apf len "
"t=found | f=not-found」となり、これは「-- apf len t=found | -- apf len f=not-"
"found」 という意味になってしまう)。"

#: ../../chapter5.rst:1131
msgid ""
"If you prefer, you can write the entire stack effect twice, either on the"
" same line, separated by three spaces:"
msgstr "必要に応じて、スタック効果全体を3行のスペースで区切って同じ行に2回書き込むことができます。"

#: ../../chapter5.rst:1139
msgid "or listed vertically:"
msgstr "または垂直書式だと、"

#: ../../chapter5.rst:1147
msgid "Data-Structure Comments"
msgstr "データ構造コメント"

#: ../../chapter5.rst:1149
msgid ""
"A “data-structure comment” depicts the elements in a data structure. For "
"example, here’s the definition of an insert buffer called ``|INSERT`` :"
msgstr ""

#: ../../chapter5.rst:1156
msgid ""
"The “faces” (curly-brackets) begin and end the structure comment; the "
"bars separate the various elements in the structure; the numbers "
"represent bytes per element. In the comment above, the first byte "
"contains the count, and the remaining 63 bytes contain the text."
msgstr ""

#: ../../chapter5.rst:1161
msgid ""
"A “bit comment” uses the same format as a data-structure comment to "
"depict the meaning of bits in a byte or cell. For instance, the bit "
"comment"
msgstr ""

#: ../../chapter5.rst:1170
msgid ""
"describes the format of a 16-bit status register of a communications "
"channel. The first two bits are flags, the second two bits are unused, "
"and the final pair of six-bit fields indicate the input and output "
"devices which this channel is connected to."
msgstr ""

#: ../../chapter5.rst:1176
msgid ""
"If more than one data structure employs the same pattern of elements, "
"write out the comment only once (possibly in the preamble), and give a "
"name to the pattern for reference in subsequent screens. For instance, if"
" the preamble gives the above bit-pattern the name “status,” then "
"“status” can be used in stack comments to indicate values with that "
"pattern:"
msgstr ""

#: ../../chapter5.rst:1187
msgid ""
"If a ``2VARIABLE`` contains one double-length value, the comment should "
"be a stack picture that indicates the contents:"
msgstr ""

#: ../../chapter5.rst:1194
msgid ""
"If a ``2VARIABLE`` contains two single-length data elements, it’s given a"
" stack picture showing what would be on the stack after a ``2@``. Thus:"
msgstr ""

#: ../../chapter5.rst:1202
msgid ""
"This is different from the comment that would be used if ``MEASUREMENTS``"
" were defined by ``CREATE``."
msgstr ""

#: ../../chapter5.rst:1209
msgid ""
"(While both statements produce the same result in the dictionary, the use"
" of ``2VARIABLE`` implies that the values will normally be “2-fetched” "
"and “2-stored” together-thus we use a *stack* comment. The high-order "
"part, appearing on top of the stack, is listed to the right. The use of "
"``CREATE`` implies that the values will normally be fetched and stored "
"separately–thus we use a data structure comment. The item in the 0th "
"position is listed to the left.)"
msgstr ""

#: ../../chapter5.rst:1219
msgid "Input-stream Comments"
msgstr ""

#: ../../chapter5.rst:1221
msgid ""
"The input-stream comment indicates what words and/or strings are presumed"
" to be in the input stream. Table :numref:`tab-5-3` lists the "
"designations used for input stream arguments."
msgstr ""

#: ../../chapter5.rst:1225
msgid "Input-stream comment designations."
msgstr ""

#: ../../chapter5.rst:1230
msgid "single character, blank-delimited"
msgstr ""

#: ../../chapter5.rst:1231
msgid "name"
msgstr ""

#: ../../chapter5.rst:1231
msgid "sequence of characters, blank delimited"
msgstr ""

#: ../../chapter5.rst:1232
msgid "text"
msgstr ""

#: ../../chapter5.rst:1232
msgid "sequence of characters, delimited by non-blank"
msgstr ""

#: ../../chapter5.rst:1235
msgid "Follow \"text\" with the actual delimiter required; e.g.: \"text\" or text"
msgstr ""

#: ../../chapter5.rst:1237
msgid ""
"The input-stream comment appears *before* the stack comment, and is *not*"
" encapsulated between its own pair of parentheses, but simply surrounded "
"by three spaces on each side. For instance, here’s one way to comment the"
" definition of ``’`` (tick) showing first the input-stream comment, then "
"the stack comment:"
msgstr ""

#: ../../chapter5.rst:1247
msgid "If you prefer to use ``(`` , the comment would look like this:"
msgstr ""

#: ../../chapter5.rst:1253
msgid ""
"Incidentally, there are three distinct ways to receive string input. To "
"avoid confusion, here are the terms:"
msgstr ""

#: ../../chapter5.rst:1260
msgid "Scanning-for"
msgstr ""

#: ../../chapter5.rst:1258
msgid ""
"means looking ahead in the input stream, either for a word or number as "
"in the case of tick, or for a delimiter as in the case of ``.\"`` and "
"``(`` ."
msgstr ""

#: ../../chapter5.rst:1264
msgid "Expecting"
msgstr ""

#: ../../chapter5.rst:1263
msgid ""
"means waiting for. ``EXPECT`` and ``KEY``, and definitions that invoke "
"them, are ones that “expect” input."
msgstr ""

#: ../../chapter5.rst:1269
msgid "Presuming"
msgstr ""

#: ../../chapter5.rst:1267
msgid ""
"indicates that in normal usage something will follow. The word: “scans-"
"for” the name to be defined, and “presumes” that a definition will "
"follow."
msgstr ""

#: ../../chapter5.rst:1271
msgid "The input-stream comment is only appropriate for input being scanned-for."
msgstr ""

#: ../../chapter5.rst:1275
msgid "Purpose Comments"
msgstr ""

#: ../../chapter5.rst:1279
msgid "Every definition should bear a purpose comment unless:"
msgstr ""

#: ../../chapter5.rst:1281
msgid "its purpose is clear from its name or its stack-effect comment, or"
msgstr ""

#: ../../chapter5.rst:1282
msgid "if it consists of three or fewer words."
msgstr ""

#: ../../chapter5.rst:1284
msgid ""
"The purpose comment should be kept to a minimum-never more than a full "
"line. For example:"
msgstr ""

#: ../../chapter5.rst:1292
msgid ""
"Use the imperative mood: “set Foreground color,” not “sets Foreground "
"color.”"
msgstr ""

#: ../../chapter5.rst:1295
msgid ""
"On the other hand, a word’s purpose can often be described in terms of "
"its stack-effect comment. You rarely need both a stack comment and a "
"purpose comment. For instance:"
msgstr ""

#: ../../chapter5.rst:1309
msgid ""
"This definition takes as its incoming argument a number that represents "
"the number of spaces to type."
msgstr ""

#: ../../chapter5.rst:1318
msgid ""
"This definition converts an index, which it consumes, into an address "
"within a table of 2-byte elements corresponding to the indexed element."
msgstr ""

#: ../../chapter5.rst:1325
msgid "This definition returns an address of a scratch region of memory."
msgstr ""

#: ../../chapter5.rst:1327
msgid ""
"Occasionally, readability is best served by including both types of "
"comment. In this case, the purpose comment should appear last. For "
"instance:"
msgstr ""

#: ../../chapter5.rst:1337
msgid ""
"Indicate the type of comment by ordering: input-stream comments first, "
"stack-effect comments second, purpose comments last."
msgstr ""

#: ../../chapter5.rst:1340
msgid "For example:"
msgstr ""

#: ../../chapter5.rst:1346
msgid "If you prefer to use ``(``, then write:"
msgstr ""

#: ../../chapter5.rst:1352
msgid "If necessary, you can put the purpose comment on a second line:"
msgstr ""

#: ../../chapter5.rst:1361
msgid "Comments for Defining Words"
msgstr ""

#: ../../chapter5.rst:1363
msgid "The definition of a defining word involves two behaviors:"
msgstr ""

#: ../../chapter5.rst:1366
msgid ""
"that of the defining word as it defines its “child” (compile-time "
"behavior), and"
msgstr ""

#: ../../chapter5.rst:1369
msgid "that of the child itself (run-time behavior)."
msgstr ""

#: ../../chapter5.rst:1371
msgid "These two behaviors must be commented separately."
msgstr ""

#: ../../chapter5.rst:1375
msgid ""
"Comment a defining word's compile-time behavior in the usual way; comment"
" its run-time behavior separately, following the word ``DOES>`` (or "
"``;CODE``)."
msgstr ""

#: ../../chapter5.rst:1379
msgid "For instance,"
msgstr ""

#: ../../chapter5.rst:1386
msgid ""
"The stack-effect comment for the run-time (child’s) behavior represents "
"the net stack effect for the child word. Therefore it does not include "
"the address returned by ``DOES>,`` even though this address is on the "
"stack when the run-time code begins."
msgstr ""

#: ../../chapter5.rst:1391
msgid "*Bad* (run-time comment includes apf):"
msgstr ""

#: ../../chapter5.rst:1407
msgid "Words defined by this word ARRAY will exhibit the stack effect:"
msgstr ""

#: ../../chapter5.rst:1413
msgid ""
"If the defining word does not specify the run-time behavior, there still "
"exists a run-time behavior, and it may be commented:"
msgstr ""

#: ../../chapter5.rst:1422
msgid "Comments for Compiling Words"
msgstr ""

#: ../../chapter5.rst:1424
msgid "As with defining words, most compiling words involve two behaviors:"
msgstr ""

#: ../../chapter5.rst:1426
msgid ""
"That of the compiling word as the definition in which it appears is "
"compiled"
msgstr ""

#: ../../chapter5.rst:1429
msgid ""
"That of the run-time routine which will execute when we invoke the word "
"being defined. Again we must comment each behavior separately."
msgstr ""

#: ../../chapter5.rst:1434
msgid ""
"Comment a compiling word's run-time behavior in the usual way; comment "
"its compile-time behavior separately, beginning with the label "
"\"Compile:\"."
msgstr ""

#: ../../chapter5.rst:1438
msgid "For instance:"
msgstr ""

#: ../../chapter5.rst:1446
msgid ""
"In the case of compiling words, the first comment describes the run-time "
"behavior, which is usually the *syntax for using* the word. The second "
"comment describes what the word *actually does* in compiling (which is of"
" less importance to the user)."
msgstr ""

#: ../../chapter5.rst:1451
msgid "Other examples:"
msgstr ""

#: ../../chapter5.rst:1458
msgid ""
"Occasionally a compiling word may exhibit a different behavior when it is"
" invoked *outside* a colon definition. Such words (to be fastidious about"
" it) require three comments. For instance:"
msgstr ""

#: ../../chapter5.rst:1469
msgid ""
":doc:`Appendix E<appendixe>` includes two screens showing good commenting"
" style."
msgstr ""

#: ../../chapter5.rst:1472
msgid "Vertical Format vs. Horizontal Format"
msgstr ""

#: ../../chapter5.rst:1474
msgid ""
"The purpose of commenting is to allow a reader of your code to easily "
"determine what’s going on. But how much commenting is necessary? To "
"determine the level of commenting appropriate for your circumstances, you"
" must ask yourself two questions:"
msgstr ""

#: ../../chapter5.rst:1479
msgid "Who will be reading my code?"
msgstr ""

#: ../../chapter5.rst:1481
msgid "How readable are my definitions?"
msgstr ""

#: ../../chapter5.rst:1483
msgid ""
"There are two basic styles of commenting to choose from. The first style,"
" often called the “vertical format,” includes a step-by-step description "
"of the process, in the manner of a well-commented assembly language "
"listing. These line-by-line comments are called “narrative comments.”"
msgstr ""

#: ../../chapter5.rst:1506
msgid ""
"The other approach does not intersperse narrative comments between code "
"phrases. This is called the “horizontal format.”"
msgstr ""

#: ../../chapter5.rst:1515
msgid ""
"The vertical format is preferred when a large team of programmers are "
"coding and maintaining the application. Typically, such a team will "
"include several junior-level programmers responsible for minor "
"corrections. In such an environment, diligent commenting can save a lot "
"of time and upset. As Johnson of Moore Products Co. says: “When "
"maintaining code you are usually interested in just one small section, "
"and the more information written there the better your chances for a "
"speedy fix.”"
msgstr ""

#: ../../chapter5.rst:1524
msgid ""
"Here are several pertinent rules required of the Forth programmers at "
"Moore Products Co. (I’m paraphrasing):"
msgstr ""

#: ../../chapter5.rst:1527
msgid ""
"A vertical format will be used. Comments will appear to the right of the "
"source code, but may continue to engulf the next line totally if needed."
msgstr ""

#: ../../chapter5.rst:1531
msgid ""
"There should be more comment characters than source characters. (The "
"company encourages long descriptive names, greater than ten characters, "
"and allows the names to be counted as comment characters.)"
msgstr ""

#: ../../chapter5.rst:1536
msgid ""
"Any conditional structure or application word should appear on a separate"
" line. “Noise words” can be grouped together. Indentation is used to show"
" nested conditionals."
msgstr ""

#: ../../chapter5.rst:1540
msgid ""
"There are some difficulties with this format, however. For one thing, "
"line-by-line commenting is time-consuming, even with a good screen "
"editor. Productivity can be stifled, especially when stopping to write "
"the comments breaks your chain of thought."
msgstr ""

#: ../../chapter5.rst:1546
msgid ""
"Also, you must also carefully ensure that the comments are up-to-date. "
"Very often code is corrected, the revision is tested, the change "
"works—and the programmer forgets to change the comments. The more "
"comments there are, the more likely they are to be wrong. If they’re "
"wrong, they’re worse than useless."
msgstr ""

#: ../../chapter5.rst:1552
msgid ""
"This problem can be alleviated if the project supervisor carefully "
"reviews code and ensures the accuracy of comments."
msgstr ""

#: ../../chapter5.rst:1555
msgid ""
"Finally, line-by-line commenting can allow a false sense of security. "
"Don’t assume that because each *line* has a comment, the *application* is"
" well-com-men-ted. Line-by-line commenting doesn’t address the "
"significant aspects of a definition’s operation. What, for instance, is "
"the thinking behind the checksum algorithm used? Who knows, from the "
"narrative comments?"
msgstr ""

#: ../../chapter5.rst:1563
msgid ""
"To properly describe, in prose, the implications of a given procedure "
"usually requires many paragraphs, not a single phrase. Such descriptions "
"properly belong in auxiliary documentation or in the chapter preamble."
msgstr ""

#: ../../chapter5.rst:1567
msgid ""
"Despite these cautions, many companies find the vertical format "
"necessary. Certainly a team that is newly exposed to Forth should adopt "
"it, as should any very large team."
msgstr ""

#: ../../chapter5.rst:1571
msgid ""
"What about the horizontal format? Perhaps it’s an issue of art vs. "
"practicality, but I feel compelled to defend the horizontal format as "
"equally valid and in some ways superior."
msgstr ""

#: ../../chapter5.rst:1575
msgid ""
"If Forth code is really well-written, there should be nothing ambiguous "
"about it. This means that:"
msgstr ""

#: ../../chapter5.rst:1578
msgid "supporting lexicons have a well-designed syntax"
msgstr ""

#: ../../chapter5.rst:1580
msgid "stack inputs and outputs are commented"
msgstr ""

#: ../../chapter5.rst:1582
msgid ""
"the purpose is commented (if it’s not clear from the name or stack "
"comment)"
msgstr ""

#: ../../chapter5.rst:1585
msgid "definitions are not too long"
msgstr ""

#: ../../chapter5.rst:1587
msgid ""
"not too many arguments are passed to a single definition via the stack "
"(see “The Stylish Stack” in :doc:`Chapter Seven<chapter7>`)."
msgstr ""

#: ../../chapter5.rst:1590
msgid ""
"Forth is simply not like other languages, in which line-by-line "
"commenting is one of the few things you can do to make programs more "
"readable."
msgstr ""

#: ../../chapter5.rst:1594
msgid ""
"Skillfully written Forth code is like poetry, containing precise meaning "
"that both programmer and machine can easily read. Your *goal* should be "
"to write code that does not need commenting, even if you choose to "
"comment it. Design your application so that the code, not the comments, "
"conveys the meaning."
msgstr ""

#: ../../chapter5.rst:1600
msgid ""
"If you succeed, then you can eliminate the clutter of excessive "
"commenting, achieving a purity of expression without redundant "
"explanations."
msgstr ""

#: ../../chapter5.rst:1609
msgid "Wiggins, proud of his commenting technique."
msgstr ""

#: ../../chapter5.rst:1613
msgid "The most-accurate, least-expensive documentation is self-documenting code."
msgstr ""

#: ../../chapter5.rst:1616
msgid ""
"Unfortunately, even the best programmers, given the pressure of a "
"deadline, may write working code that is not easily readable without "
"comments. If you are writing for yourself, or for a small group with whom"
" you can verbally communicate, the horizontal format is ideal. Otherwise,"
" consider the vertical format."
msgstr ""

#: ../../chapter5.rst:1624
msgid "Choosing Names: The Art"
msgstr ""

#: ../../chapter5.rst:1626
msgid ""
"Besides a mathematical inclination, an exceptionally good mastery of "
"one\\'s native tongue is the most vital asset of a competent programmer "
"(**Prof.  Edsger W. Dijkstra** [dijkstra82]_ )."
msgstr ""

#: ../../chapter5.rst:1630
msgid ""
"We’ve talked about the significance of using names to symbolize ideas and"
" objects in the application. The choosing of names turns out to be an "
"important part of the design process."
msgstr ""

#: ../../chapter5.rst:1635
msgid ""
"Newcomers tend to overlook the important of names. “After all,” they "
"think, “the computer doesn’t care what names I choose.”"
msgstr ""

#: ../../chapter5.rst:1638
msgid ""
"But good names are essential for readability. Moreover, the mental "
"exercise of summoning a one-word description bears a synergistic effect "
"on your perceptions of what the entity should or should not do."
msgstr ""

#: ../../chapter5.rst:1642
msgid "Here are some rules for choosing good names:"
msgstr ""

#: ../../chapter5.rst:1646
msgid "Choose names according to \"what,\" not \"how.\""
msgstr ""

#: ../../chapter5.rst:1648
msgid ""
"A definition should hide the complexities of implementation from other "
"definitions which invoke it. The name, too, should hide the details of "
"the procedure, and instead should describe the outward appearance or net "
"effect."
msgstr ""

#: ../../chapter5.rst:1653
msgid ""
"For instance, the Forth word ``ALLOT`` simply increments the dictionary "
"pointer (called ``DP`` or ``H`` in most systems). But the name ``ALLOT`` "
"is better than ``DP+!`` because the user is thinking of reserving space, "
"not incrementing a pointer."
msgstr ""

#: ../../chapter5.rst:1659
msgid ""
"The ’83 Standard adopted the name ``CMOVE>`` instead of the previous name"
" for the same function, ``<CMOVE``. The operation makes it possible to "
"copy a region of memory *forward* into overlapping memory. It "
"accomplishes this by starting with the last byte and working *backward*. "
"In the new name, the forwardness of the “what” supersedes the "
"backwardness of the “how.”"
msgstr ""

#: ../../chapter5.rst:1668
msgid "Find the most expressive word."
msgstr ""

#: ../../chapter5.rst:1672
msgid ""
"A powerful agent is the right word.  Whenever we come upon one of those "
"intensely right words in a book or a newspaper the resulting effect is "
"physical as well as spiritual, and electrically prompt **(Mark Twain)** ."
msgstr ""

#: ../../chapter5.rst:1677
msgid ""
"The difference between the right word and the almost-right word is like "
"the difference between lightning and the lightning bug **(Mark Twain)** ."
msgstr ""

#: ../../chapter5.rst:1681
msgid ""
"Suit the action to the word, the word to the action **(Shakespeare, "
"Hamlet, Act~III)** ."
msgstr ""

#: ../../chapter5.rst:1684
msgid ""
"Henry Laxen, a Forth consultant and author, suggests that the most "
"important Forth development tool is a good thesaurus [laxen]_ ."
msgstr ""

#: ../../chapter5.rst:1688
msgid ""
"Sometimes you’ll think of an adequate word for a definition, but it "
"doesn’t feel quite right. It may be months later before you realize that "
"you fell short of the mark. In the Roman numeral example in :doc:`Chapter"
" Four<chapter4>` one-less-than the next symbol’s value. My first choice "
"was ``4-0R-9``. That’s awkward, but it was much later that I thought of "
"``ALMOST``."
msgstr ""

#: ../../chapter5.rst:1694
msgid ""
"Most fig-Forth systems include the word ``VLIST``, which lists the names "
"of all the words in the current vocabulary. After many years someone "
"realized that a nicer name is ``WORDS``. Not only does ``WORDS`` sound "
"more pleasant by itself, it also works nicely with vocabulary names. For "
"instance:"
msgstr ""

#: ../../chapter5.rst:1710
msgid ""
"On the other hand, Moore points out that inappropriate names can become a"
" simple technique for encryption. If you need to provide security when "
"you’re forced to distribute source, you can make your code very "
"unreadable by deliberately choosing misleading names. Of course, "
"maintenance becomes impossible."
msgstr ""

#: ../../chapter5.rst:1719
msgid "Choose names that work in phrases."
msgstr ""

#: ../../chapter5.rst:1721
msgid ""
"Faced with a definition you don’t know what to call, think about how the "
"word will be used in context. For instance:"
msgstr ""

#: ../../chapter5.rst:1726
msgid "``SHUTTER OPEN``"
msgstr ""

#: ../../chapter5.rst:1725
msgid ""
"``OPEN`` is the appropriate name for a word that sets a bit in an I/O "
"address identified with the name ``SHUTTER``."
msgstr ""

#: ../../chapter5.rst:1732
msgid "``3 BUTTON DOES IGNITION``"
msgstr ""

#: ../../chapter5.rst:1729
msgid ""
"``DOES`` is a good choice for a word that vectors the address of the "
"function ``IGNITION`` into a table of functions, so that ``IGNITION`` "
"will be executed when Button 3 is pushed."
msgstr ""

#: ../../chapter5.rst:1739
msgid "``SAY HELLO``"
msgstr ""

#: ../../chapter5.rst:1735
msgid ""
"``SAY`` is the perfect choice for vectoring ``HELLO`` into an execution "
"variable.  (When I first wrote this example for Starting Forth, I called "
"it ``VERSION``. Moore reviewed the manuscript and suggested ``SAY``, "
"which is clearly much better.)"
msgstr ""

#: ../../chapter5.rst:1743
msgid "``I'M HARRY``"
msgstr ""

#: ../../chapter5.rst:1742
msgid ""
"The word ``I'M`` seems more natural than ``LOGON HARRY``, ``LOGIN HARRY``"
" or ``SESSION HARRY``, as often seen."
msgstr ""

#: ../../chapter5.rst:1758
msgid "The choice of ``I'M`` is another invention of **Moore**, who says:"
msgstr ""

#: ../../chapter5.rst:1748
msgid ""
"I detest the word ``LOGON``. There is no such word in English.  I was "
"looking for a word that said, \"I'm ...\" It was a natural. I just "
"stumbled across it.  Even though it's clumsy with that apostrophe, it has"
" that sense of rightness."
msgstr ""

#: ../../chapter5.rst:1753
msgid ""
"All these little words are the nicest way of getting the \"Aha!\" "
"reaction.  If you think of the right word, it is **obviously** the right "
"word."
msgstr ""

#: ../../chapter5.rst:1757
msgid ""
"If you have a wide recall vocabulary, you're in a better position to come"
" up with the right word."
msgstr ""

#: ../../chapter5.rst:1760
msgid ""
"Another of Moore’s favorite words is TH, which he uses as an array "
"indexing word. For instance, the phrase"
msgstr ""

#: ../../chapter5.rst:1767
msgid "returns the address of the “fifth” element of the array."
msgstr ""

#: ../../chapter5.rst:1772
msgid "Spell names in full."
msgstr ""

#: ../../chapter5.rst:1774
msgid ""
"I once saw some Forth code published in a magazine in which the author "
"seemed hell-bent on purging all vowels from his names, inventing such "
"eyesores as ``DSPL-BFR`` for “display buffer.” Other writers seem to "
"think that three characters magically says it all, coining ``LEN`` for "
"“length.” Such practices reflect thinking from a bygone age."
msgstr ""

#: ../../chapter5.rst:1780
msgid ""
"Forth words should be fully spelled out. Feel proud to type every letter "
"of ``INITIALIZE`` or ``TERMINAL`` or ``BUFFER``. These are the words you "
"mean. The worst problem with abbreviating a word is that you forget just "
"how you abbreviated it. Was that ``DSPL`` or ``DSPLY``?"
msgstr ""

#: ../../chapter5.rst:1786
msgid ""
"Another problem is that abbreviations hinder readability. Any programming"
" language is hard enough to read without compounding the difficulty."
msgstr ""

#: ../../chapter5.rst:1790
msgid "Still, there are exceptions. Here are a few:"
msgstr ""

#: ../../chapter5.rst:1792
msgid ""
"Words that you use extremely frequently in code. Forth employs a handful "
"of commands that get used over and over, but have little or no intrinsic "
"meaning:"
msgstr ""

#: ../../chapter5.rst:1800
msgid ""
"But there are so few of them, and they’re used so often, they become old "
"friends. I would never want to type, on a regular basis,"
msgstr ""

#: ../../chapter5.rst:1808
msgid ""
"(Interestingly, most of these symbols don’t have English counterparts. We"
" use the phrase “*colon* definition” because there’s no other term; we "
"say “*comma* a number into the dictionary” because it’s not exactly "
"compiling, and there’s no other term.)"
msgstr ""

#: ../../chapter5.rst:1813
msgid ""
"Words that a terminal operator might use frequently to control an "
"operation. These words should be spelled as single letters, as are line "
"editor commands."
msgstr ""

#: ../../chapter5.rst:1817
msgid ""
"Words in which familiar usage implies that they be abbreviated. Forth "
"assembler mnemonics are typically patterned after the manufacturer’s "
"suggested mnemonics, which are abbreviations (such as JMP and MOV)."
msgstr ""

#: ../../chapter5.rst:1821
msgid ""
"Your names should be pronounceable; otherwise you may regret it when you "
"try to discuss the program with other people. If the name is symbolic, "
"invent a pronunciation (e.g., ``>R`` is called “to-r”; ``R>`` is called "
"“r-from”)."
msgstr ""

#: ../../chapter5.rst:1828
msgid "Favor short words."
msgstr ""

#: ../../chapter5.rst:1830
msgid ""
"Given the choice between a three-syllable word and a one-syllable word "
"that means the same thing, choose the shorter. ``BRIGHT`` is a better "
"name than ``INTENSE``. ``ENABLE`` is a better name than ``ACTIVATE``; "
"``GO``, ``RUN``, or ``ON`` may be better still."
msgstr ""

#: ../../chapter5.rst:1834
msgid ""
"Shorter names are easier to type. They save space in the source screen. "
"Most important, they make your code crisp and clean."
msgstr ""

#: ../../chapter5.rst:1839
msgid "Hyphenated names may be a sign of bad factoring."
msgstr ""

#: ../../chapter5.rst:1850
msgid "**Moore**:"
msgstr ""

#: ../../chapter5.rst:1842
msgid ""
"There are diverging programming styles in the Forth community.  One uses "
"hyphenated words that express in English what the word is doing. You "
"string these big long words together and you get something that is quite "
"readable."
msgstr ""

#: ../../chapter5.rst:1847
msgid ""
"But I immediately suspect that the programmer didn't think out the words "
"carefully enough, that the hyphen should be broken and the words defined "
"separately.  That isn't always possible, and it isn't always "
"advantageous. But I suspect a hyphenated word of mixing two concepts."
msgstr ""

#: ../../chapter5.rst:1852
msgid "Compare the following two strategies for saying the same thing:"
msgstr ""

#: ../../chapter5.rst:1865
msgid ""
"The syntax on the left requires eight dictionary entries; the syntax on "
"the right requires only six-and some of the words are likely to be reused"
" in other parts of the application. If you had a ``MIDDLE`` motor and "
"solenoid as well, you’d need only seven words to describe sixteen "
"combinations."
msgstr ""

#: ../../chapter5.rst:1873
msgid "Don't bundle numbers into names."
msgstr ""

#: ../../chapter5.rst:1875
msgid ""
"Watch out for a series of names beginning or ending with numbers, such as"
" ``1CHANNEL``, ``2CHANNEL``, ``3CHANNEL``, etc."
msgstr ""

#: ../../chapter5.rst:1878
msgid ""
"This bundling of names and numbers may be an indication of bad factoring."
" The crime is similar to hyphenation, except that what should be factored"
" out is a number, not a word. A better factoring of the above would be"
msgstr ""

#: ../../chapter5.rst:1889
msgid "In this case, the three words were reduced to one."
msgstr ""

#: ../../chapter5.rst:1891
msgid ""
"Often the bundling of names and numbers indicates fuzzy naming. In the "
"above case, more descriptive names might indicate the purpose of the "
"channels, as in"
msgstr ""

#: ../../chapter5.rst:1899
msgid "We’ll amplify on these ideas in the next chapter on “Factoring.”"
msgstr ""

#: ../../chapter5.rst:1902
msgid "Naming Standards: The Science"
msgstr ""

#: ../../chapter5.rst:1906
msgid "Learn and adopt Forth\\'s naming conventions."
msgstr ""

#: ../../chapter5.rst:1908
msgid ""
"In the quest for short, yet meaningful names, Forth programmers have "
"adopted certain naming conventions. :doc:`Appendix E<appendixe>` includes"
" a list of the most useful conventions developed over the years."
msgstr ""

#: ../../chapter5.rst:1912
msgid ""
"An example of the power of naming conventions is the use of “dot” to mean"
" “print” or “display.” Forth itself uses"
msgstr ""

#: ../../chapter5.rst:1919
msgid ""
"for displaying various types of numbers in various formats. The "
"convention extends to application words as well. If you have a variable "
"called ``DATE,`` and you want a word that displays the date, use the name"
msgstr ""

#: ../../chapter5.rst:1927
msgid ""
"A caution: The overuse of prefixes and suffixes makes words uglier and "
"ultimately less readable. Don’t try to describe everything a word does by"
" its name alone. After all, a name is a symbol, not a shorthand for code."
" Which is more readable and natural sounding?:"
msgstr ""

#: ../../chapter5.rst:1932
msgid "Oedipus complex"
msgstr ""

#: ../../chapter5.rst:1934
msgid "(which bears no intrinsic meaning), or"
msgstr ""

#: ../../chapter5.rst:1936
msgid "subconscious-attachment-to-parent-of-opposite-sex complex"
msgstr ""

#: ../../chapter5.rst:1938
msgid "Probably the former, even though it assumes you know the play."
msgstr ""

#: ../../chapter5.rst:1942
msgid ""
"Use prefixes and suffices to differentiate between like words rather than"
" to cram details of meaning into the name itself."
msgstr ""

#: ../../chapter5.rst:1945
msgid "For instance, the phrase"
msgstr ""

#: ../../chapter5.rst:1951
msgid "is just as readable as"
msgstr ""

#: ../../chapter5.rst:1957
msgid ""
"and cleaner as well. It is therefore preferable, unless we need an "
"additional word called DONE (as a flag, for instance)."
msgstr ""

#: ../../chapter5.rst:1960
msgid "A final tip on naming:"
msgstr ""

#: ../../chapter5.rst:1964
msgid ""
"Begin all hex numbers with \"0\" (zero) to avoid potential collisions "
"with names."
msgstr ""

#: ../../chapter5.rst:1967
msgid "For example, write 0ADD, not ADD."
msgstr ""

#: ../../chapter5.rst:1969
msgid ""
"By the way, don’t expect your Forth system to necessarily conform to the "
"above conventions. The conventions are meant to be used in new "
"applications."
msgstr ""

#: ../../chapter5.rst:1973
msgid ""
"Forth was created and refined over many years by people who used it as a "
"means to an end. At that time, it was neither reasonable nor possible to "
"impose naming standards on a tool that was still growing and evolving."
msgstr ""

#: ../../chapter5.rst:1977
msgid "Had Forth been designed by committee, we would not love it so."
msgstr ""

#: ../../chapter5.rst:1980
msgid "More Tips for Readability"
msgstr ""

#: ../../chapter5.rst:1982
msgid ""
"Here are some final suggestions to make your code more readable. "
"(Definitions appear in :doc:`Appendix C<appendixc>`.)"
msgstr ""

#: ../../chapter5.rst:1985
msgid ""
"One constant that pays for itself in most applications is ``BL`` (the "
"ASCII value for “blank-space”)."
msgstr ""

#: ../../chapter5.rst:1988
msgid ""
"The word ``ASCII`` is used primarily within colon definitions to free you"
" from having to know the literal value of an ASCII character. For "
"instance, instead of writing:"
msgstr ""

#: ../../chapter5.rst:1996
msgid "where 41 is the ASCII representation for right-parenthesis, you can write"
msgstr ""

#: ../../chapter5.rst:2003
msgid ""
"A pair of words that can make dealing with booleans more readable are "
"``TRUE`` and ``FALSE``. With these additions you can write phrases such "
"as"
msgstr ""

#: ../../chapter5.rst:2012
msgid "to set a flag or"
msgstr ""

#: ../../chapter5.rst:2018
msgid "to clear it."
msgstr ""

#: ../../chapter5.rst:2020
msgid ""
"(I once used ``T`` and ``F``, but the words are needed so rarely I now "
"heed the injunction against abbreviations.)"
msgstr ""

#: ../../chapter5.rst:2024
msgid ""
"As part of your application (not necessarily part of your Forth system), "
"you can take this idea a step further and define:"
msgstr ""

#: ../../chapter5.rst:2032
msgid "These words allow you to write:"
msgstr ""

#: ../../chapter5.rst:2044
msgid ""
"Other names for these definitions include ``SET`` and ``RESET``, although"
" ``SET`` and ``RESET`` most commonly use bit masks to manipulate "
"individual bits."
msgstr ""

#: ../../chapter5.rst:2047
msgid ""
"An often-used word is ``WITHIN``, which determines whether a given value "
"lies within two other values. The syntax is:"
msgstr ""

#: ../../chapter5.rst:2055
msgid ""
"where “n” is the value to be tested and “lo” and “hi” represent the "
"range. ``WITHIN`` returns true if “n” is *greater-than or equal-to* “lo” "
"and *less-than* “hi.” This use of the non-inclusive upper limit parallels"
" the syntax of ``DO``  ``LOOP`` s."
msgstr ""

#: ../../chapter5.rst:2060
msgid ""
"Moore recommends the word ``UNDER+``. It’s useful for adding a value to "
"the number just under the top stack item, instead of to the top stack "
"item. It could be implemented in high level as:"
msgstr ""

#: ../../chapter5.rst:2070
msgid "Summary"
msgstr ""

#: ../../chapter5.rst:2072
msgid ""
"Maintainability requires readability. In this chapter we’ve enumerated "
"various ways to make a source listing more readable. We’ve assumed a "
"policy of making our code as self-documenting as possible. Techniques "
"include listing organization, spacing and indenting, commenting, name "
"choices, and special words that enhance clarity."
msgstr ""

#: ../../chapter5.rst:2078
msgid ""
"We’ve mentioned only briefly auxiliary documentation, which includes all "
"documentation apart from the listing itself. We won’t discuss auxiliary "
"documentation further in this volume, but it remains an integral part of "
"the software development process."
msgstr ""

#: ../../chapter5.rst:2084
msgid "REFERNCES"
msgstr "参考文献"

#: ../../chapter5.rst:2086
msgid ""
"Gregory Stevenson, \"Documentation Priorities,\" **1981 FORML Conference "
"Proceedings,**  p. 401."
msgstr ""
"Gregory Stevenson, \"Documentation Priorities,\" **1981 FORML Conference "
"Proceedings,**  p. 401."

#: ../../chapter5.rst:2087
msgid ""
"Joanne Lee, \"Quality Assurance in a ForthEnvironment,\" (Appendix A),  "
"**1981 FORML Proceedings,**  p. 363."
msgstr ""
"Joanne Lee, \"Quality Assurance in a ForthEnvironment,\" (Appendix A),  "
"**1981 FORML Proceedings,**  p. 363."

#: ../../chapter5.rst:2088
msgid ""
"Edsger W. Dijkstra,  **Selected Writings onComputing: A Personal "
"Perspective,**  New York, Springer Verlag, Inc.,1982."
msgstr ""
"Edsger W. Dijkstra,  **Selected Writings onComputing: A Personal "
"Perspective,**  New York, Springer Verlag, Inc.,1982."

#: ../../chapter5.rst:2089
msgid ""
"Henry Laxen, \"Choosing Names,\"  **Forth Dimensions,** vol. 4, no.\\ 4, "
"Forth Interest Group."
msgstr ""
"Henry Laxen, \"Choosing Names,\"  **Forth Dimensions,** vol. 4, no.\\ 4, "
"Forth Interest Group."

