# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Leo Brodie
# This file is distributed under the same license as the Thinking Forth package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Thinking Forth 0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-29 09:41+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../chapter6.rst:4
msgid "6. Factoring"
msgstr ""

#: ../../chapter6.rst:6
msgid "In this chapter we’ll continue our study of the implementations phase, this time focusing on factoring."
msgstr ""

#: ../../chapter6.rst:9
msgid "Decomposition and factoring are chips off the same block. Both involve dividing and organizing. Decomposition occurs during preliminary design; factoring occurs during detailed design and implementation."
msgstr ""

#: ../../chapter6.rst:13
msgid "Since every colon definition reflects decisions of factoring, an understanding of good factoring technique is perhaps the most important skill for a Forth programmer."
msgstr ""

#: ../../chapter6.rst:17
msgid "What is factoring? Factoring means organizing code into useful fragments. To make a fragment useful, you often must separate reusable parts from non-reusable parts. The reusable parts become new definitions. The non-reusable parts become arguments or parameters to the definitions."
msgstr ""

#: ../../chapter6.rst:23
msgid "Making this separation is usually referred to as “factoring out.” The first part of this chapter will discuss various “factoring-out” techniques."
msgstr ""

#: ../../chapter6.rst:27
msgid "Deciding how much should go into, or stay out of, a definition is another aspect of factoring. The second section will outline the criteria for useful factoring."
msgstr ""

#: ../../chapter6.rst:32
msgid "Factoring Techniques"
msgstr ""

#: ../../chapter6.rst:34
msgid "If a module seems almost, but not quite, useful from a second place in the system, try to identify and isolate the useful subfunction. The remainder of the module might be incorporated in its original caller (from \"**Structured Design**\" [stevens74-6]_ )."
msgstr ""

#: ../../chapter6.rst:39
msgid "The “useful subfunction” of course becomes the newly factored definition.What about the part that “isn’t quite useful”? That depends on what it is."
msgstr ""

#: ../../chapter6.rst:44
msgid "Factoring Out Data"
msgstr ""

#: ../../chapter6.rst:46
msgid "The simplest thing to factor out is data, thanks to Forth’s data stack. For instance, to compute two-thirds of 1,000, we write"
msgstr ""

#: ../../chapter6.rst:54
msgid "To define a word that computes two-thirds of *any* number, we factor out the argument from the definition:"
msgstr ""

#: ../../chapter6.rst:61
msgid "When the datum comes in the *middle* of the useful phrase, we have to use stack manipulation. For instance, to center a piece of text ten characters long on an 80-column screen, we would write:"
msgstr ""

#: ../../chapter6.rst:69
msgid "But text isn’t always 10 characters long. To make the phrase useful for any string, you’d factor out the length by writing:"
msgstr ""

#: ../../chapter6.rst:76
msgid "The data stack can also be used to pass addresses. Therefore what’s factored out may be a *pointer* to data rather than the data themselves. The data can be numbers or even strings, and still be factored out through use of the stack."
msgstr ""

#: ../../chapter6.rst:81
msgid "Sometimes the difference appears to be a function, but you can factor it out simply as a number on the stack. For instance:"
msgstr ""

#: ../../chapter6.rst:87
#: ../../chapter6.rst:106
#: ../../chapter6.rst:133
#: ../../chapter6.rst:150
#: ../../chapter6.rst:164
msgid "Segment 1:"
msgstr ""

#: ../../chapter6.rst:88
#: ../../chapter6.rst:89
#: ../../chapter6.rst:93
msgid "WILLY"
msgstr ""

#: ../../chapter6.rst:91
#: ../../chapter6.rst:96
msgid "PUDDIN’ PIE AND"
msgstr ""

#: ../../chapter6.rst:92
#: ../../chapter6.rst:109
#: ../../chapter6.rst:139
#: ../../chapter6.rst:153
#: ../../chapter6.rst:167
msgid "Segment 2:"
msgstr ""

#: ../../chapter6.rst:94
msgid "NILLY"
msgstr ""

#: ../../chapter6.rst:95
msgid "8 \\*"
msgstr ""

#: ../../chapter6.rst:98
msgid "How can you factor out the “8 \\*” operation? By including “\\*” in the factoring and passing it a one or eight:"
msgstr ""

#: ../../chapter6.rst:106
msgid "1 NEW"
msgstr ""

#: ../../chapter6.rst:109
msgid "8 NEW"
msgstr ""

#: ../../chapter6.rst:111
msgid "(Of course if WILLY NILLY changes the stack, you’ll need to add appropriate stack-manipulation operators.)"
msgstr ""

#: ../../chapter6.rst:114
msgid "If the operation involves addition, you can nullify it by passing a zero."
msgstr ""

#: ../../chapter6.rst:119
msgid "For simplicity, try to express the difference between similar fragments as a numeric difference (values or addresses), rather than as a procedural difference."
msgstr ""

#: ../../chapter6.rst:124
msgid "Factoring Out Functions"
msgstr ""

#: ../../chapter6.rst:126
msgid "On the other hand, the difference sometimes *is* a function. Witness:"
msgstr ""

#: ../../chapter6.rst:141
msgid "Wrong approach:"
msgstr ""

#: ../../chapter6.rst:150
msgid "TRUE BLETCHES"
msgstr ""

#: ../../chapter6.rst:153
msgid "FALSE BLETCHES"
msgstr ""

#: ../../chapter6.rst:155
msgid "A better approach:"
msgstr ""

#: ../../chapter6.rst:164
msgid "BLETCH-AB BLETCH-C BLETCH-DEF"
msgstr ""

#: ../../chapter6.rst:167
msgid "BLETCH-AB PERVERSITY BLETCH-DEF"
msgstr ""

#: ../../chapter6.rst:171
msgid "Don't pass control flags downward."
msgstr ""

#: ../../chapter6.rst:173
msgid "Why not? First, you are asking your running application to make a pointless decision—one you knew the answer to while programming—thereby reducing efficiency. Second, the terminology doesn’t match the conceptual model. What are ``TRUE BLETCHES`` as opposed to ``FALSE BLETCHES``?"
msgstr ""

#: ../../chapter6.rst:179
msgid "Factoring Out Code from Within Control Structures"
msgstr ""

#: ../../chapter6.rst:181
msgid "Be alert to repetitions on either side of an ``IF``  ``ELSE``  ``THEN`` statement. For instance:"
msgstr ""

#: ../../chapter6.rst:190
msgid "This fragment normally emits an ASCII character, but if the character is a control code, it emits a dot. Either way, an ``EMIT`` is performed. Factor ``EMIT`` out of the conditional structure, like this:"
msgstr ""

#: ../../chapter6.rst:199
msgid "The messiest situation occurs when the difference between two definitions is a function within a structure that makes it impossible to factor out the half-fragments. In this case, use stack arguments, variables, or even vectoring. We’ll see how vectoring can be used in a section of :doc:`Chapter Seven<chapter7>` called “Using DOER/MAKE.”"
msgstr ""

#: ../../chapter6.rst:205
msgid "Here’s a reminder about factoring code from out of a ``DO``  ``LOOP``:"
msgstr ""

#: ../../chapter6.rst:209
msgid "In factoring out the contents of a ``DO``   ``LOOP`` into a new definition, rework the code so that ``I`` (the index) is not referenced within the new definition, but rather passed as a stack argument to it."
msgstr ""

#: ../../chapter6.rst:215
msgid "Factoring Out Control Structures Themselves"
msgstr ""

#: ../../chapter6.rst:217
msgid "Here are two definitions whose differences lies within a ``IF``  ``THEN`` construct:"
msgstr ""

#: ../../chapter6.rst:225
msgid "The condition and control structure remain the same; only the event changes. Since you can’t factor the ``IF`` into one word and the ``THEN`` into another, the simplest thing is to factor the condition:"
msgstr ""

#: ../../chapter6.rst:236
msgid "Depending on the number of repetitions of the same condition and control structure, you may even want to factor out both. Watch this:"
msgstr ""

#: ../../chapter6.rst:246
msgid "The word ``CONDITIONALLY`` may—depending on the condition—alter the control flow so that the remaining words in each definition will be skipped. This approach has certain disadvantages as well. We’ll discuss this technique—pros and cons—in :doc:`Chapter Eight<chapter8>`."
msgstr ""

#: ../../chapter6.rst:251
msgid "More benign examples of factoring-out control structures include case statements, which eliminate nested ``IF``  ``ELSE``  ``THEN`` s, and multiple exit loops  (the ``BEGIN``  ``WHILE``  ``WHILE``  ``WHILE`` ``...``  ``REPEAT`` construct). We\\’ll also discuss these topics in :doc:`Chapter Eight<chapter8>`."
msgstr ""

#: ../../chapter6.rst:258
msgid "Factoring Out Names"
msgstr ""

#: ../../chapter6.rst:260
msgid "It’s even good to factor out names, when the names seem almost, but not quite, the same. Examine the following terrible example of code, which is meant to initialize three variables associated with each of eight channels:"
msgstr ""

#: ../../chapter6.rst:292
msgid "First there’s a similarity among the names of the variables; then there’s a similarity in the code used in all the ``INIT-CH`` words."
msgstr ""

#: ../../chapter6.rst:295
msgid "Here’s an improved rendition. The similar variable names have been factored into three data structures, and the lengthy recital of ``INIT-CH`` words has been factored into a ``DO``  ``LOOP``:"
msgstr ""

#: ../../chapter6.rst:309
msgid "That’s all the code we need."
msgstr ""

#: ../../chapter6.rst:311
msgid "Even in the most innocent cases, a little data structure can eliminate extra names. By convention Forth handles text in “counted strings” (i.e., with the count in the first byte). Any word that returns the “address of a string” actually returns this beginning address, where the count is. Not only does use of this two-element data structure eliminate the need for separate names for string and count, it also makes it easier to move a string in memory, because you can copy the string *and* the count with a single ``CMOVE``."
msgstr ""

#: ../../chapter6.rst:321
msgid "When you start finding the same awkwardness here and there, you can combine things and make the awkwardness go away."
msgstr ""

#: ../../chapter6.rst:325
msgid "Factoring Out Functions into Defining Words"
msgstr ""

#: ../../chapter6.rst:329
msgid "If a series of definitions contains identical functions, with variation only in data, use a defining word."
msgstr ""

#: ../../chapter6.rst:332
msgid "Examine the structure of this code (without worrying about its purpose—you’ll see the same example later on):"
msgstr ""

#: ../../chapter6.rst:349
msgid "The above approach is technically correct, but less memory-efficient than the following approach using defining words:"
msgstr ""

#: ../../chapter6.rst:360
msgid "(Defining words are explained in *Starting Forth*, Chapter Eleven)."
msgstr ""

#: ../../chapter6.rst:362
msgid "By using a defining word, we save memory because each compiled colon definition needs the address of ``EXIT`` to conclude the definition. (In defining eight words, the use of a defining word saves 14 bytes on a 16-bit Forth.) Also, in a colon definition each reference to a numeric literal requires the compilation of ``LIT`` (or ``literal``), another 2 bytes per definition. (If 1 and 2 are predefined constants, this costs another 10 bytes—24 total.)"
msgstr ""

#: ../../chapter6.rst:370
msgid "In terms of readability, the defining word makes it absolutely clear that all the colors it defines belong to the same family of words."
msgstr ""

#: ../../chapter6.rst:373
msgid "The greatest strength of defining words, however, arises when a series of definitions share the same *compile-time* behavior. This topic is the subject of a later section, “Compile-Time Factoring.”"
msgstr ""

#: ../../chapter6.rst:378
msgid "Factoring Criteria"
msgstr ""

#: ../../chapter6.rst:380
msgid "Armed with an understanding of factoring techniques, let’s now discuss several of the criteria for factoring Forth definitions. They include:"
msgstr ""

#: ../../chapter6.rst:384
msgid "Limiting the size of definitions"
msgstr ""

#: ../../chapter6.rst:386
msgid "Limiting repetition of code"
msgstr ""

#: ../../chapter6.rst:388
msgid "Nameability"
msgstr ""

#: ../../chapter6.rst:390
msgid "Information hiding"
msgstr ""

#: ../../chapter6.rst:392
msgid "Simplifying the command interface"
msgstr ""

#: ../../chapter6.rst:396
msgid "Keep definitions short."
msgstr ""

#: ../../chapter6.rst:406
msgid "We asked **Moore**, \"How long should a Forth definition be?\""
msgstr ""

#: ../../chapter6.rst:399
msgid "A word should be a line long. That's the target."
msgstr ""

#: ../../chapter6.rst:401
msgid "When you have a whole lot of words that are all useful in their own right---perhaps in debugging or exploring, but inevitably there's a reason for their existence---you feel you've extracted the essence of the problem and that those words have expressed it."
msgstr ""

#: ../../chapter6.rst:406
msgid "Short words give you a good feeling."
msgstr ""

#: ../../chapter6.rst:408
msgid "An informal examination of one of Moore’s applications shows that he averages seven references, including both words and numbers, per definition. These are remarkably short definitions. (Actually, his code was divided about 50–50 between one-line and two-line definitions.)"
msgstr ""

#: ../../chapter6.rst:413
msgid "Psychological tests have shown that the human mind can only focus its conscious attention on seven things, plus or minus two, at a time [miller56]_. Yet all the while, day and night, the vast resources of the mind are subconsciously storing immense amounts of data, making connections and associations and solving problems."
msgstr ""

#: ../../chapter6.rst:419
msgid "Even if out subconscious mind knows each part of an application inside out, our narrow-viewed conscious mind can only correlate seven elements of it at once. Beyond that, our grasp wavers. Short definitions match our mental capabilities."
msgstr ""

#: ../../chapter6.rst:424
msgid "Something that tempts many Forth programmers to write overly long definitions is the knowledge that headers take space in the dictionary. The coarser the factoring, the fewer the names, and the less memory that will be wasted."
msgstr ""

#: ../../chapter6.rst:429
msgid "It’s true that more memory will be used, but it’s hard to say that anything that helps you test, debug and interact with your code is a “waste.” If your application is large, try using a default width of three, with the ability to switch to a full-length name to avoid a specific collision. (“Width” refers to a limit on the number of characters stored in the name field of each dictionary header.)"
msgstr ""

#: ../../chapter6.rst:436
msgid "If the application is still too big, switch to a Forth with multiple dictionaries on a machine with extended memory, or better yet, a 32-bit Forth on a machine with 32-bit addressing."
msgstr ""

#: ../../chapter6.rst:440
msgid "A related fear is that over-factoring will decrease performance due to the overhead of Forth’s inner interpreter. Again, it’s true that there is some penalty for each level of nesting. But ordinarily the penalty for extra nesting due to proper factoring will not be noticeable. If you timings are that tight, the real solution is to translate something into assembler."
msgstr ""

#: ../../chapter6.rst:449
msgid "Factor at the point where you feel unsure about your code (where complexity approaches the conscious limit)."
msgstr ""

#: ../../chapter6.rst:452
msgid "Don’t let your ego take over with an “I can lick this!” attitude. Forth code should never feel uncomfortably complex. Factor!"
msgstr ""

#: ../../chapter6.rst:463
#: ../../chapter6.rst:513
#: ../../chapter6.rst:593
#: ../../chapter6.rst:1008
#: ../../chapter6.rst:1375
msgid "**Moore**:"
msgstr ""

#: ../../chapter6.rst:456
msgid "Feeling like you might have introduced a bug is one reason for factoring. Any time you see a doubly-nested ``DO``  ``LOOP``, that's a sign that something's wrong because it will be hard to debug. Almost always take the inner ``DO``  ``LOOP`` and make a word."
msgstr ""

#: ../../chapter6.rst:461
msgid "And having factored out a word for testing, there's no reason for putting it back. You found it useful in the first place. There's no guarantee you won't need it again."
msgstr ""

#: ../../chapter6.rst:465
msgid "Here’s another facet of the same principle:"
msgstr ""

#: ../../chapter6.rst:469
msgid "Factor at the point where a comment seems necessary"
msgstr ""

#: ../../chapter6.rst:471
msgid "Particularly if you feel a need to remind yourself what’s on the stack, this may be a good time to “make a break.”"
msgstr ""

#: ../../chapter6.rst:474
msgid "Suppose you have"
msgstr ""

#: ../../chapter6.rst:481
msgid "which begins by computing the balance and ends by displaying it. In the meantime, several lines of code use the balance for purposes of their own. Since it’s difficult to see that the balance is still on the stack when SHOW executes, the programmer has interjected a stack picture."
msgstr ""

#: ../../chapter6.rst:486
msgid "This solution is generally a sign of bad factoring. Better to write:"
msgstr ""

#: ../../chapter6.rst:494
msgid "No narrative stack pictures are needed. Furthermore, the programmer now has a reusable, testable subset of the definition."
msgstr ""

#: ../../chapter6.rst:499
msgid "Limit repetition of code."
msgstr ""

#: ../../chapter6.rst:501
msgid "The second reason for factoring, to eliminate repeated fragments of code, is even more important than reducing the size of definitions."
msgstr ""

#: ../../chapter6.rst:506
msgid "When a word is just a piece of something, it's useful for clarity or debugging, but not nearly as good as a word that is used multiple times. Any time a word is used only once you want to question its value."
msgstr ""

#: ../../chapter6.rst:511
msgid "Many times when a program has gotten too big I will go back through it looking for phrases that strike my eye as candidates for factoring. The computer can't do this; there are too many variables."
msgstr ""

#: ../../chapter6.rst:515
msgid "In looking over your work, you often find identical phrases or short passages duplicated several times. In writing an editor I found this phrase repeated several times:"
msgstr ""

#: ../../chapter6.rst:523
msgid "Because it appeared several times I factored it into a new word called ``AT``."
msgstr ""

#: ../../chapter6.rst:526
msgid "It’s up to you to recognize fragments that are coded differently but functionally equivalent, such as:"
msgstr ""

#: ../../chapter6.rst:533
msgid "The ``1-`` appears to make this phrase different from the one defined as ``AT.`` But in fact, it can be written"
msgstr ""

#: ../../chapter6.rst:540
msgid "On the other hand:"
msgstr ""

#: ../../chapter6.rst:544
msgid "When factoring out duplicate code, make sure the factored code serves a single purpose."
msgstr ""

#: ../../chapter6.rst:547
msgid "Don’t blindly seize upon duplications that may not be useful. For instance, in several places in one application I used this phrase:"
msgstr ""

#: ../../chapter6.rst:554
msgid "I turned it into a new word and called it ``LETTER``, since it returned the letter being pointed to by the interpreter."
msgstr ""

#: ../../chapter6.rst:557
msgid "In a later revision, I unexpectedly had to write:"
msgstr ""

#: ../../chapter6.rst:563
msgid "I could have used the existing ``LETTER`` were it not for its ``C@`` at the end. Rather than duplicate the bulk of the phrase in the new section, I chose to refactor ``LETTER`` to a finer resolution, taking out the ``C@``. The usage was then either ``LETTER C@`` or ``LETTER C!``. This change required me to search through the listing changing all instances of ``LETTER`` to ``LETTER C@``. But I should have done that in the first place, separating the computation of the letter’s address from the operation to be performed on the address."
msgstr ""

#: ../../chapter6.rst:573
msgid "Similar to our injunction against repetition of code:"
msgstr ""

#: ../../chapter6.rst:575
#: ../../chapter6.rst:585
msgid "latex"
msgstr ""

#: ../../chapter6.rst:577
msgid "Look for repetition of patterns."
msgstr ""

#: ../../chapter6.rst:579
msgid "If you find yourself referring back in the program to copy the pattern of previously-used words, then you may have mixed in a general idea with a specific application. The part of the pattern you are copying perhaps can be factored out as an independent definition that can be used in all the similar cases."
msgstr ""

#: ../../chapter6.rst:587
msgid "Be sure you can name what you factor."
msgstr ""

#: ../../chapter6.rst:590
msgid "If you have a concept that you can't assign a single name to, not a hyphenated name, but a name, it's not a well-formed concept. The ability to assign a name is a necessary part of decomposition. Certainly you get more confidence in the idea."
msgstr ""

#: ../../chapter6.rst:595
msgid "Compare this view with the criteria for decomposing a module espoused by structured design in :doc:`Chapter One<chapter1>`. According to that method, a module should exhibit “functional binding,” which can be verified by describing its function in a single, non-compound, *sentence*. Forth’s “atom,” a *name*, is an order of magnitude more refined."
msgstr ""

#: ../../chapter6.rst:604
msgid "Factor definitions to hide details that may change."
msgstr ""

#: ../../chapter6.rst:606
msgid "We’ve seen the value of information hiding in earlier chapters, especially with regard to preliminary design. It’s useful to remember this criterion during the implementation stage as well."
msgstr ""

#: ../../chapter6.rst:610
msgid "Here’s a very short definition that does little except hide information:"
msgstr ""

#: ../../chapter6.rst:616
msgid "This definition allows you to convert an acf (address of code field) to an apf (address of parameter field) without depending on the actual structure of a dictionary definition. If you were to use ``2+`` instead of the word ``>BODY``, you would lose transportability if you ever converted to a Forth system in which the heads were separated from the bodies. (This is one of a set of words suggested by Kim Harris, and included as an Experimental Proposal in the Forth-83 Standard [harris83]_.)"
msgstr ""

#: ../../chapter6.rst:626
msgid "Here’s a group of definitions that might be used in writing an editor:"
msgstr ""

#: ../../chapter6.rst:634
msgid "These three definitions can form the basis for all calculations of addresses necessary for moving text around. Use of these three definitions completely separates your editing algorithms from a reliance on Forth blocks."
msgstr ""

#: ../../chapter6.rst:639
msgid "What good is that? If you should decide, during development, to create an editing buffer to protect the user from making errors that destroy a block, you merely have to redefine two of these words, perhaps like this:"
msgstr ""

#: ../../chapter6.rst:649
msgid "The rest of your code can remain intact."
msgstr ""

#: ../../chapter6.rst:653
msgid "Factor functions out of definitions that display results."
msgstr ""

#: ../../chapter6.rst:655
msgid "This is really a question of decomposition."
msgstr ""

#: ../../chapter6.rst:657
msgid "Here’s an example. The word defined below, pronounced “people-to-paths,” computes how many paths of communication there are between a given number of people in a group. (This is a good thing for managers of programmer teams to know—the number of communication paths increases drastically with each new addition to the team.)"
msgstr ""

#: ../../chapter6.rst:667
msgid "This definition does the calculation only. Here’s the “user definition” that invokes ``PEOPLE>PATHS`` to perform the calculation, and then displays the result:"
msgstr ""

#: ../../chapter6.rst:676
msgid "This produces:"
msgstr ""

#: ../../chapter6.rst:685
msgid "Even if you think you’re going to perform a particular calculation only once, to display it in a certain way, believe me, you’re wrong. You will have to come back later and factor out the calculation part. Perhaps you’ll need to display the information in a right-justified column, or perhaps you’ll want to record the results in a data base—you never know. But you’ll always have to factor it, so you might as well do it right the first time. (The few times you might get away with it aren’t worth the trouble.)"
msgstr ""

#: ../../chapter6.rst:694
msgid "The word ``.`` (dot) is a prime example. Dot is great 99% of the time, but occasionally it does too much. Here’s what it does, in fact (in Forth–83):"
msgstr ""

#: ../../chapter6.rst:702
msgid "But suppose you want to convert a number on the stack into an ASCII string and store it in a buffer for typing later. Dot converts it, but also types it. Or suppose you want to format playing cards in the form ``10C`` (for “ten of clubs”). You can’t use dot to display the 10 because it prints a final space."
msgstr ""

#: ../../chapter6.rst:708
msgid "Here’s a better factoring found in some Forth systems:"
msgstr ""

#: ../../chapter6.rst:715
msgid "We find another example of failing to factor the output function from the calculation function in our own Roman numeral example in :doc:`Chapter Four<chapter4>` Four. Given our solution, we can’t store a Roman numeral in a buffer or even center it in a field. (A better approach would have been to use ``HOLD`` instead of ``EMIT``.)"
msgstr ""

#: ../../chapter6.rst:721
msgid "Information hiding can also be a reason *not* to factor. For instance, if you factor the phrase"
msgstr ""

#: ../../chapter6.rst:728
msgid "into the definition"
msgstr ""

#: ../../chapter6.rst:734
msgid "remember you are doing so only because you may want to change the location of the editing frame. Don’t blindly replace all occurrences of the phrase with the new word ``FRAME,`` because you may change the definition of ``FRAME`` and there will certainly be times when you really want ``SCR``  ``@``  ``BLOCK``."
msgstr ""

#: ../../chapter6.rst:742
msgid "If a repeated code fragment is likely to change in some cases but not others, factor out only those instances that might change. If the fragment is likely to change in more than one way, factor it into more than one definition."
msgstr ""

#: ../../chapter6.rst:747
msgid "Knowing when to hide information requires intuition and experience. Having made many design changes in your career, you’ll learn the hard way which things will be most likely to change in the future."
msgstr ""

#: ../../chapter6.rst:751
msgid "You can never predict everything, though. It would be useless to try, as we’ll see in the upcoming section called “The Iterative Approach in Implementation.”"
msgstr ""

#: ../../chapter6.rst:757
msgid "Simplify the command interface by reducing the number of commands."
msgstr ""

#: ../../chapter6.rst:759
msgid "It may seem paradoxical, but good factoring can often yield *fewer* names. In :doc:`Chapger Five<chapter5>` we saw how six simple names (``LEFT``, ``RIGHT``, ``MOTOR``, ``SOLENOID``, ``ON``, and ``OFF``) could do the work of eight badly-factored, hyphenated names."
msgstr ""

#: ../../chapter6.rst:765
msgid "As another example, I found two definitions circulating in one department in which Forth had recently introduced. Their purpose was purely instructional, to remind the programmer which vocabulary was ``CURRENT``, and which was ``CONTEXT``:"
msgstr ""

#: ../../chapter6.rst:775
msgid "If you typed"
msgstr ""

#: ../../chapter6.rst:781
msgid "the system would respond"
msgstr ""

#: ../../chapter6.rst:787
msgid "(They worked—at least on the system used there—by backing up to the name field of the vocabulary definition, and displaying it.)"
msgstr ""

#: ../../chapter6.rst:790
msgid "The obvious repetition of code struck my eye as a sign of bad factoring. It would have been possible to consolidate the repeated passage into a third definition:"
msgstr ""

#: ../../chapter6.rst:798
msgid "shortening the original definitions to:"
msgstr ""

#: ../../chapter6.rst:805
msgid "But in this approach, the only difference between the two definitions was the pointer to be displayed. Since part of good factoring is to make fewer, not more definitions, it seemed logical to have only one definition, and let it take as an argument either the word ``CONTEXT`` or the word ``CURRENT``."
msgstr ""

#: ../../chapter6.rst:811
msgid "Applying the principles of good naming, I suggested:"
msgstr ""

#: ../../chapter6.rst:817
msgid "allowing the syntax(``CONTEXT IS`` \\[:kbd:`Enter`\\])"
msgstr ""

#: ../../chapter6.rst:823
msgid "or(``CURRENT IS`` \\[:kbd:`Enter`\\])"
msgstr ""

#: ../../chapter6.rst:829
msgid "The initial clue was repetition of code, but the final result came from attempting to simplify the command interface."
msgstr ""

#: ../../chapter6.rst:832
msgid "Here’s another example. The IBM PC has four modes four displaying text only:"
msgstr ""

#: ../../chapter6.rst:835
msgid "40 column monochrome"
msgstr ""

#: ../../chapter6.rst:837
msgid "40 column color"
msgstr ""

#: ../../chapter6.rst:839
msgid "80 column monochrome"
msgstr ""

#: ../../chapter6.rst:841
msgid "80 column color"
msgstr ""

#: ../../chapter6.rst:843
msgid "The word ``MODE`` is available in the Forth system I use. ``MODE`` takes an argument between 0 and 3 and changes the mode accordingly. Of course, the phrase 0 ``MODE`` or 1 ``MODE`` doesn’t help me remember which mode is which."
msgstr ""

#: ../../chapter6.rst:848
msgid "Since I need to switch between these modes in doing presentations, I need to have a convenient set of words to effect the change. These words must also set a variable that contains the current number of columns—40 or 80."
msgstr ""

#: ../../chapter6.rst:853
msgid "Here’s the most straightforward way to fulfill the requirements:"
msgstr ""

#: ../../chapter6.rst:862
msgid "By factoring to eliminate the repetition, we come up with this version:"
msgstr ""

#: ../../chapter6.rst:872
msgid "But by attempting to reduce the number of commands, and also by following the injunctions against numerically-prefixed and hyphenated names, we realize that we can use the number of columns as a stack argument, and *calculate* the mode:"
msgstr ""

#: ../../chapter6.rst:882
msgid "This gives us this syntax:"
msgstr ""

#: ../../chapter6.rst:891
msgid "We’ve reduced the number of commands from four to two."
msgstr ""

#: ../../chapter6.rst:893
msgid "Once again, though, we have some duplicate code. If we factor out this code we get:"
msgstr ""

#: ../../chapter6.rst:903
msgid "Now we’ve achieved a nicer syntax, and at the same time greatly reduced the size of the object code. With only two commands, as in this example, the benefits may be marginal. But with larger sets of commands the benefits increase geometrically."
msgstr ""

#: ../../chapter6.rst:908
msgid "Our final example is a set of words to represent colors on a particular system. Names like ``BLUE`` and ``RED`` are nicer than numbers. One solution might be to define:"
msgstr ""

#: ../../chapter6.rst:923
msgid "These colors can be used with words such as BACKGROUND, FOREGROUND, and BORDER:"
msgstr ""

#: ../../chapter6.rst:930
msgid "But this solution requires 16 names, and many of them are hyphenated. Is there a way to simplify this?"
msgstr ""

#: ../../chapter6.rst:933
msgid "We notice that the colors between 8 and 15 are all “lighter” versions of the colors between 0 and 7. (In the hardware, the only difference between these two sets is the setting of the “intensity bit.”) If we factor out the “lightness,” we might come up with this solution:"
msgstr ""

#: ../../chapter6.rst:949
msgid "With this syntax, the word"
msgstr ""

#: ../../chapter6.rst:955
msgid "by itself will return a “1” on the stack, but the phrase"
msgstr ""

#: ../../chapter6.rst:961
msgid "will return a “9.” (The adjective LIGHT sets flag which is used by the hues, then cleared.)"
msgstr ""

#: ../../chapter6.rst:964
msgid "If necessary for readability, we still might want to define:"
msgstr ""

#: ../../chapter6.rst:971
msgid "Again, through this approach we’ve achieved a more pleasant syntax and shorter object code."
msgstr ""

#: ../../chapter6.rst:976
msgid "Don't factor for the sake of factoring. Use clich\\'es."
msgstr ""

#: ../../chapter6.rst:978
msgid "The phrase"
msgstr ""

#: ../../chapter6.rst:984
msgid "may be seen commonly in certain applications. (It converts an address and count into an ending address and starting address appropriate for a ``DO LOOP``.)"
msgstr ""

#: ../../chapter6.rst:988
msgid "Another commonly seen phrase is"
msgstr ""

#: ../../chapter6.rst:994
msgid "(It rearranges a first-number and last-number into the last-number-plus-one and first-number order required by ``DO``.)"
msgstr ""

#: ../../chapter6.rst:998
msgid "It’s a little tempting to seize upon these phrases and turn them into words, such as (for the first phrase) ``RANGE``."
msgstr ""

#: ../../chapter6.rst:1002
msgid "That particular phrase ``OVER``  ``+``   ``SWAP`` is one that's right on the margin of being a useful word. Often, though, if you define something as a word, it turns out you use it only once. If you name such a phrase, you have trouble knowing exactly what ``RANGE`` does. You can't see the manipulation in your mind. ``OVER``  ``+``   ``SWAP`` has greater mnemonic value than ``RANGE``."
msgstr ""

#: ../../chapter6.rst:1010
msgid "I call these phrases “clich\\'es.” They stick together as meaningful functions. You don’t have to remember how the phrase works, just what it does. And you don’t have to remember an extra name."
msgstr ""

#: ../../chapter6.rst:1015
msgid "Compile-Time Factoring"
msgstr ""

#: ../../chapter6.rst:1017
msgid "In the last section we looked at many techniques for organizing code and data to reduce redundancy."
msgstr ""

#: ../../chapter6.rst:1020
msgid "We can also apply limited redundancy during compilation, by letting Forth do some of out dirty work."
msgstr ""

#: ../../chapter6.rst:1025
msgid "For maximum maintainability, limit redundancy even at compile time."
msgstr ""

#: ../../chapter6.rst:1027
msgid "Suppose in our application we must draw nine boxes as shown in :numref:`fig6-1` ."
msgstr ""

#: ../../chapter6.rst:1030
msgid "What we\\'re supposed to display"
msgstr ""

#: ../../chapter6.rst:1052
msgid "In our design we need to have constants that represent values such as the size of each box, the size of the gap between boxes, and the left-most and top-most coordinates of the first box."
msgstr ""

#: ../../chapter6.rst:1056
msgid "Naturally we can define:"
msgstr ""

#: ../../chapter6.rst:1065
msgid "(Streets run east and west; avenues run north and south.)"
msgstr ""

#: ../../chapter6.rst:1067
msgid "Now, to define the left margin, we might compute it mentally, We want to center all these boxes on a screen 80 columns wide. To center something, we subtract its width from 80 and divide by two to determine the left margin. To figure the total width of all the boxes, we add"
msgstr ""

#: ../../chapter6.rst:1072
msgid "8 + 4 + 8 + 4 + 8 = 32  (three widths and two avenues). :math:`(80-31) / 2 = 24`."
msgstr ""

#: ../../chapter6.rst:1078
msgid "So we could, crudely, define:"
msgstr ""

#: ../../chapter6.rst:1084
msgid "and use the same approach for ``TOPMARGIN``."
msgstr ""

#: ../../chapter6.rst:1086
msgid "But what if we should later redesign the pattern, so that the width changed, or perhaps the gap between the boxes? We’d have to recompute the left margin ourselves."
msgstr ""

#: ../../chapter6.rst:1090
msgid "In the Forth environment, we can use the full power of Forth even when we’re compiling. Why not let Forth do the figuring?"
msgstr ""

#: ../../chapter6.rst:1100
msgid "If a constant's value depends on the value of an earlier constant, use Forth to calculate the value of the second."
msgstr ""

#: ../../chapter6.rst:1103
msgid "None of these computations are performed when the application is running, so run-time speed is not affected."
msgstr ""

#: ../../chapter6.rst:1106
msgid "Here’s another example.  :numref:`fig6-2`  shows the code for a word that draws shapes. The word ``DRAW`` emits a star at every x–y coordinate listed in the table called ``POINTS``. (Note: the word ``XY`` positions the cursor to the ( x y ) coordinate on the stack.)"
msgstr ""

#: ../../chapter6.rst:1111
msgid "Notice the line immediately following the list of points:"
msgstr ""

#: ../../chapter6.rst:1117
msgid "Another example of limiting compile-time redundancy."
msgstr ""

#: ../../chapter6.rst:1130
msgid "The phrase ``HERE POINTS -`` computes the number of x–y coordinates in the table: this value becomes the constant ``#POINTS``, used as the limit in ``DRAW`` \\’s ``DO``   ``LOOP``."
msgstr ""

#: ../../chapter6.rst:1134
msgid "This construct lets you add or subtract points from the table without worrying about the number of points there are. Forth computes this for you."
msgstr ""

#: ../../chapter6.rst:1139
msgid "Compile-Time Factoring through Defining Words"
msgstr ""

#: ../../chapter6.rst:1141
msgid "Let’s examine a series of approaches to the same problem—defining a group of related addresses. Here’s the first try:"
msgstr ""

#: ../../chapter6.rst:1153
msgid "The idea is right, but the implementation is ugly. The only elements that change from port to port are the numeric offset and the name of the port being defined; everything else repeats. This repetition suggests the use of a defining word."
msgstr ""

#: ../../chapter6.rst:1158
msgid "The following approach, which is more readable, combines all the repeated code into the “does” part of a defining word:"
msgstr ""

#: ../../chapter6.rst:1170
msgid "In this solution we’re performing the offset calculation at *run*-time, every time we invoke one of these names. It would be more efficient to perform the calculation at compile time, like this:"
msgstr ""

#: ../../chapter6.rst:1183
msgid "Here we’ve created a defining word, ``PORT``, that has a unique *compile*-time behavior, namely adding the offset to ``BASE.PORT.ADDRESS`` and defining a ``CONSTANT``."
msgstr ""

#: ../../chapter6.rst:1187
msgid "We might even go one step further. Suppose that all port addresses are two bytes apart. In this case there’s no reason we should have to specify these offsets. The numeric sequence"
msgstr ""

#: ../../chapter6.rst:1191
msgid "0 2 4 6"
msgstr ""

#: ../../chapter6.rst:1193
msgid "is itself redundant."
msgstr ""

#: ../../chapter6.rst:1195
msgid "In the following version, we begin with the ``BASE.PORT.ADDRESS`` on the stack. The defining word ``PORT`` duplicates this address, makes a constant out of it, then adds 2 to the address still on the stack, for the next invocation of ``PORT``."
msgstr ""

#: ../../chapter6.rst:1211
msgid "Notice we must supply the initial port address on the stack before defining the first port, then invoke ``DROP`` when we’ve finished defining all the ports to get rid of the port address that’s still on the stack."
msgstr ""

#: ../../chapter6.rst:1216
msgid "One final comment. The base-port address is very likely to change, and therefore should be defined in only one place. This does *not* mean it has to be defined as a constant. Provided that the base-port address won’t be used outside of this lexicon of port names, it’s just as well to refer to it by number here."
msgstr ""

#: ../../chapter6.rst:1233
msgid "The Iterative Approach in Implementation"
msgstr ""

#: ../../chapter6.rst:1235
msgid "Earlier in the book we discussed the iterative approach, paying particular attention to its impact on the design phase. Now that we’re talking about implementation, let’s see how the approach is actually used in writing code."
msgstr ""

#: ../../chapter6.rst:1243
msgid "Work on only one aspect of a problem at a time."
msgstr ""

#: ../../chapter6.rst:1245
msgid "Suppose we’re entrusted with the job of coding a word to draw or erase a box at a given x–y coordinate. (This is the same problem we introduced in the section called “Compile-Time Factoring.”)"
msgstr ""

#: ../../chapter6.rst:1249
msgid "At first we focus our attention on the problem of drawing a box—never mind erasing it. We might come up with this:"
msgstr ""

#: ../../chapter6.rst:1259
msgid "Having tested this to make sure it works correctly, we turn now to the problem of using the same code to *un*\\ draw a box. The solution is simple: instead of hard-coding the ``ASCII *`` we\\’d like to change the emitted character from an asterisk to a blank. This requires the addition of a variable, and some readable words for setting the contents of the variable. So:"
msgstr ""

#: ../../chapter6.rst:1273
msgid "The definition of ``BOX``, along with the remainder of the application, remains the same."
msgstr ""

#: ../../chapter6.rst:1276
msgid "This approach allows the syntax"
msgstr ""

#: ../../chapter6.rst:1282
msgid "or"
msgstr ""

#: ../../chapter6.rst:1288
msgid "By switching from an explicit value to a variable that contains a value, we’ve added a level of indirection. In this case, we’ve added indirection “backwards,” adding a new level of complexity to the definition of ``LAYER`` without substantially lengthening the definition."
msgstr ""

#: ../../chapter6.rst:1293
msgid "By concentrating on one dimension of the problem at a time, you can solve each dimension more efficiently. If there’s an error in your thinking, the problem will be easier to see if it’s not obscured by yet another untried, untested aspect of your code."
msgstr ""

#: ../../chapter6.rst:1300
msgid "Don't change too much at once."
msgstr ""

#: ../../chapter6.rst:1302
msgid "While you’re editing your application—adding a new feature or fixing something—it’s often tempting to go and fix several other things at the same time. Our advice: Don’t."
msgstr ""

#: ../../chapter6.rst:1306
msgid "Make as few changes as you can each time you edit-compile. Be sure to test the results of each revision before going on. You’d be amazed how often you can make three innocent modifications, only to recompile and have nothing work!"
msgstr ""

#: ../../chapter6.rst:1311
msgid "Making changes one at a time ensures that when it stops working, you know why."
msgstr ""

#: ../../chapter6.rst:1316
msgid "Don't try to anticipate ways to factor too early."
msgstr ""

#: ../../chapter6.rst:1318
msgid "Some people wonder why most Forth systems don’t include the definition word ARRAY. This rule is the reason."
msgstr ""

#: ../../chapter6.rst:1323
msgid "I often have a class of things called arrays. The simplest array merely adds a subscript to an address and gives you back an address. You can define an array by saying"
msgstr ""

#: ../../chapter6.rst:1331
msgid "then saying"
msgstr ""

#: ../../chapter6.rst:1337
msgid "Or you can say"
msgstr ""

#: ../../chapter6.rst:1343
msgid "One of the problems that\\'s most frustrating for me is knowing whether it\\'s worth creating a defining word for a particular data structure. Will I have enough instances to justify it?"
msgstr ""

#: ../../chapter6.rst:1347
msgid "I rarely know in advance if I\\'m going to have more than one array. So I don't define the word ``ARRAY``."
msgstr ""

#: ../../chapter6.rst:1350
msgid "After I discover I need two arrays, the question is marginal."
msgstr ""

#: ../../chapter6.rst:1352
msgid "If I need three then it\\'s clear. Unless they\\'re different. And odds are they will be different. You may want it to fetch it for you. You may want a byte array, or a bit array. You may want to do bounds checking, or store its current length so you can add things to the end."
msgstr ""

#: ../../chapter6.rst:1358
msgid "I grit my teeth and say, \"Should I make the byte array into a cell array, just to fit the data structure into the word I already have available?\""
msgstr ""

#: ../../chapter6.rst:1362
msgid "The more complex the problem, the less likely it will be that you\\'ll find a universally applicable data structure. The number of instances in which a truly complex data structure has found universal use is very small. One example of a successful complex data structure is the Forth dictionary. Very firm structure, great versatility. It's used everywhere in Forth. But that\\s rare."
msgstr ""

#: ../../chapter6.rst:1369
msgid "If you choose to define the word ``ARRAY``, you\\'ve done a decomposition step. You've factored out the concept of an array from all the words you\\'ll later back in. And you've gone to another level of abstraction."
msgstr ""

#: ../../chapter6.rst:1374
msgid "Building levels of abstraction is a dynamic process, not one you can predict."
msgstr ""

#: ../../chapter6.rst:1379
msgid "Today, make it work. Tomorrow, optimize it."
msgstr ""

#: ../../chapter6.rst:1404
msgid "Again **Moore**. On the day of this interview, Moore had been completing work on the design of a board-level Forth computer, using commercially available ICs. As part of his toolkit for designing the board, he created a simulator in Forth, to test the board\\'s logic:"
msgstr ""

#: ../../chapter6.rst:1382
msgid "This morning I realized I\\'ve been mixing the descriptions of the chips with the placement of the chips on the board. This perfectly convenient for my purposes at the moment, but when I come up with another board that I want to use the same chips for, I have arranged things very badly."
msgstr ""

#: ../../chapter6.rst:1388
msgid "I should have factored it with the descriptions here and the uses there. I would then have had a chip description language. Okay. At the time I was doing this I was not interested in that level of optimization."
msgstr ""

#: ../../chapter6.rst:1393
msgid "Even if the thought had occurred to me then, I probably would have said, \"All right, I'll do that later,\" then gone right ahead with what I was doing. Optimization wasn't the most important thing to me at the time."
msgstr ""

#: ../../chapter6.rst:1398
msgid "Of course I try to factor things well. But if there doesn't seem to be a good way to do something, I say, \"Let's just make it work.\""
msgstr ""

#: ../../chapter6.rst:1401
msgid "My motivation isn't laziness, it's knowing that there are other things coming down the pike that are going to affect this decision in ways I can't predict. Trying to optimize this now is foolish. Until I get the whole picture in front of me, I can't know what the optimum is."
msgstr ""

#: ../../chapter6.rst:1406
msgid "The observations in this section shouldn’t contradict what’s been said before about information hiding and about anticipating elements that may change. A good programmer continually tries to balance the expense of building-in changeability against the expense of changing things later if necessary."
msgstr ""

#: ../../chapter6.rst:1412
msgid "These decisions take experience. But as a general rule:"
msgstr ""

#: ../../chapter6.rst:1416
msgid "Anticipate things-that-may-change by organizing information, not by adding complexity. Add complexity only as necessary to make the current iteration work."
msgstr ""

#: ../../chapter6.rst:1421
msgid "Summary"
msgstr ""

#: ../../chapter6.rst:1423
msgid "In this chapter we’ve discussed various techniques and criteria for factoring. We also examined how the iterative approach applies to the implementation phase."
msgstr ""

#: ../../chapter6.rst:1428
msgid "REFERNCES"
msgstr ""

#: ../../chapter6.rst:1430
msgid "W.P. Stevens, G.J. Myers,and L.L. Constantine, ** IBM Systems Journal** , vol. 13, no. 2, 1974, Copyright 1974 byInternational Business Machines Corporation."
msgstr ""

#: ../../chapter6.rst:1431
msgid "G.A. Miller, \"The Magical Number Seven, Plus orMinus Two: Some Limits on our Capacity for Processing Information,\" **Psychol. Rev** ., vol. 63, pp. 81-97, Mar. 1956."
msgstr ""

#: ../../chapter6.rst:1432
msgid "Kim R. Harris, \"Definition Field AddressConversion Operators,\"  **Forth--83 Standard** , Forth StandardsTeam."
msgstr ""

