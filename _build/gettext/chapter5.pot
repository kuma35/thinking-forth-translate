# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Leo Brodie
# This file is distributed under the same license as the Thinking Forth package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Thinking Forth 0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-01 21:04+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../chapter5.rst:4
msgid "5. Implementation: Elements of Forth Style"
msgstr ""

#: ../../chapter5.rst:6
msgid "Badly written Forth has been accused of looking like “code that went through a trash compactor.” It’s true, Forth affords more freedom in the way we write applications. But that freedom also gives us a chance to write exquisitely readable and easily maintainable code, provided we consciously employ the elements of good Forth style."
msgstr ""

#: ../../chapter5.rst:13
msgid "In this chapter we’ll delve into Forth coding convention including:"
msgstr ""

#: ../../chapter5.rst:15
msgid "listing organization"
msgstr ""

#: ../../chapter5.rst:17
msgid "screen layout, spacing and indentation"
msgstr ""

#: ../../chapter5.rst:19
msgid "commenting"
msgstr ""

#: ../../chapter5.rst:21
msgid "choosing names"
msgstr ""

#: ../../chapter5.rst:23
msgid "I wish I could recommend a list of hard-and-fast conventions for everyone. Unfortunately, such a list may be inappropriate in many situations. This chapter merges many widely-adopted conventions with personal preferences, commented with alternate ideas and the reasons for the preferences. In other words:"
msgstr ""

#: ../../chapter5.rst:33
msgid "I’d especially like to thank Kim Harris, who proposed many of the conventions described in this chapter, for his continuing efforts at unifying divergent views on good Forth style."
msgstr ""

#: ../../chapter5.rst:39
msgid "Listing Organization"
msgstr ""

#: ../../chapter5.rst:41
msgid "A well-organized book has clearly defined chapters, with clearly defined sections, and a table of contents to help you see the organization at a glance. A well-organized book is easy to read. A badly organized book makes comprehension more difficult, and makes finding information later on nearly impossible."
msgstr ""

#: ../../chapter5.rst:52
msgid "I still don't see how these programming conventions enhance readability."
msgstr ""

#: ../../chapter5.rst:54
msgid "The necessity for good organization applies to an application listing as well. Good organization has three aspects:"
msgstr ""

#: ../../chapter5.rst:57
#: ../../chapter5.rst:64
msgid "Decomposition"
msgstr ""

#: ../../chapter5.rst:59
#: ../../chapter5.rst:81
msgid "Composition"
msgstr ""

#: ../../chapter5.rst:61
msgid "Disk partitioning"
msgstr ""

#: ../../chapter5.rst:66
msgid "As we’ve already seen, the organization of a listing should follow the decomposition of the application into lexicons. Generally these lexicons should be sequenced in “uses” order. Lexicons being *used* should precede the lexicons which *use* them."
msgstr ""

#: ../../chapter5.rst:71
msgid "On a larger scale, elements in a listing should be organized by degree of complexity, with the most complex variations appearing towards the end. It’s best to arrange things so that you can leave off the lattermost screens (i.e., not load them) and still have a self-sufficient, running application, working properly except for the lack of the more advanced features."
msgstr ""

#: ../../chapter5.rst:78
msgid "We discussed the art of decomposition extensively in :doc:`Chapter Three<chapter3>`."
msgstr ""

#: ../../chapter5.rst:83
msgid "Composition is the putting together of pieces to create a whole. Good composition requires as much artistry as good decomposition."
msgstr ""

#: ../../chapter5.rst:86
msgid "One of Forth’s present conventions is that source code resides in “screens,” which are 1K units of mass storage. (The term “screen” refers to a block used specifically for source code.) It’s possible in Forth to chain every screen of code to the next, linking the entire listing together linearly like a lengthy parchment scroll. This is not a useful approach. Instead:"
msgstr ""

#: ../../chapter5.rst:95
msgid "Structure your application listing like a book: hierarchically."
msgstr ""

#: ../../chapter5.rst:97
msgid "An application may consist of:"
msgstr ""

#: ../../chapter5.rst:100
msgid "Screens:"
msgstr ""

#: ../../chapter5.rst:100
msgid "the smallest unit of Forth source"
msgstr ""

#: ../../chapter5.rst:103
msgid "Lexicons:"
msgstr ""

#: ../../chapter5.rst:103
msgid "one to three screens, enough to implement a component"
msgstr ""

#: ../../chapter5.rst:106
msgid "Chapters:"
msgstr ""

#: ../../chapter5.rst:106
msgid "a series of related lexicons, and"
msgstr ""

#: ../../chapter5.rst:110
msgid "Load screens:"
msgstr ""

#: ../../chapter5.rst:109
msgid "analogous to a table of contents, a screen that loads the chapters in the proper sequence."
msgstr ""

#: ../../chapter5.rst:112
msgid "Example of an application-load screen"
msgstr ""

#: ../../chapter5.rst:114
msgid "Screen #1"
msgstr ""

#: ../../chapter5.rst:132
msgid "Application-load Screen"
msgstr ""

#: ../../chapter5.rst:134
msgid ":numref:`fig5-1`  is an example of an application-load screen. Since it resides in Screen 1, you can load this entire application by entering"
msgstr ""

#: ../../chapter5.rst:142
msgid "The individual load commands within this screen load the chapters of the application. For instance, Screen 12 is the load screen for the video primitives chapter."
msgstr ""

#: ../../chapter5.rst:146
msgid "As a reference tool, the application-load screen tells you where to find all of the chapters. For instance, if you want to look at the routines that do framing, you can see that the section starts at Screen 90."
msgstr ""

#: ../../chapter5.rst:150
msgid "Each chapter-load screen in turn, loads all of the screens comprising the chapter. We’ll study some formats for chapter-load screens shortly."
msgstr ""

#: ../../chapter5.rst:153
msgid "The primary benefit of this hierarchical scheme is that you can load any section, or any screen by itself, without having to load the entire application. Modularity of the source code is one of the reasons for Forth’s quick turnaround time for editing, loading, and testing (necessary for the iterative approach). Like pages of a book, each screen can be accessed individually and quickly. It’s a “random access” approach to source-code maintenance."
msgstr ""

#: ../../chapter5.rst:161
msgid "You can also replace any passage of code with a new, trial version by simply changing the screen numbers in the load screen. You don’t have to move large passages of source code around within a file."
msgstr ""

#: ../../chapter5.rst:165
msgid "In small applications, there may not be such things as chapters. The application-load screen will directly load all the lexicons. In larger applications, however, the extra level of hierarchy can improve maintainability. A screen should either be a load-screen or a code-screen, not a mixture. Avoid embedding a ``LOAD`` or ``THRU`` command in the middle of a screen containing definitions just because you “need something” or because you “ran out of room.”"
msgstr ""

#: ../../chapter5.rst:175
msgid "Skip Commands"
msgstr ""

#: ../../chapter5.rst:177
msgid "Two commands make it easy to control what gets loaded in each screen and what gets ignored. They are:"
msgstr ""

#: ../../chapter5.rst:180
msgid "``\\``"
msgstr ""

#: ../../chapter5.rst:181
msgid "``\\`` S also called ``EXIT``"
msgstr ""

#: ../../chapter5.rst:183
msgid "\\\\ is pronounced “skip-line.” It causes the Forth interpreter to ignore everything to the right of it on the same line. (Since ``\\`` is a Forth word, it must be followed by a space.) It does not require a delimiter."
msgstr ""

#: ../../chapter5.rst:188
msgid "In :numref:`fig5-1` , you see ``\\`` used in two ways: to begin the screen-comment line (Line 0), and to begin comments on individual lines which have no more code to the right of the comment."
msgstr ""

#: ../../chapter5.rst:192
msgid "During testing, ``\\`` also serves to temporarily “paren out” lines that already contain a right parenthesis in a name or comment. For instance, these two “skip-line”s keep the definition of ``NUTATE`` from being compiled without causing problems in encountering either right parenthesis:"
msgstr ""

#: ../../chapter5.rst:203
msgid "``\\S`` is pronounced “skip-screen.” It causes the Forth interpreter to stop interpreting the screen entirely, as though there were nothing else in the screen beyond ``\\S``."
msgstr ""

#: ../../chapter5.rst:207
msgid "In many Forth systems, this function is the same as ``EXIT``, which is the run-time routine for semicolon. In these systems the use of ``EXIT`` is acceptable. Some Forth systems, however, require for internal reasons a different routine for the “skip-screen” function."
msgstr ""

#: ../../chapter5.rst:213
msgid "Definitions for ``\\`` and ``\\S`` can be found in :doc:`Appendix C<appendixc>`."
msgstr ""

#: ../../chapter5.rst:216
msgid "Chapter-load Screens"
msgstr ""

#: ../../chapter5.rst:218
msgid ":numref:`fig5-2`  illustrates a typical chapter-load screen. The screens loaded by this screen are referred to relatively, not absolutely as they were in the application-load screen."
msgstr ""

#: ../../chapter5.rst:222
msgid "This is because the chapter-load screen is the first screen of the contiguous range of screens in the chapter. You can move an entire chapter forward or backward within the listing; the relative pointers in the chapter-load screen are position-independent. All you have to change is the single number in the application-load screen that points to the beginning of the chapter."
msgstr ""

#: ../../chapter5.rst:229
msgid "Example of a chapter-load screen."
msgstr ""

#: ../../chapter5.rst:231
msgid "Screen #100"
msgstr ""

#: ../../chapter5.rst:247
msgid "Use absolute screen numbers in the application-load screen.  Use relative screen numbers in the chapter- or section-load screens."
msgstr ""

#: ../../chapter5.rst:250
msgid "There are two ways to implement relative loading. The most common is to define:"
msgstr ""

#: ../../chapter5.rst:257
msgid "and"
msgstr ""

#: ../../chapter5.rst:264
msgid "My own way, which I submit as a more useful factoring, requires a single word, ``FH`` (see :doc:`Appendix C<appendixc>` for its definition)."
msgstr ""

#: ../../chapter5.rst:267
msgid "The phrase"
msgstr ""

#: ../../chapter5.rst:273
msgid "is read “1 from here ``LOAD``,” and is equivalent to 1 ``+LOAD``."
msgstr ""

#: ../../chapter5.rst:275
msgid "Similarly,"
msgstr ""

#: ../../chapter5.rst:281
msgid "is read “2 from here, 5 from here ``THRU``.”"
msgstr ""

#: ../../chapter5.rst:283
msgid "Some programmers begin each chapter with a dummy word; e.g.,"
msgstr ""

#: ../../chapter5.rst:289
msgid "and list its name in the comment on the line where the chapter is loaded in the application-load screen. This permits selectively ``FORGET`` ting any chapter and reloading from that point on without having to look at the chapter itself."
msgstr ""

#: ../../chapter5.rst:294
msgid "Within a chapter the first group of screens will usually define those variables, constants, and other data structures needed globally within the chapter. Following that will come the lexicons, loaded in “uses” order. The final lines of the chapter-load screen normally invoke any needed initialization commands."
msgstr ""

#: ../../chapter5.rst:300
msgid "Some of the more style-conscious Forthwrights begin each chapter with a “preamble” that discusses in general terms the theory of operation for the components described in the chapter. :numref:`fig5-3`  is a sample preamble screen which demonstrates the format required at Moore Products Co."
msgstr ""

#: ../../chapter5.rst:306
msgid "Moore Products Co.'s format for chapter preambles."
msgstr ""

#: ../../chapter5.rst:308
msgid "Screen #101"
msgstr ""

#: ../../chapter5.rst:325
msgid "Screen #102"
msgstr ""

#: ../../chapter5.rst:349
msgid "**Charles Moore** (no relation to Moore Products Co.) places less importance on the well-organized hierarchical listing than I do. Moore:"
msgstr ""

#: ../../chapter5.rst:342
msgid "I structure **applications** hierarchically, but not necessarily **listings.**  My listings are organized in a fairly sloppy way, not at all hierarchically in the sense of primitives first."
msgstr ""

#: ../../chapter5.rst:346
msgid "I use ``LOCATE`` [also known as ``VIEW``; see the Handy Hint in **Starting Forth**, Chapter Nine].  As a result, the listing is much less carefully organized because I have ``LOCATE`` to find things for me.  I never look at listings."
msgstr ""

#: ../../chapter5.rst:352
msgid "––> vs. THRU"
msgstr ""

#: ../../chapter5.rst:354
msgid "On the subject of relative loading, one popular way to load a series of adjacent screens is with the word ``-->`` (pronounced “next block”). This word causes the interpreter to immediately cease interpreting the current screen and begin interpreting the next (higher-numbered) screen."
msgstr ""

#: ../../chapter5.rst:360
msgid "If your system provides ``-->``, you must choose between using the ``THRU`` command in your chapter-load screen to load each series of screens, or linking each series together with the arrows and LOADing only the first in the series. (You can’t do both; you’d end up loading most of the screens more than once.)"
msgstr ""

#: ../../chapter5.rst:367
msgid "The nice thing about the arrows is this: suppose you change a screen in the middle of a series, then reload the screen. The rest of the series will automatically get loaded. You don’t have to know what the last screen is."
msgstr ""

#: ../../chapter5.rst:372
msgid "That’s also the nasty thing about the arrows: There’s no way to stop the loading process once it starts. You may compile a lot more screens than you need to test this one screen."
msgstr ""

#: ../../chapter5.rst:376
msgid "To get analytical about it, there are three things you might want to do after making the change just described:"
msgstr ""

#: ../../chapter5.rst:379
msgid "load the one screen only, to test the change,"
msgstr ""

#: ../../chapter5.rst:381
msgid "load the entire section in which the screen appears,"
msgstr ""

#: ../../chapter5.rst:383
#: ../../chapter5.rst:1296
#: ../../chapter5.rst:1697
#: ../../chapter5.rst:2031
msgid "or"
msgstr ""

#: ../../chapter5.rst:385
msgid "load the entire remainder of the application."
msgstr ""

#: ../../chapter5.rst:387
msgid "The use of ``THRU`` seems to give you the greatest control."
msgstr ""

#: ../../chapter5.rst:390
msgid "Some people consider the arrow to be useful for letting definitions cross screen boundaries. In fact ``-->`` is the only way to compile a high-level (colon) definition that occupies more than one screen, because ``-->`` is “immediate.” But it’s *never* good style to let a colon definition cross screen boundaries. (They should never be that long!)"
msgstr ""

#: ../../chapter5.rst:396
msgid "On the other hand, an extremely complicated and time-critical piece of assembler coding might occupy several sequential screens. In this case, though, normal ``LOAD`` ing will do just as well, since the assembler does not use compilation mode, and therefore does not require immediacy."
msgstr ""

#: ../../chapter5.rst:402
msgid "Finally, the arrow wastes an extra line of each source screen. We don’t recommend it."
msgstr ""

#: ../../chapter5.rst:406
msgid "An Alternative to Screens: Source in Named Files"
msgstr ""

#: ../../chapter5.rst:408
msgid "Some Forth practitioners advocate storing source code in variable-length, named text files, deliberately emulating the approach used by traditional compilers and editors. This approach may become more and more common, but its usefulness is still controversial."
msgstr ""

#: ../../chapter5.rst:414
msgid "Sure, it’s nice not to have to worry about running out of room in a screen, but the hassle of writing in a restricted area is compensated for by retaining control of discrete chunks of code. In developing an application, you spend a lot more time loading and reloading screens than you do rearranging their contents."
msgstr ""

#: ../../chapter5.rst:420
msgid "“Infinite-length” files allow sloppy, disorganized thinking and bad factoring. Definitions become longer without the discipline imposed by the 1K block boundaries. The tendency becomes to write a 20K file, or worse: a 20K definition."
msgstr ""

#: ../../chapter5.rst:425
msgid "Perhaps a nice compromise would be a file-based system that allows nested loading, and encourages the use of very small named files. Most likely, though, the more experienced Forth programmers would not use named files longer than 5K to 10K. So what’s the benefit?"
msgstr ""

#: ../../chapter5.rst:431
msgid "Some might answer that rhetorical question: “It’s easier to remember names than numbers.” If that’s so, then predefine those block numbers as constants, e.g.:"
msgstr ""

#: ../../chapter5.rst:439
msgid "Then to load the “framing” section, enter"
msgstr ""

#: ../../chapter5.rst:445
msgid "Or, to list the section’s load block, enter"
msgstr ""

#: ../../chapter5.rst:451
msgid "(It’s a convention that names of sections end in “ING.”)"
msgstr ""

#: ../../chapter5.rst:453
msgid "Of course, to minimize the hassle of the screen-based approach you need good tools, including editor commands that move lines of source from one screen to another, and words that slide a series of screens forward or back within the listing."
msgstr ""

#: ../../chapter5.rst:459
msgid "Disk Partitioning"
msgstr ""

#: ../../chapter5.rst:461
msgid "The final aspect of the well-organized listing involves standardizing an arrangement for what goes where on the disk. These standards must be set by each shop, or department, or individual programmer, depending on the nature of the work."
msgstr ""

#: ../../chapter5.rst:467
msgid "Example of a disk-partitioning scheme within one department."
msgstr ""

#: ../../chapter5.rst:471
msgid "Screen 0"
msgstr ""

#: ../../chapter5.rst:472
msgid "is the title screen, showing the name of the application, the current release number, and primary author."
msgstr ""

#: ../../chapter5.rst:474
msgid "Screen 1"
msgstr ""

#: ../../chapter5.rst:475
msgid "is the application-load block."
msgstr ""

#: ../../chapter5.rst:476
msgid "Screen 2"
msgstr ""

#: ../../chapter5.rst:477
msgid "is reserved for possible continuation from Screen 1"
msgstr ""

#: ../../chapter5.rst:478
msgid "Screen 4 and 5"
msgstr ""

#: ../../chapter5.rst:479
msgid "contain system messages."
msgstr ""

#: ../../chapter5.rst:480
msgid "Screens 9 thru 29"
msgstr ""

#: ../../chapter5.rst:481
msgid "incorporate general utilities needed in, but not restricted to, this application."
msgstr ""

#: ../../chapter5.rst:483
msgid "Screen 30"
msgstr ""

#: ../../chapter5.rst:484
msgid "begins the application screens."
msgstr ""

#: ../../chapter5.rst:486
msgid ":numref:`fig5-4`  shows a typical department’s partitioning scheme."
msgstr ""

#: ../../chapter5.rst:488
msgid "In many Forth shops it’s considered desirable to begin sections of code on screen numbers that are evenly divisible by three. Major divisions on a disk should be made on boundaries evenly divisible by thirty."
msgstr ""

#: ../../chapter5.rst:493
msgid "The reason? By convention, Forth screens are printed three to a page, with the top screen always evenly divisible by three. Such a page is called a “triad;” most Forth systems include the word ``TRIAD`` to produce it, given as an argument the number of any of the three screens in the triad. For instance, if you type"
msgstr ""

#: ../../chapter5.rst:503
msgid "you’ll get a page that includes 75, 76, and 77."
msgstr ""

#: ../../chapter5.rst:505
msgid "The main benefit of this convention is that if you change a single screen, you can slip the new triad right into your binder containing the current listing, replacing exactly one page with no overlapping screens."
msgstr ""

#: ../../chapter5.rst:509
msgid "Similarly, the word ``INDEX`` lists the first line of each screen, 60 per page, on boundaries evenly divisible by 60."
msgstr ""

#: ../../chapter5.rst:514
msgid "Begin sections or lexicons on screen numbers evenly divisible by three. Begin applications or chapters on screen numbers evenly divisible by thirty."
msgstr ""

#: ../../chapter5.rst:519
msgid "Electives"
msgstr ""

#: ../../chapter5.rst:521
msgid "Vendors of Forth systems have a problem. If they want to include every command that the customer might expect—words to control graphics, printers, and other niceties—they often find that the system has swollen to more than half the memory capacity of the computer, leaving less room for serious programmers to compile their applications. The solution is for the vendor to provide the bare bones as a precompiled nucleus, with the extra goodies provided in *source* form. This approach allows the programmer to pick and choose the special routines actually needed."
msgstr ""

#: ../../chapter5.rst:531
msgid "These user-loadable routines are called “electives.” Double-length arithmetic, date and time support, ``CASE`` statements and the ``DOER/MAKE`` construct (described later) are some of the features that Forth systems should offer as electives."
msgstr ""

#: ../../chapter5.rst:537
msgid "Screen Layout"
msgstr ""

#: ../../chapter5.rst:539
msgid "In this section we’ll discuss the layout of each source screen."
msgstr ""

#: ../../chapter5.rst:543
msgid "Reserve Line 0 as a \"comment line.\""
msgstr ""

#: ../../chapter5.rst:545
msgid "The comment line serves both as a heading for the screen, and also as a line in the disk ``INDEX``. It should describe the purpose of the screen (not list the words defined therein)."
msgstr ""

#: ../../chapter5.rst:549
msgid "The comment line minimally contains the name of the screen. In larger applications, you may also include both the chapter name and screen name. If the screen is one of a series of screens implementing a lexicon, you should include a “page number” as well."
msgstr ""

#: ../../chapter5.rst:554
msgid "The upper right hand corner is reserved for the “stamp.” The stamp includes the date of latest revision and, when authorship is important, the programmer’s initials (three characters to the left of the date); e.g.:"
msgstr ""

#: ../../chapter5.rst:563
msgid "Some Forth editors will enter the stamp for you at the press of a key."
msgstr ""

#: ../../chapter5.rst:565
msgid "A common form for representing dates is"
msgstr ""

#: ../../chapter5.rst:571
msgid "that is, February 6, 1984 would be expressed"
msgstr ""

#: ../../chapter5.rst:577
msgid "An increasingly popular alternative uses"
msgstr ""

#: ../../chapter5.rst:583
msgid "where “Mmm” is a three-letter abbreviation of the month. For instance:"
msgstr ""

#: ../../chapter5.rst:589
msgid "This form requires fewer characters than"
msgstr ""

#: ../../chapter5.rst:595
msgid "and eliminates possible confusion between dates and months."
msgstr ""

#: ../../chapter5.rst:597
msgid "If your system has ``\\`` (“skip-line”—see :doc:`Appendix C<appendixc>`), you can write the comment line like this:"
msgstr ""

#: ../../chapter5.rst:604
msgid "As with all comments, use lower-case or a mixture of lower- and upper-case text in the comment line."
msgstr ""

#: ../../chapter5.rst:607
msgid "One way to make the index of an application reveal more about the organization of the screens is to indent the comment line by three spaces in screens that continue a lexicon.  :numref:`fig5-5` shows a portion of a list produced by ``INDEX`` in which the comment lines for the continuing screens are indented."
msgstr ""

#: ../../chapter5.rst:616
msgid "The output of ``INDEX`` showing indented comment lines."
msgstr ""

#: ../../chapter5.rst:636
msgid "Begin all definitions at the left edge of the screen, and define only one word per line."
msgstr ""

#: ../../chapter5.rst:639
msgid "*Bad:*"
msgstr ""

#: ../../chapter5.rst:645
#: ../../chapter5.rst:785
#: ../../chapter5.rst:798
#: ../../chapter5.rst:811
#: ../../chapter5.rst:1392
msgid "*Good:*"
msgstr ""

#: ../../chapter5.rst:652
msgid "This rule makes it easier to find a definition in the listing. (When definitions continue for more than one line, the subsequent lines should always be indented.) ``VARIABLE`` s and ``CONSTANT`` s should also be defined one per line. (See “Samples of Good Commenting Style” in :doc:`Appendix E<appendixe>`) This leaves room for an explanatory comment on the same line. The exception is a large “family” of words (defined by a common defining-word) which do not need unique comments:"
msgstr ""

#: ../../chapter5.rst:668
msgid "Leave lots of room at the bottom of the screen for later additions."
msgstr ""

#: ../../chapter5.rst:670
msgid "On your first pass, fill each screen no more than half with code. The iterative approach demands that you sketch out the components of your application first, then iteratively flesh them out until all the requirements are satisfied. Usually this means adding new commands, or adding special-case handling, to existing screens. (Not *always,* though. A new iteration may see a simplification of the code. Or a new complexity may really belong in another component and should be factored out, into another screen.)"
msgstr ""

#: ../../chapter5.rst:679
msgid "Leaving plenty of room at the outset makes later additions more pleasant. One writer recommends that on the initial pass, the screen should contain about 20–40 percent code and 80–60 percent whitespace [stevenson81]_ ."
msgstr ""

#: ../../chapter5.rst:684
msgid "Don’t skip a line between each definition. You may, however, skip a line between *groups* of definitions."
msgstr ""

#: ../../chapter5.rst:689
msgid "All screens must leave ``BASE`` set to ``DECIMAL``."
msgstr ""

#: ../../chapter5.rst:691
msgid "Even if you have three screens in a row in which the code is written in ``HEX`` (three screens of assembler code, for instance), each screen must set ``BASE`` to ``HEX`` at the top, and restore base to ``DECIMAL`` at the bottom. This rule ensures that each screen could be loaded separately, for purposes of testing, without mucking up the state of affairs. Also, in reading the listing you know that values are in decimal unless the screen explicitly says ``HEX``."
msgstr ""

#: ../../chapter5.rst:700
msgid "Some shops take this rule even further. Rather than brashly resetting base to ``DECIMAL`` at the end, they reset base to *whatever it was at the beginning.* This extra bit of insurance can be accomplished in this fashion:"
msgstr ""

#: ../../chapter5.rst:713
msgid "Sometimes an argument is passed on the stack from screen to screen, such as the value returned by ``BEGIN`` or ``IF`` in a multiscreen assembler definition, or the base address passed from one defining word to another—see “Compile-Time Factoring” in :doc:`Chapter Six<chapter6>`. In these cases, it’s best to save the value of ``BASE`` on the return stack like this:"
msgstr ""

#: ../../chapter5.rst:726
msgid "Some folks make it a policy to use this approach on any screen that changes ``BASE``, so they don’t have to worry about it."
msgstr ""

#: ../../chapter5.rst:729
msgid "Moore prefers to define ``LOAD`` to invoke ``DECIMAL`` after loading. This approach simplifies the screen’s contents because you don’t have to worry about resetting."
msgstr ""

#: ../../chapter5.rst:734
msgid "Spacing and Indentation"
msgstr ""

#: ../../chapter5.rst:738
msgid "Spacing and indentation are essential for readability."
msgstr ""

#: ../../chapter5.rst:740
msgid "The examples in this book use widely accepted conventions of spacing and indenting style. Whitespace, appropriately used, lends readability. There’s no penalty for leaving space in source screens except disk memory, which is cheap."
msgstr ""

#: ../../chapter5.rst:745
msgid "For those who like their conventions in black and white, Table :numref:`tab-5-1` is a list of guidelines. (But remember, Forth’s interpreter couldn’t care less about spacing or indentation.)"
msgstr ""

#: ../../chapter5.rst:749
msgid "Indentation and spacing guidelines"
msgstr ""

#: ../../chapter5.rst:752
msgid "1 space between the colon and the name"
msgstr ""

#: ../../chapter5.rst:753
msgid "2 spaces between the name and the comment [#f1]_"
msgstr ""

#: ../../chapter5.rst:754
msgid "2 spaces, or a carriage return, after the comment and"
msgstr ""

#: ../../chapter5.rst:755
msgid "before the definition [#f1]_"
msgstr ""

#: ../../chapter5.rst:756
msgid "3 spaces between the name and definition if no comment is used"
msgstr ""

#: ../../chapter5.rst:757
msgid "3 spaces indentation on each subsequent line (or multiples of 3 for nested indentation)"
msgstr ""

#: ../../chapter5.rst:759
msgid "1 space between words/numbers within a phrase"
msgstr ""

#: ../../chapter5.rst:760
msgid "2 or 3 spaces between phrases"
msgstr ""

#: ../../chapter5.rst:761
msgid "1 space between the last word and the semicolon"
msgstr ""

#: ../../chapter5.rst:762
msgid "1 space between semicolon and ``IMMEDIATE`` (if invoked)"
msgstr ""

#: ../../chapter5.rst:764
msgid "No blank lines between definitions, except to separate distinct groups of definitions"
msgstr ""

#: ../../chapter5.rst:767
msgid "The last position of each line should be blank except for:"
msgstr ""

#: ../../chapter5.rst:769
msgid "quoted strings that continue onto the next line, or"
msgstr ""

#: ../../chapter5.rst:771
msgid "the end of a comment."
msgstr ""

#: ../../chapter5.rst:773
msgid "A comment that begins with ``\\`` may continue right to the end of the line. Also, a comment that begins with ( may have its delimiting right parenthesis in the last column."
msgstr ""

#: ../../chapter5.rst:777
msgid "Here are some common errors of spacing and indentation:"
msgstr ""

#: ../../chapter5.rst:779
msgid "*Bad* (name not separated from the body of the definition):"
msgstr ""

#: ../../chapter5.rst:791
msgid "*Bad* (subsequent lines not indented three spaces):"
msgstr ""

#: ../../chapter5.rst:805
msgid "*Bad* (lack of phrasing):"
msgstr ""

#: ../../chapter5.rst:817
msgid "Phrasing is a subjective art; I’ve yet to see a useful set of formal rules. Simply strive for readability."
msgstr ""

#: ../../chapter5.rst:821
msgid "An often-seen alternative calls for 1 space between the name and comment and 3 between the comment and the definition. A more liberal technique uses 3 spaces before and after the comment. Whatever you choose, be consistent."
msgstr ""

#: ../../chapter5.rst:827
msgid "Comment Conventions"
msgstr ""

#: ../../chapter5.rst:829
msgid "Appropriate commenting is essential. There are five types of comments: stack-effect comments, data-structure comments, input-stream comments, purpose comments and narrative comments."
msgstr ""

#: ../../chapter5.rst:836
msgid "*A* stack-effect comment"
msgstr ""

#: ../../chapter5.rst:834
msgid "shows the arguments that the definition consumes from the stack, and the arguments it returns to the stack, if any."
msgstr ""

#: ../../chapter5.rst:842
msgid "*A* data-structure comment"
msgstr ""

#: ../../chapter5.rst:839
msgid "indicates the position and meaning of elements in a data structure. For instance, a text buffer might contain a count in the first byte, and 63 free bytes for text."
msgstr ""

#: ../../chapter5.rst:848
msgid "*An* input-stream comment"
msgstr ""

#: ../../chapter5.rst:845
msgid "indicates what strings the word expects to see in the input stream. For example, the Forth word FORGET scans for the name of a dictionary entry in the input stream."
msgstr ""

#: ../../chapter5.rst:853
msgid "*A* purpose comment"
msgstr ""

#: ../../chapter5.rst:851
msgid "describes, in as few words possible, what the definition does. How the definition works is not the concern of the purpose comment."
msgstr ""

#: ../../chapter5.rst:859
msgid "*A* narrative comment"
msgstr ""

#: ../../chapter5.rst:856
msgid "appears amidst a definition to explain what is going on, usually line-by-line. Narrative comments are used only in the “vertical format,” which we’ll describe in a later section."
msgstr ""

#: ../../chapter5.rst:861
msgid "Comments are usually typed in lower-case letters to distinguish them from source code. (Most Forth words are spelled with upper-case letters, but lower-case spellings are sometimes used in special cases.)"
msgstr ""

#: ../../chapter5.rst:865
msgid "In the following sections we’ll summarize the standardized formats for these types of comments and give examples for each type."
msgstr ""

#: ../../chapter5.rst:869
msgid "Stack Notation"
msgstr ""

#: ../../chapter5.rst:873
msgid "Every colon or code definition that consumes and/or returns any arguments on the stack must include a stack-effect comment."
msgstr ""

#: ../../chapter5.rst:876
msgid "“Stack notation” refers to conventions for representing what’s on the stack. Forms of stack notation include “stack pictures,” “stack effects,” and “stack-effect comments.”"
msgstr ""

#: ../../chapter5.rst:882
msgid "Stack Picture"
msgstr ""

#: ../../chapter5.rst:884
msgid "A stack picture depicts items understood to be on the stack at a given time. Items are listed from left to right, with the leftmost item representing the bottom of the stack and the rightmost item representing the top."
msgstr ""

#: ../../chapter5.rst:889
msgid "For instance, the stack picture"
msgstr ""

#: ../../chapter5.rst:895
msgid "indicates two numbers on the stack, with n2 on the top (the most accessible position)."
msgstr ""

#: ../../chapter5.rst:898
msgid "This is the same order that you would use to type these values in; i.e., if n1 is 100 and n2 is 5000, then you would type"
msgstr ""

#: ../../chapter5.rst:905
msgid "to place these values correctly on the stack."
msgstr ""

#: ../../chapter5.rst:907
msgid "A stack picture can include either abbreviations, such as “n1,” or fully spelled-out words. Usually abbreviations are used. Some standard abbreviations appear in Table :numref:`tab-5-2`. Whether abbreviations or fully spelled-out words are used, each stack item should be separated by a space."
msgstr ""

#: ../../chapter5.rst:913
msgid "If a stack item is described with a phrase (such as “address-of-latest-link”), the words in the phrase should be joined by hyphens. For example, the stack picture:"
msgstr ""

#: ../../chapter5.rst:921
msgid "shows three elements on the stack."
msgstr ""

#: ../../chapter5.rst:924
msgid "Stack Effect"
msgstr ""

#: ../../chapter5.rst:926
msgid "A “stack effect” shows two stack pictures: one picture of any items that may be *consumed* by a definition, and another picture of any items *returned* by the definition. The “before” picture comes first, followed by two hyphens, then the “after” picture."
msgstr ""

#: ../../chapter5.rst:931
msgid "For instance, the stack effect for Forth’s addition operator, ``+`` is"
msgstr ""

#: ../../chapter5.rst:937
msgid "where ``+`` consumes two numbers and returns their sum."
msgstr ""

#: ../../chapter5.rst:939
msgid "Remember that the stack effect describes only the *net result* of the operation on the stack. Other values that happen to reside on the stack beneath the arguments of interest don’t need to be shown. Nor do values that may appear or disappear while the operation is executing."
msgstr ""

#: ../../chapter5.rst:944
msgid "If the word returns any input arguments unchanged, they should be repeated in the output picture; e.g.,"
msgstr ""

#: ../../chapter5.rst:951
msgid "Conversely, if the word changes any arguments, the stack comment must use a different descriptor:"
msgstr ""

#: ../../chapter5.rst:959
msgid "A stack effect might appear in a formatted glossary."
msgstr ""

#: ../../chapter5.rst:962
msgid "Stack Effect Comment"
msgstr ""

#: ../../chapter5.rst:964
msgid "A “stack-effect comment” is a stack effect that appears in source code surrounded by parentheses. Here’s the stack-effect comment for the word COUNT:"
msgstr ""

#: ../../chapter5.rst:972
msgid "or:"
msgstr ""

#: ../../chapter5.rst:978
msgid "(The “count” is on top of the stack after the word has executed.)"
msgstr ""

#: ../../chapter5.rst:980
msgid "If a definition has no effect on the stack (that is, no effect the user is aware of, despite what gyrations occur within the definition), it needs no stack-effect comment:"
msgstr ""

#: ../../chapter5.rst:988
msgid "On the other hand, you may want to use an empty stack comment—i.e.,"
msgstr ""

#: ../../chapter5.rst:994
msgid "to emphasize that the word has no effect on the stack."
msgstr ""

#: ../../chapter5.rst:996
msgid "If a definition consumes arguments but returns none, the double-hyphen is optional. For instance,"
msgstr ""

#: ../../chapter5.rst:1003
msgid "can be shortened to"
msgstr ""

#: ../../chapter5.rst:1009
msgid "The assumption behind this convention is this: There are many more colon definitions that consume arguments and return nothing than definitions that consume nothing and return arguments."
msgstr ""

#: ../../chapter5.rst:1014
msgid "Stack Abbreviation Standards"
msgstr ""

#: ../../chapter5.rst:1016
msgid "Abbreviations used in stack notation should be consistent. Table :numref:`tab-5-2` lists most of the commonly used abbreviations. (This table reappears in :doc:`Appendix E<appendixe>`.) The terms “single-length,” “double-length,” etc. refer to the size of a “cell” in the particular Forth system. (If the system uses a 16-bit cell, “n” represents a 16-bit number; if the system uses a 32-bit cell, “n” represents a 32-bit number.)"
msgstr ""

#: ../../chapter5.rst:1025
msgid "Notation of Flags"
msgstr ""

#: ../../chapter5.rst:1027
msgid "Table :numref:`tab-5-2` shows three ways to represent a boolean flag. To illustrate, here are three versions of the same stack comment for the word ``-TEXT``:"
msgstr ""

#: ../../chapter5.rst:1037
msgid "Stack-comment abbreviations."
msgstr ""

#: ../../chapter5.rst:1041
msgid "n"
msgstr ""

#: ../../chapter5.rst:1042
msgid "single-length signed number"
msgstr ""

#: ../../chapter5.rst:1043
msgid "d"
msgstr ""

#: ../../chapter5.rst:1044
msgid "double-length signed number"
msgstr ""

#: ../../chapter5.rst:1045
msgid "u"
msgstr ""

#: ../../chapter5.rst:1046
msgid "single-length unsigned number"
msgstr ""

#: ../../chapter5.rst:1047
msgid "ud"
msgstr ""

#: ../../chapter5.rst:1048
msgid "double-length unsigned number"
msgstr ""

#: ../../chapter5.rst:1049
msgid "t"
msgstr ""

#: ../../chapter5.rst:1050
msgid "triple-length"
msgstr ""

#: ../../chapter5.rst:1051
msgid "q"
msgstr ""

#: ../../chapter5.rst:1052
msgid "quadruple-length"
msgstr ""

#: ../../chapter5.rst:1053
#: ../../chapter5.rst:1223
msgid "c"
msgstr ""

#: ../../chapter5.rst:1054
msgid "7-bit character value"
msgstr ""

#: ../../chapter5.rst:1055
msgid "b"
msgstr ""

#: ../../chapter5.rst:1056
msgid "8-bit byte"
msgstr ""

#: ../../chapter5.rst:1057
msgid "?"
msgstr ""

#: ../../chapter5.rst:1058
msgid "boolean flag; or;"
msgstr ""

#: ../../chapter5.rst:1059
msgid "t="
msgstr ""

#: ../../chapter5.rst:1060
msgid "true"
msgstr ""

#: ../../chapter5.rst:1061
msgid "f="
msgstr ""

#: ../../chapter5.rst:1062
msgid "false"
msgstr ""

#: ../../chapter5.rst:1063
msgid "a or adr"
msgstr ""

#: ../../chapter5.rst:1064
msgid "address"
msgstr ""

#: ../../chapter5.rst:1065
msgid "acf"
msgstr ""

#: ../../chapter5.rst:1066
msgid "address of code field"
msgstr ""

#: ../../chapter5.rst:1067
msgid "apf"
msgstr ""

#: ../../chapter5.rst:1068
msgid "address of parameter field"
msgstr ""

#: ../../chapter5.rst:1069
msgid "\\'"
msgstr ""

#: ../../chapter5.rst:1070
msgid "(as prefix) address of"
msgstr ""

#: ../../chapter5.rst:1071
msgid "s d"
msgstr ""

#: ../../chapter5.rst:1072
msgid "(as a pair) source destination"
msgstr ""

#: ../../chapter5.rst:1073
msgid "lo hi"
msgstr ""

#: ../../chapter5.rst:1074
msgid "lower-limit upper-limit (inclusive)"
msgstr ""

#: ../../chapter5.rst:1075
msgid "#"
msgstr ""

#: ../../chapter5.rst:1076
msgid "count"
msgstr ""

#: ../../chapter5.rst:1077
msgid "o"
msgstr ""

#: ../../chapter5.rst:1078
msgid "offset"
msgstr ""

#: ../../chapter5.rst:1079
msgid "i"
msgstr ""

#: ../../chapter5.rst:1080
msgid "index"
msgstr ""

#: ../../chapter5.rst:1081
msgid "m"
msgstr ""

#: ../../chapter5.rst:1082
msgid "mask"
msgstr ""

#: ../../chapter5.rst:1083
msgid "x"
msgstr ""

#: ../../chapter5.rst:1084
msgid "don\\'t care (data structure notation)"
msgstr ""

#: ../../chapter5.rst:1086
msgid "An “offset” is a difference expressed in absolute units, such as bytes."
msgstr ""

#: ../../chapter5.rst:1087
msgid "An “index” is a difference expressed in logical units, such as elements or records."
msgstr ""

#: ../../chapter5.rst:1089
msgid "The equal sign after the symbols “t” and “f” equates the flag outcome with its meaning. The result-side of the second version would be read “true means no match.”"
msgstr ""

#: ../../chapter5.rst:1094
msgid "Notation of Variable Possibilities"
msgstr ""

#: ../../chapter5.rst:1096
msgid "Some definitions yield a different stack effect under different circumstances."
msgstr ""

#: ../../chapter5.rst:1098
msgid "If the number of items on the stack remains the same under all conditions, but the items themselves change, you can use the vertical bar ( ``|`` ) to mean “or.” The following stack-effect comment describes a word that returns either the address of a file or, if the requested file is not found, zero:"
msgstr ""

#: ../../chapter5.rst:1107
msgid "If the number of items in a stack picture can vary—in either the “before” or “after” picture—you must write out both versions of the entire stack picture, along with the double-hyphen, separated by the “or” symbol. For instance:"
msgstr ""

#: ../../chapter5.rst:1116
msgid "This comment indicates that if the word is found, three arguments are returned (with the flag on top); otherwise only a false flag is returned."
msgstr ""

#: ../../chapter5.rst:1120
msgid "Note the importance of the second “--”. Its omission would indicate that the definition always returned three arguments, the top one being a flag."
msgstr ""

#: ../../chapter5.rst:1124
msgid "If you prefer, you can write the entire stack effect twice, either on the same line, separated by three spaces:"
msgstr ""

#: ../../chapter5.rst:1132
msgid "or listed vertically:"
msgstr ""

#: ../../chapter5.rst:1140
msgid "Data-Structure Comments"
msgstr ""

#: ../../chapter5.rst:1142
msgid "A “data-structure comment” depicts the elements in a data structure. For example, here’s the definition of an insert buffer called \\|INSERT :"
msgstr ""

#: ../../chapter5.rst:1149
msgid "The “faces” (curly-brackets) begin and end the structure comment; the bars separate the various elements in the structure; the numbers represent bytes per element. In the comment above, the first byte contains the count, and the remaining 63 bytes contain the text."
msgstr ""

#: ../../chapter5.rst:1154
msgid "A “bit comment” uses the same format as a data-structure comment to depict the meaning of bits in a byte or cell. For instance, the bit comment"
msgstr ""

#: ../../chapter5.rst:1163
msgid "describes the format of a 16-bit status register of a communications channel. The first two bits are flags, the second two bits are unused, and the final pair of six-bit fields indicate the input and output devices which this channel is connected to."
msgstr ""

#: ../../chapter5.rst:1169
msgid "If more than one data structure employs the same pattern of elements, write out the comment only once (possibly in the preamble), and give a name to the pattern for reference in subsequent screens. For instance, if the preamble gives the above bit-pattern the name “status,” then “status” can be used in stack comments to indicate values with that pattern:"
msgstr ""

#: ../../chapter5.rst:1180
msgid "If a ``2VARIABLE`` contains one double-length value, the comment should be a stack picture that indicates the contents:"
msgstr ""

#: ../../chapter5.rst:1187
msgid "If a ``2VARIABLE`` contains two single-length data elements, it’s given a stack picture showing what would be on the stack after a ``2@``. Thus:"
msgstr ""

#: ../../chapter5.rst:1195
msgid "This is different from the comment that would be used if ``MEASUREMENTS`` were defined by ``CREATE``."
msgstr ""

#: ../../chapter5.rst:1202
msgid "(While both statements produce the same result in the dictionary, the use of ``2VARIABLE`` implies that the values will normally be “2-fetched” and “2-stored” together-thus we use a *stack* comment. The high-order part, appearing on top of the stack, is listed to the right. The use of ``CREATE`` implies that the values will normally be fetched and stored separately–thus we use a data structure comment. The item in the 0th position is listed to the left.)"
msgstr ""

#: ../../chapter5.rst:1212
msgid "Input-stream Comments"
msgstr ""

#: ../../chapter5.rst:1214
msgid "The input-stream comment indicates what words and/or strings are presumed to be in the input stream. Table :numref:`tab-5-3` lists the designations used for input stream arguments."
msgstr ""

#: ../../chapter5.rst:1218
msgid "Input-stream comment designations."
msgstr ""

#: ../../chapter5.rst:1223
msgid "single character, blank-delimited"
msgstr ""

#: ../../chapter5.rst:1224
msgid "name"
msgstr ""

#: ../../chapter5.rst:1224
msgid "sequence of characters, blank delimited"
msgstr ""

#: ../../chapter5.rst:1225
msgid "text"
msgstr ""

#: ../../chapter5.rst:1225
msgid "sequence of characters, delimited by non-blank"
msgstr ""

#: ../../chapter5.rst:1228
msgid "Follow \"text\" with the actual delimiter required; e.g.: \"text\" or text"
msgstr ""

#: ../../chapter5.rst:1230
msgid "The input-stream comment appears *before* the stack comment, and is *not* encapsulated between its own pair of parentheses, but simply surrounded by three spaces on each side. For instance, here’s one way to comment the definition of ``’`` (tick) showing first the input-stream comment, then the stack comment:"
msgstr ""

#: ../../chapter5.rst:1240
msgid "If you prefer to use ``(`` , the comment would look like this:"
msgstr ""

#: ../../chapter5.rst:1246
msgid "Incidentally, there are three distinct ways to receive string input. To avoid confusion, here are the terms:"
msgstr ""

#: ../../chapter5.rst:1253
msgid "Scanning-for"
msgstr ""

#: ../../chapter5.rst:1251
msgid "means looking ahead in the input stream, either for a word or number as in the case of tick, or for a delimiter as in the case of ``.\"`` and ``(`` ."
msgstr ""

#: ../../chapter5.rst:1257
msgid "Expecting"
msgstr ""

#: ../../chapter5.rst:1256
msgid "means waiting for. ``EXPECT`` and ``KEY``, and definitions that invoke them, are ones that “expect” input."
msgstr ""

#: ../../chapter5.rst:1262
msgid "Presuming"
msgstr ""

#: ../../chapter5.rst:1260
msgid "indicates that in normal usage something will follow. The word: “scans-for” the name to be defined, and “presumes” that a definition will follow."
msgstr ""

#: ../../chapter5.rst:1264
msgid "The input-stream comment is only appropriate for input being scanned-for."
msgstr ""

#: ../../chapter5.rst:1268
msgid "Purpose Comments"
msgstr ""

#: ../../chapter5.rst:1272
msgid "Every definition should bear a purpose comment unless:"
msgstr ""

#: ../../chapter5.rst:1274
msgid "its purpose is clear from its name or its stack-effect comment, or"
msgstr ""

#: ../../chapter5.rst:1275
msgid "if it consists of three or fewer words."
msgstr ""

#: ../../chapter5.rst:1277
msgid "The purpose comment should be kept to a minimum-never more than a full line. For example:"
msgstr ""

#: ../../chapter5.rst:1285
msgid "Use the imperative mood: “set Foreground color,” not “sets Foreground color.”"
msgstr ""

#: ../../chapter5.rst:1288
msgid "On the other hand, a word’s purpose can often be described in terms of its stack-effect comment. You rarely need both a stack comment and a purpose comment. For instance:"
msgstr ""

#: ../../chapter5.rst:1302
msgid "This definition takes as its incoming argument a number that represents the number of spaces to type."
msgstr ""

#: ../../chapter5.rst:1311
msgid "This definition converts an index, which it consumes, into an address within a table of 2-byte elements corresponding to the indexed element."
msgstr ""

#: ../../chapter5.rst:1318
msgid "This definition returns an address of a scratch region of memory."
msgstr ""

#: ../../chapter5.rst:1320
msgid "Occasionally, readability is best served by including both types of comment. In this case, the purpose comment should appear last. For instance:"
msgstr ""

#: ../../chapter5.rst:1330
msgid "Indicate the type of comment by ordering: input-stream comments first, stack-effect comments second, purpose comments last."
msgstr ""

#: ../../chapter5.rst:1333
msgid "For example:"
msgstr ""

#: ../../chapter5.rst:1339
msgid "If you prefer to use ``(``, then write:"
msgstr ""

#: ../../chapter5.rst:1345
msgid "If necessary, you can put the purpose comment on a second line:"
msgstr ""

#: ../../chapter5.rst:1354
msgid "Comments for Defining Words"
msgstr ""

#: ../../chapter5.rst:1356
msgid "The definition of a defining word involves two behaviors:"
msgstr ""

#: ../../chapter5.rst:1359
msgid "that of the defining word as it defines its “child” (compile-time behavior), and"
msgstr ""

#: ../../chapter5.rst:1362
msgid "that of the child itself (run-time behavior)."
msgstr ""

#: ../../chapter5.rst:1364
msgid "These two behaviors must be commented separately."
msgstr ""

#: ../../chapter5.rst:1368
msgid "Comment a defining word's compile-time behavior in the usual way; comment its run-time behavior separately, following the word ``DOES>`` (or ``;CODE``)."
msgstr ""

#: ../../chapter5.rst:1372
msgid "For instance,"
msgstr ""

#: ../../chapter5.rst:1379
msgid "The stack-effect comment for the run-time (child’s) behavior represents the net stack effect for the child word. Therefore it does not include the address returned by ``DOES>,`` even though this address is on the stack when the run-time code begins."
msgstr ""

#: ../../chapter5.rst:1384
msgid "*Bad* (run-time comment includes apf):"
msgstr ""

#: ../../chapter5.rst:1400
msgid "Words defined by this word ARRAY will exhibit the stack effect:"
msgstr ""

#: ../../chapter5.rst:1406
msgid "If the defining word does not specify the run-time behavior, there still exists a run-time behavior, and it may be commented:"
msgstr ""

#: ../../chapter5.rst:1415
msgid "Comments for Compiling Words"
msgstr ""

#: ../../chapter5.rst:1417
msgid "As with defining words, most compiling words involve two behaviors:"
msgstr ""

#: ../../chapter5.rst:1419
msgid "That of the compiling word as the definition in which it appears is compiled"
msgstr ""

#: ../../chapter5.rst:1422
msgid "That of the run-time routine which will execute when we invoke the word being defined. Again we must comment each behavior separately."
msgstr ""

#: ../../chapter5.rst:1427
msgid "Comment a compiling word's run-time behavior in the usual way; comment its compile-time behavior separately, beginning with the label \"Compile:\"."
msgstr ""

#: ../../chapter5.rst:1431
msgid "For instance:"
msgstr ""

#: ../../chapter5.rst:1439
msgid "In the case of compiling words, the first comment describes the run-time behavior, which is usually the *syntax for using* the word. The second comment describes what the word *actually does* in compiling (which is of less importance to the user)."
msgstr ""

#: ../../chapter5.rst:1444
msgid "Other examples:"
msgstr ""

#: ../../chapter5.rst:1451
msgid "Occasionally a compiling word may exhibit a different behavior when it is invoked *outside* a colon definition. Such words (to be fastidious about it) require three comments. For instance:"
msgstr ""

#: ../../chapter5.rst:1462
msgid ":doc:`Appendix E<appendixe>` includes two screens showing good commenting style."
msgstr ""

#: ../../chapter5.rst:1465
msgid "Vertical Format vs. Horizontal Format"
msgstr ""

#: ../../chapter5.rst:1467
msgid "The purpose of commenting is to allow a reader of your code to easily determine what’s going on. But how much commenting is necessary? To determine the level of commenting appropriate for your circumstances, you must ask yourself two questions:"
msgstr ""

#: ../../chapter5.rst:1472
msgid "Who will be reading my code?"
msgstr ""

#: ../../chapter5.rst:1474
msgid "How readable are my definitions?"
msgstr ""

#: ../../chapter5.rst:1476
msgid "There are two basic styles of commenting to choose from. The first style, often called the “vertical format,” includes a step-by-step description of the process, in the manner of a well-commented assembly language listing. These line-by-line comments are called “narrative comments.”"
msgstr ""

#: ../../chapter5.rst:1499
msgid "The other approach does not intersperse narrative comments between code phrases. This is called the “horizontal format.”"
msgstr ""

#: ../../chapter5.rst:1508
msgid "The vertical format is preferred when a large team of programmers are coding and maintaining the application. Typically, such a team will include several junior-level programmers responsible for minor corrections. In such an environment, diligent commenting can save a lot of time and upset. As Johnson of Moore Products Co. says: “When maintaining code you are usually interested in just one small section, and the more information written there the better your chances for a speedy fix.”"
msgstr ""

#: ../../chapter5.rst:1517
msgid "Here are several pertinent rules required of the Forth programmers at Moore Products Co. (I’m paraphrasing):"
msgstr ""

#: ../../chapter5.rst:1520
msgid "A vertical format will be used. Comments will appear to the right of the source code, but may continue to engulf the next line totally if needed."
msgstr ""

#: ../../chapter5.rst:1524
msgid "There should be more comment characters than source characters. (The company encourages long descriptive names, greater than ten characters, and allows the names to be counted as comment characters.)"
msgstr ""

#: ../../chapter5.rst:1529
msgid "Any conditional structure or application word should appear on a separate line. “Noise words” can be grouped together. Indentation is used to show nested conditionals."
msgstr ""

#: ../../chapter5.rst:1533
msgid "There are some difficulties with this format, however. For one thing, line-by-line commenting is time-consuming, even with a good screen editor. Productivity can be stifled, especially when stopping to write the comments breaks your chain of thought."
msgstr ""

#: ../../chapter5.rst:1539
msgid "Also, you must also carefully ensure that the comments are up-to-date. Very often code is corrected, the revision is tested, the change works—and the programmer forgets to change the comments. The more comments there are, the more likely they are to be wrong. If they’re wrong, they’re worse than useless."
msgstr ""

#: ../../chapter5.rst:1545
msgid "This problem can be alleviated if the project supervisor carefully reviews code and ensures the accuracy of comments."
msgstr ""

#: ../../chapter5.rst:1548
msgid "Finally, line-by-line commenting can allow a false sense of security. Don’t assume that because each *line* has a comment, the *application* is well-com-men-ted. Line-by-line commenting doesn’t address the significant aspects of a definition’s operation. What, for instance, is the thinking behind the checksum algorithm used? Who knows, from the narrative comments?"
msgstr ""

#: ../../chapter5.rst:1556
msgid "To properly describe, in prose, the implications of a given procedure usually requires many paragraphs, not a single phrase. Such descriptions properly belong in auxiliary documentation or in the chapter preamble."
msgstr ""

#: ../../chapter5.rst:1560
msgid "Despite these cautions, many companies find the vertical format necessary. Certainly a team that is newly exposed to Forth should adopt it, as should any very large team."
msgstr ""

#: ../../chapter5.rst:1564
msgid "What about the horizontal format? Perhaps it’s an issue of art vs. practicality, but I feel compelled to defend the horizontal format as equally valid and in some ways superior."
msgstr ""

#: ../../chapter5.rst:1568
msgid "If Forth code is really well-written, there should be nothing ambiguous about it. This means that:"
msgstr ""

#: ../../chapter5.rst:1571
msgid "supporting lexicons have a well-designed syntax"
msgstr ""

#: ../../chapter5.rst:1573
msgid "stack inputs and outputs are commented"
msgstr ""

#: ../../chapter5.rst:1575
msgid "the purpose is commented (if it’s not clear from the name or stack comment)"
msgstr ""

#: ../../chapter5.rst:1578
msgid "definitions are not too long"
msgstr ""

#: ../../chapter5.rst:1580
msgid "not too many arguments are passed to a single definition via the stack (see “The Stylish Stack” in :doc:`Chapter Seven<chapter7>`)."
msgstr ""

#: ../../chapter5.rst:1583
msgid "Forth is simply not like other languages, in which line-by-line commenting is one of the few things you can do to make programs more readable."
msgstr ""

#: ../../chapter5.rst:1587
msgid "Skillfully written Forth code is like poetry, containing precise meaning that both programmer and machine can easily read. Your *goal* should be to write code that does not need commenting, even if you choose to comment it. Design your application so that the code, not the comments, conveys the meaning."
msgstr ""

#: ../../chapter5.rst:1593
msgid "If you succeed, then you can eliminate the clutter of excessive commenting, achieving a purity of expression without redundant explanations."
msgstr ""

#: ../../chapter5.rst:1602
msgid "Wiggins, proud of his commenting technique."
msgstr ""

#: ../../chapter5.rst:1606
msgid "The most-accurate, least-expensive documentation is self-documenting code."
msgstr ""

#: ../../chapter5.rst:1609
msgid "Unfortunately, even the best programmers, given the pressure of a deadline, may write working code that is not easily readable without comments. If you are writing for yourself, or for a small group with whom you can verbally communicate, the horizontal format is ideal. Otherwise, consider the vertical format."
msgstr ""

#: ../../chapter5.rst:1617
msgid "Choosing Names: The Art"
msgstr ""

#: ../../chapter5.rst:1619
msgid "Besides a mathematical inclination, an exceptionally good mastery of one\\'s native tongue is the most vital asset of a competent programmer (**Prof.  Edsger W. Dijkstra** [dijkstra82]_ )."
msgstr ""

#: ../../chapter5.rst:1623
msgid "We’ve talked about the significance of using names to symbolize ideas and objects in the application. The choosing of names turns out to be an important part of the design process."
msgstr ""

#: ../../chapter5.rst:1628
msgid "Newcomers tend to overlook the important of names. “After all,” they think, “the computer doesn’t care what names I choose.”"
msgstr ""

#: ../../chapter5.rst:1631
msgid "But good names are essential for readability. Moreover, the mental exercise of summoning a one-word description bears a synergistic effect on your perceptions of what the entity should or should not do."
msgstr ""

#: ../../chapter5.rst:1635
msgid "Here are some rules for choosing good names:"
msgstr ""

#: ../../chapter5.rst:1639
msgid "Choose names according to \"what,\" not \"how.\""
msgstr ""

#: ../../chapter5.rst:1641
msgid "A definition should hide the complexities of implementation from other definitions which invoke it. The name, too, should hide the details of the procedure, and instead should describe the outward appearance or net effect."
msgstr ""

#: ../../chapter5.rst:1646
msgid "For instance, the Forth word ``ALLOT`` simply increments the dictionary pointer (called ``DP`` or ``H`` in most systems). But the name ``ALLOT`` is better than ``DP+!`` because the user is thinking of reserving space, not incrementing a pointer."
msgstr ""

#: ../../chapter5.rst:1652
msgid "The ’83 Standard adopted the name ``CMOVE>`` instead of the previous name for the same function, ``<CMOVE``. The operation makes it possible to copy a region of memory *forward* into overlapping memory. It accomplishes this by starting with the last byte and working *backward*. In the new name, the forwardness of the “what” supersedes the backwardness of the “how.”"
msgstr ""

#: ../../chapter5.rst:1661
msgid "Find the most expressive word."
msgstr ""

#: ../../chapter5.rst:1665
msgid "A powerful agent is the right word.  Whenever we come upon one of those intensely right words in a book or a newspaper the resulting effect is physical as well as spiritual, and electrically prompt **(Mark Twain)** ."
msgstr ""

#: ../../chapter5.rst:1670
msgid "The difference between the right word and the almost-right word is like the difference between lightning and the lightning bug **(Mark Twain)** ."
msgstr ""

#: ../../chapter5.rst:1674
msgid "Suit the action to the word, the word to the action **(Shakespeare, Hamlet, Act~III)** ."
msgstr ""

#: ../../chapter5.rst:1677
msgid "Henry Laxen, a Forth consultant and author, suggests that the most important Forth development tool is a good thesaurus [laxen]_ ."
msgstr ""

#: ../../chapter5.rst:1681
msgid "Sometimes you’ll think of an adequate word for a definition, but it doesn’t feel quite right. It may be months later before you realize that you fell short of the mark. In the Roman numeral example in :doc:`Chapter Four<chapter4>` one-less-than the next symbol’s value. My first choice was ``4-0R-9``. That’s awkward, but it was much later that I thought of ``ALMOST``."
msgstr ""

#: ../../chapter5.rst:1687
msgid "Most fig-Forth systems include the word ``VLIST``, which lists the names of all the words in the current vocabulary. After many years someone realized that a nicer name is ``WORDS``. Not only does ``WORDS`` sound more pleasant by itself, it also works nicely with vocabulary names. For instance:"
msgstr ""

#: ../../chapter5.rst:1703
msgid "On the other hand, Moore points out that inappropriate names can become a simple technique for encryption. If you need to provide security when you’re forced to distribute source, you can make your code very unreadable by deliberately choosing misleading names. Of course, maintenance becomes impossible."
msgstr ""

#: ../../chapter5.rst:1712
msgid "Choose names that work in phrases."
msgstr ""

#: ../../chapter5.rst:1714
msgid "Faced with a definition you don’t know what to call, think about how the word will be used in context. For instance:"
msgstr ""

#: ../../chapter5.rst:1719
msgid "``SHUTTER OPEN``"
msgstr ""

#: ../../chapter5.rst:1718
msgid "``OPEN`` is the appropriate name for a word that sets a bit in an I/O address identified with the name ``SHUTTER``."
msgstr ""

#: ../../chapter5.rst:1725
msgid "``3 BUTTON DOES IGNITION``"
msgstr ""

#: ../../chapter5.rst:1722
msgid "``DOES`` is a good choice for a word that vectors the address of the function ``IGNITION`` into a table of functions, so that ``IGNITION`` will be executed when Button 3 is pushed."
msgstr ""

#: ../../chapter5.rst:1732
msgid "``SAY HELLO``"
msgstr ""

#: ../../chapter5.rst:1728
msgid "``SAY`` is the perfect choice for vectoring ``HELLO`` into an execution variable.  (When I first wrote this example for Starting Forth, I called it ``VERSION``. Moore reviewed the manuscript and suggested ``SAY``, which is clearly much better.)"
msgstr ""

#: ../../chapter5.rst:1736
msgid "``I'M HARRY``"
msgstr ""

#: ../../chapter5.rst:1735
msgid "The word ``I'M`` seems more natural than ``LOGON HARRY``, ``LOGIN HARRY`` or ``SESSION HARRY``, as often seen."
msgstr ""

#: ../../chapter5.rst:1751
msgid "The choice of ``I'M`` is another invention of **Moore**, who says:"
msgstr ""

#: ../../chapter5.rst:1741
msgid "I detest the word ``LOGON``. There is no such word in English.  I was looking for a word that said, \"I'm ...\" It was a natural. I just stumbled across it.  Even though it's clumsy with that apostrophe, it has that sense of rightness."
msgstr ""

#: ../../chapter5.rst:1746
msgid "All these little words are the nicest way of getting the \"Aha!\" reaction.  If you think of the right word, it is **obviously** the right word."
msgstr ""

#: ../../chapter5.rst:1750
msgid "If you have a wide recall vocabulary, you're in a better position to come up with the right word."
msgstr ""

#: ../../chapter5.rst:1753
msgid "Another of Moore’s favorite words is TH, which he uses as an array indexing word. For instance, the phrase"
msgstr ""

#: ../../chapter5.rst:1760
msgid "returns the address of the “fifth” element of the array."
msgstr ""

#: ../../chapter5.rst:1765
msgid "Spell names in full."
msgstr ""

#: ../../chapter5.rst:1767
msgid "I once saw some Forth code published in a magazine in which the author seemed hell-bent on purging all vowels from his names, inventing such eyesores as ``DSPL-BFR`` for “display buffer.” Other writers seem to think that three characters magically says it all, coining ``LEN`` for “length.” Such practices reflect thinking from a bygone age."
msgstr ""

#: ../../chapter5.rst:1773
msgid "Forth words should be fully spelled out. Feel proud to type every letter of ``INITIALIZE`` or ``TERMINAL`` or ``BUFFER``. These are the words you mean. The worst problem with abbreviating a word is that you forget just how you abbreviated it. Was that ``DSPL`` or ``DSPLY``?"
msgstr ""

#: ../../chapter5.rst:1779
msgid "Another problem is that abbreviations hinder readability. Any programming language is hard enough to read without compounding the difficulty."
msgstr ""

#: ../../chapter5.rst:1783
msgid "Still, there are exceptions. Here are a few:"
msgstr ""

#: ../../chapter5.rst:1785
msgid "Words that you use extremely frequently in code. Forth employs a handful of commands that get used over and over, but have little or no intrinsic meaning:"
msgstr ""

#: ../../chapter5.rst:1793
msgid "But there are so few of them, and they’re used so often, they become old friends. I would never want to type, on a regular basis,"
msgstr ""

#: ../../chapter5.rst:1801
msgid "(Interestingly, most of these symbols don’t have English counterparts. We use the phrase “*colon* definition” because there’s no other term; we say “*comma* a number into the dictionary” because it’s not exactly compiling, and there’s no other term.)"
msgstr ""

#: ../../chapter5.rst:1806
msgid "Words that a terminal operator might use frequently to control an operation. These words should be spelled as single letters, as are line editor commands."
msgstr ""

#: ../../chapter5.rst:1810
msgid "Words in which familiar usage implies that they be abbreviated. Forth assembler mnemonics are typically patterned after the manufacturer’s suggested mnemonics, which are abbreviations (such as JMP and MOV)."
msgstr ""

#: ../../chapter5.rst:1814
msgid "Your names should be pronounceable; otherwise you may regret it when you try to discuss the program with other people. If the name is symbolic, invent a pronunciation (e.g., ``>R`` is called “to-r”; ``R>`` is called “r-from”)."
msgstr ""

#: ../../chapter5.rst:1821
msgid "Favor short words."
msgstr ""

#: ../../chapter5.rst:1823
msgid "Given the choice between a three-syllable word and a one-syllable word that means the same thing, choose the shorter. ``BRIGHT`` is a better name than ``INTENSE``. ``ENABLE`` is a better name than ``ACTIVATE``; ``GO``, ``RUN``, or ``ON`` may be better still."
msgstr ""

#: ../../chapter5.rst:1827
msgid "Shorter names are easier to type. They save space in the source screen. Most important, they make your code crisp and clean."
msgstr ""

#: ../../chapter5.rst:1832
msgid "Hyphenated names may be a sign of bad factoring."
msgstr ""

#: ../../chapter5.rst:1843
msgid "**Moore**:"
msgstr ""

#: ../../chapter5.rst:1835
msgid "There are diverging programming styles in the Forth community.  One uses hyphenated words that express in English what the word is doing. You string these big long words together and you get something that is quite readable."
msgstr ""

#: ../../chapter5.rst:1840
msgid "But I immediately suspect that the programmer didn't think out the words carefully enough, that the hyphen should be broken and the words defined separately.  That isn't always possible, and it isn't always advantageous. But I suspect a hyphenated word of mixing two concepts."
msgstr ""

#: ../../chapter5.rst:1845
msgid "Compare the following two strategies for saying the same thing:"
msgstr ""

#: ../../chapter5.rst:1858
msgid "The syntax on the left requires eight dictionary entries; the syntax on the right requires only six-and some of the words are likely to be reused in other parts of the application. If you had a ``MIDDLE`` motor and solenoid as well, you’d need only seven words to describe sixteen combinations."
msgstr ""

#: ../../chapter5.rst:1866
msgid "Don't bundle numbers into names."
msgstr ""

#: ../../chapter5.rst:1868
msgid "Watch out for a series of names beginning or ending with numbers, such as ``1CHANNEL``, ``2CHANNEL``, ``3CHANNEL``, etc."
msgstr ""

#: ../../chapter5.rst:1871
msgid "This bundling of names and numbers may be an indication of bad factoring. The crime is similar to hyphenation, except that what should be factored out is a number, not a word. A better factoring of the above would be"
msgstr ""

#: ../../chapter5.rst:1882
msgid "In this case, the three words were reduced to one."
msgstr ""

#: ../../chapter5.rst:1884
msgid "Often the bundling of names and numbers indicates fuzzy naming. In the above case, more descriptive names might indicate the purpose of the channels, as in"
msgstr ""

#: ../../chapter5.rst:1892
msgid "We’ll amplify on these ideas in the next chapter on “Factoring.”"
msgstr ""

#: ../../chapter5.rst:1895
msgid "Naming Standards: The Science"
msgstr ""

#: ../../chapter5.rst:1899
msgid "Learn and adopt Forth\\'s naming conventions."
msgstr ""

#: ../../chapter5.rst:1901
msgid "In the quest for short, yet meaningful names, Forth programmers have adopted certain naming conventions. :doc:`Appendix E<appendixe>` includes a list of the most useful conventions developed over the years."
msgstr ""

#: ../../chapter5.rst:1905
msgid "An example of the power of naming conventions is the use of “dot” to mean “print” or “display.” Forth itself uses"
msgstr ""

#: ../../chapter5.rst:1912
msgid "for displaying various types of numbers in various formats. The convention extends to application words as well. If you have a variable called ``DATE,`` and you want a word that displays the date, use the name"
msgstr ""

#: ../../chapter5.rst:1920
msgid "A caution: The overuse of prefixes and suffixes makes words uglier and ultimately less readable. Don’t try to describe everything a word does by its name alone. After all, a name is a symbol, not a shorthand for code. Which is more readable and natural sounding?:"
msgstr ""

#: ../../chapter5.rst:1925
msgid "Oedipus complex"
msgstr ""

#: ../../chapter5.rst:1927
msgid "(which bears no intrinsic meaning), or"
msgstr ""

#: ../../chapter5.rst:1929
msgid "subconscious-attachment-to-parent-of-opposite-sex complex"
msgstr ""

#: ../../chapter5.rst:1931
msgid "Probably the former, even though it assumes you know the play."
msgstr ""

#: ../../chapter5.rst:1935
msgid "Use prefixes and suffices to differentiate between like words rather than to cram details of meaning into the name itself."
msgstr ""

#: ../../chapter5.rst:1938
msgid "For instance, the phrase"
msgstr ""

#: ../../chapter5.rst:1944
msgid "is just as readable as"
msgstr ""

#: ../../chapter5.rst:1950
msgid "and cleaner as well. It is therefore preferable, unless we need an additional word called DONE (as a flag, for instance)."
msgstr ""

#: ../../chapter5.rst:1953
msgid "A final tip on naming:"
msgstr ""

#: ../../chapter5.rst:1957
msgid "Begin all hex numbers with \"0\" (zero) to avoid potential collisions with names."
msgstr ""

#: ../../chapter5.rst:1960
msgid "For example, write 0ADD, not ADD."
msgstr ""

#: ../../chapter5.rst:1962
msgid "By the way, don’t expect your Forth system to necessarily conform to the above conventions. The conventions are meant to be used in new applications."
msgstr ""

#: ../../chapter5.rst:1966
msgid "Forth was created and refined over many years by people who used it as a means to an end. At that time, it was neither reasonable nor possible to impose naming standards on a tool that was still growing and evolving."
msgstr ""

#: ../../chapter5.rst:1970
msgid "Had Forth been designed by committee, we would not love it so."
msgstr ""

#: ../../chapter5.rst:1973
msgid "More Tips for Readability"
msgstr ""

#: ../../chapter5.rst:1975
msgid "Here are some final suggestions to make your code more readable. (Definitions appear in :doc:`Appendix C<appendixc>`.)"
msgstr ""

#: ../../chapter5.rst:1978
msgid "One constant that pays for itself in most applications is ``BL`` (the ASCII value for “blank-space”)."
msgstr ""

#: ../../chapter5.rst:1981
msgid "The word ``ASCII`` is used primarily within colon definitions to free you from having to know the literal value of an ASCII character. For instance, instead of writing:"
msgstr ""

#: ../../chapter5.rst:1989
msgid "where 41 is the ASCII representation for right-parenthesis, you can write"
msgstr ""

#: ../../chapter5.rst:1996
msgid "A pair of words that can make dealing with booleans more readable are ``TRUE`` and ``FALSE``. With these additions you can write phrases such as"
msgstr ""

#: ../../chapter5.rst:2005
msgid "to set a flag or"
msgstr ""

#: ../../chapter5.rst:2011
msgid "to clear it."
msgstr ""

#: ../../chapter5.rst:2013
msgid "(I once used ``T`` and ``F``, but the words are needed so rarely I now heed the injunction against abbreviations.)"
msgstr ""

#: ../../chapter5.rst:2017
msgid "As part of your application (not necessarily part of your Forth system), you can take this idea a step further and define:"
msgstr ""

#: ../../chapter5.rst:2025
msgid "These words allow you to write:"
msgstr ""

#: ../../chapter5.rst:2037
msgid "Other names for these definitions include ``SET`` and ``RESET``, although ``SET`` and ``RESET`` most commonly use bit masks to manipulate individual bits."
msgstr ""

#: ../../chapter5.rst:2040
msgid "An often-used word is ``WITHIN``, which determines whether a given value lies within two other values. The syntax is:"
msgstr ""

#: ../../chapter5.rst:2048
msgid "where “n” is the value to be tested and “lo” and “hi” represent the range. ``WITHIN`` returns true if “n” is *greater-than or equal-to* “lo” and *less-than* “hi.” This use of the non-inclusive upper limit parallels the syntax of ``DO``  ``LOOP`` s."
msgstr ""

#: ../../chapter5.rst:2053
msgid "Moore recommends the word ``UNDER+``. It’s useful for adding a value to the number just under the top stack item, instead of to the top stack item. It could be implemented in high level as:"
msgstr ""

#: ../../chapter5.rst:2063
msgid "Summary"
msgstr ""

#: ../../chapter5.rst:2065
msgid "Maintainability requires readability. In this chapter we’ve enumerated various ways to make a source listing more readable. We’ve assumed a policy of making our code as self-documenting as possible. Techniques include listing organization, spacing and indenting, commenting, name choices, and special words that enhance clarity."
msgstr ""

#: ../../chapter5.rst:2071
msgid "We’ve mentioned only briefly auxiliary documentation, which includes all documentation apart from the listing itself. We won’t discuss auxiliary documentation further in this volume, but it remains an integral part of the software development process."
msgstr ""

#: ../../chapter5.rst:2077
msgid "REFERNCES"
msgstr ""

#: ../../chapter5.rst:2079
msgid "Gregory Stevenson, \"Documentation Priorities,\" **1981 FORML Conference Proceedings,**  p. 401."
msgstr ""

#: ../../chapter5.rst:2080
msgid "Joanne Lee, \"Quality Assurance in a ForthEnvironment,\" (Appendix A),  **1981 FORML Proceedings,**  p. 363."
msgstr ""

#: ../../chapter5.rst:2081
msgid "Edsger W. Dijkstra,  **Selected Writings onComputing: A Personal Perspective,**  New York, Springer Verlag, Inc.,1982."
msgstr ""

#: ../../chapter5.rst:2082
msgid "Henry Laxen, \"Choosing Names,\"  **Forth Dimensions,** vol. 4, no.\\ 4, Forth Interest Group."
msgstr ""

